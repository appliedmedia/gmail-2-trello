[
  {
    "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532553",
    "pull_request_review_id": 3014319788,
    "id": 2203532553,
    "node_id": "PRRC_kwDOD1hYKM6DVz0J",
    "diff_hunk": "@@ -0,0 +1,848 @@\n+/** Gmail2Trello Application - ES6 Class Version\n+ */\n+\n+var Gmail2Trello = Gmail2Trello || {}; // Namespace initialization - must be var to guarantee correct scope\n+\n+class App {\n+  constructor() {\n+    this.CHROME_SETTINGS_ID = 'g2t_user_settings';\n+    this.UNIQUE_URI_VAR = 'g2t_filename';\n+\n+    this.model = new Gmail2Trello.Model(this);\n+    this.gmailView = new Gmail2Trello.GmailView(this);\n+    this.popupView = new Gmail2Trello.PopupView(this);\n+\n+    this.bindEvents();\n+  }\n+\n+  bindEvents() {\n+    const self = this;\n+\n+    /*** Data's events binding ***/\n+    this.model.event.addListener('onBeforeAuthorize', function () {\n+      self.popupView.bindData(''); // Intentionally blank\n+      self.popupView.showMessage(self, 'Authorizing...');\n+    });\n+\n+    this.model.event.addListener('onAuthorizeFail', function () {\n+      // self.model.isInitialized = false;\n+      self.popupView.showMessage(\n+        self,\n+        'Trello authorization failed <button id=\"showsignout\">Sign out and try again</button>'\n+      );\n+    });\n+\n+    this.model.event.addListener('onAuthorized', function () {\n+      // g2t_log('onAuthorized');\n+      // g2t_log(\"Status: \" + Trello.authorized().toString());\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+    });\n+\n+    this.model.event.addListener('onBeforeLoadTrello', function () {\n+      self.popupView.showMessage(self, 'Loading Trello data...');\n+    });\n+\n+    this.model.event.addListener('onTrelloDataReady', function () {\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+\n+      self.popupView.bindData(self.model);\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloListSuccess', function () {\n+      self.popupView.updateLists();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloCardsSuccess', function () {\n+      self.popupView.updateCards();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloLabelsSuccess', function () {\n+      self.popupView.updateLabels();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloMembersSuccess', function () {\n+      self.popupView.updateMembers();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener(\n+      'onCardSubmitComplete',\n+      function (target, params) {\n+        self.popupView.displaySubmitCompleteForm();\n+        // If card lists or labels have been updated, reload:\n+        const data_k = params?.data || {};\n+        const emailId = data_k?.emailId || 0;\n+        const boardId_k = data_k?.data?.board?.id || 0;\n+        const listId_k = data_k?.data?.list?.id || 0;\n+        const cardId_k = data_k?.data?.card?.id || 0;\n+        const idBoard_k = data_k?.idBoard || 0;\n+        const idList_k = data_k?.idList || 0;\n+        const idCard_k = data_k?.idCard || 0;\n+        const boardId = boardId_k || idBoard_k || 0;\n+        const listId = listId_k || idList_k || 0;\n+        const cardId = cardId_k || idCard_k || 0;\n+        // NOTE (acoven@2020-05-23): Users expect when creating a brand new card,\n+        // we'll remember that new card ID and then keep defaulting to it for\n+        // subsequent updates to that email. That means we'll have to get the return\n+        // value/url from Trello and dissect that, potentially doing this update\n+        // in that routine:\n+        self.model.emailBoardListCardMapUpdate({\n+          emailId,\n+          boardId,\n+          listId,\n+          cardId,\n+        });\n+\n+        if (boardId) {\n+          self.model.loadTrelloLabels(boardId);\n+          self.model.loadTrelloMembers(boardId);\n+        }\n+        if (listId) {\n+          self.model.loadTrelloCards(listId);\n+        }\n+      }\n+    );\n+\n+    this.model.event.addListener('onAPIFailure', function (target, params) {\n+      self.popupView.displayAPIFailedForm(params);\n+    });\n+\n+    /*** PopupView's events binding ***/\n+\n+    this.popupView.event.addListener('onPopupVisible', function () {\n+      if (!self.model.isInitialized) {\n+        self.popupView.showMessage(self, 'Initializing...');\n+        self.popupView.$popupContent.hide();\n+        self.model.init();\n+      } else {\n+        self.popupView.reset();\n+      }\n+\n+      const trelloUser_k = self?.model?.trello?.user || {};\n+      const fullName = trelloUser_k?.fullName || '';\n+\n+      self.gmailView.parsingData = false;\n+      self.model.gmail = self.gmailView.parseData({ fullName });\n+      self.popupView.bindGmailData(self.model.gmail);\n+      self.popupView.event.fire('periodicChecks');\n+    });\n+\n+    this.popupView.event.addListener('periodicChecks', function () {\n+      setTimeout(function () {\n+        self.popupView.periodicChecks();\n+      }, 3000);\n+    });\n+\n+    this.popupView.event.addListener('onBoardChanged', function (target, params) {\n+      let boardId = params.boardId;\n+      if (boardId !== '_' && boardId !== '' && boardId !== null) {\n+        self.model.loadTrelloLists(boardId);\n+        self.model.loadTrelloLabels(boardId);\n+        self.model.loadTrelloMembers(boardId);\n+      }\n+    });\n+\n+    this.popupView.event.addListener('onListChanged', function (target, params) {\n+      let listId = params.listId;\n+      self.model.loadTrelloCards(listId);\n+    });\n+\n+    this.popupView.event.addListener('onSubmit', function () {\n+      self.model.submit();\n+    });\n+\n+    this.popupView.event.addListener('checkTrelloAuthorized', function () {\n+      self.popupView.showMessage(self, 'Authorizing...');\n+      self.model.checkTrelloAuthorized();\n+    });\n+\n+    this.popupView.event.addListener('onRequestDeauthorizeTrello', function () {\n+      g2t_log('onRequestDeauthorizeTrello');\n+      self.model.deauthorizeTrello();\n+      self.popupView.clearBoard();\n+    });\n+\n+    const eventDetectButton = function () {\n+      if (self.gmailView.preDetect()) {\n+        self.popupView.$toolBar = self.gmailView.$toolBar;\n+        self.popupView.confirmPopup();\n+      }\n+    };\n+\n+    this.popupView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    // GMailView's events:\n+\n+    this.gmailView.event.addListener('onDetected', function () {\n+      self.popupView.$toolBar = self.gmailView.$toolBar;\n+      self.popupView.init();\n+    });\n+\n+    this.gmailView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    chrome.runtime.onMessage.addListener(function (\n+      request,\n+      sender,\n+      sendResponse\n+    ) {\n+      if (request?.message === 'g2t_keyboard_shortcut') {\n+        self.popupView.showPopup();\n+      }\n+    });\n+  }\n+\n+  updateData() {\n+    const self = this;\n+\n+    const fullName = self?.model?.trello?.user?.fullName || '';\n+\n+    self.popupView.bindData(self.model);\n+\n+    self.gmailView.parsingData = false;\n+    self.model.gmail = self.gmailView.parseData({ fullName });\n+    self.popupView.bindGmailData(self.model.gmail);\n+  }\n+\n+  initialize() {\n+    const self = this;\n+\n+    this.model.isInitialized = false;\n+\n+    // g2t_log('App:initialize');\n+\n+    this.gmailView.detect();\n+\n+    service = analytics.getService('gmail-2-trello');\n+\n+    // Get a Tracker using your Google Analytics app Tracking ID.\n+    tracker = service.getTracker('G-0QPEDL7YDL'); // Was: UA-8469046-1 -> UA-42442437-4\n+\n+    // Record an \"appView\" each time the user launches your app or goes to a new\n+    // screen within the app.\n+    tracker.sendAppView('PopupView');\n+  }\n+\n+  /**\n+   * Correctly escape RegExp\n+   */\n+  escapeRegExp(str) {\n+    return str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n+  }\n+\n+  /**\n+   * Utility routine to replace variables\n+   */\n+  replacer(text, dict) {\n+    let self = this;\n+\n+    if (!text || text.length < 1) {\n+      // g2t_log('Require text!');\n+      return '';\n+    } else if (!dict || dict.length < 2) {\n+      g2t_log('replacer: Require dictionary!');\n+      return text;\n+    }\n+\n+    let re, new_text;\n+    const replacify = function () {\n+      g2t_each(dict, function (value, key) {\n+        re = new RegExp(`%${self.escapeRegExp(key)}%`, 'gi');\n+        new_text = text.replace(re, value);\n+        text = new_text;\n+      });\n+    };\n+\n+    let runaway_max = 3;\n+    while (text.indexOf('%') !== -1 && runaway_max-- > 0) {\n+      replacify();\n+    }\n+\n+    return text;\n+  }\n+\n+  /**\n+   * Make displayable URI\n+   */\n+  uriForDisplay(uri) {\n+    const uri_display_trigger_length_k = 20;\n+    const uri_length_max_k = 40;\n+    let uri_display = uri || '';\n+    if (uri_display.length > uri_display_trigger_length_k) {\n+      let re = RegExp('^\\\\w+://([\\\\w./_-]+).*?([\\\\w._-]*)$');\n+      let matched = uri_display.match(re);\n+      if (matched && matched.length > 1) {\n+        const filename_k =\n+          matched[2].length < uri_length_max_k\n+            ? matched[2]\n+            : matched[2].slice(-uri_length_max_k);\n+        let prelude = matched[1].substr(0, uri_length_max_k);\n+        if (matched[1].length > uri_length_max_k) {\n+          prelude += '...';\n+        } else if (filename_k.length > 0) {\n+          prelude += ':';\n+        }\n+\n+        uri_display = prelude + filename_k;\n+      }\n+    }\n+    return uri_display;\n+  }\n+\n+  /**\n+   * Make anchored backlink\n+   */\n+  anchorMarkdownify(text, href, comment) {\n+    let text1 = (text || '').trim();\n+    let text1lc = text1.toLowerCase();\n+    let href1 = (href || '').trim();\n+    let href1lc = href1.toLowerCase();\n+    let comment1 = (comment || '').trim();\n+\n+    let retn = '';\n+\n+    if (text1.length < 1 && href1.length < 1) {\n+      // Intetionally blank\n+    } else if (text1lc === href1lc) {\n+      retn = ` <${href1}> `; // This renders correctly in Trello as a sole URL\n+      // NOTE (Ace, 17-Feb-2017): Turns out Trello doesn't support markdown [] only, so we'll construct a nice displayable text vs url:\n+      // text1 = this.uriForDisplay(text1);\n+    } else if (`mailto:${text1lc}` === href1lc) {\n+      retn = ` <${text1}> `; // This renders correctly in Trello as a mailto: url\n+    } else {\n+      const comment1QuotedSpaced = comment1.length > 0 ? ` \"${comment1}\"` : '';\n+      retn = ` [${text1}](<${href1}>${comment1QuotedSpaced}) `;\n+    }\n+\n+    return retn;\n+  }\n+\n+  /**\n+   * Split an email into name and domain\n+   */\n+  splitEmailDomain(email = '') {\n+    const split = email.split('@');\n+    const name = split[0] || '';\n+    const domain = split[1] || '';\n+    return {\n+      name,\n+      domain,\n+    };\n+  }\n+\n+  /**\n+   * Add trailing char if not empty:\n+   */\n+  addChar(front = '', back = '', addChar = ' ') {\n+    if (front.length > 0) {\n+      if (back.length > 0) {\n+        return `${front}${addChar}${back}`;\n+      } else {\n+        return `${front}${addChar}`;\n+      }\n+    } else if (back.length > 0) {\n+      return `${addChar}${back}`;\n+    } else {\n+      return '';\n+    }\n+  }\n+\n+  /**\n+   * Add trailing space if not empty:\n+   */\n+  addSpace(front = '', back = '') {\n+    return this.addChar(front, back, ' ');\n+  }\n+\n+  /**\n+   * Add trailing CRLF if not empty:\n+   */\n+  addCRLF(front = '', back = '') {\n+    return this.addChar(front, back, '\\n');\n+  }\n+\n+  /**\n+   * Markdownify a text block\n+   */\n+  markdownify($emailBody, features, preprocess) {\n+    if (!$emailBody || $emailBody.length < 1) {\n+      g2t_log('markdownify: Require emailBody!');\n+      return;\n+    }\n+    const self = this;\n+\n+    const min_text_length_k = 4;\n+    const max_replace_attempts_k = 10;\n+    const regexp_k = {\n+      begin: '(^|\\\\s+|<|\\\\[|\\\\(|\\\\b|(?=\\\\W+))',\n+      end: '($|\\\\s+|>|\\\\]|\\\\)|\\\\b|(?=\\\\W+))',\n+    };\n+    const unique_placeholder_k = 'g2t_placeholder:'; // Unique placeholder tag\n+\n+    let count = 0;\n+    let replacer_dict = {};\n+\n+    const featureEnabled = (elementTag = '') =>\n+      features === false ? false : features?.[elementTag] !== false;\n+\n+    let $html = $emailBody || ''; // Was: $emailBody.innerHTML || \"\";\n+    // let body = $emailBody.text() || \"\";\n+    let body = $emailBody.html() || '';\n+\n+    // Different encodings handle CRLF differently, so we'll process the main body as html and convert to text:\n+    // Convert paragraph marker to two returns:\n+    let replaced = body.replace(/\\s*[\\n\\r]*<p[^>]*>\\s*[\\n\\r]*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // Convert br marker to one return:\n+    replaced = body.replace(/\\s*[\\n\\r]*<br[^>]*>\\s*[\\n\\r]*/g, '\\n');\n+    body = replaced;\n+\n+    // Remove all other html markers:\n+    replaced = body.replace(/<[^>]*>/g, '');\n+    body = replaced;\n+\n+    // Decode HTML entities:\n+    replaced = self.decodeEntities(body);\n+    body = replaced;\n+\n+    // Replace hr:\n+    replaced = body.replace(/\\s*-{3,}\\s*/g, '---\\n');\n+    body = replaced;\n+\n+    // Convert crlf x 2 (or more) to paragraph markers:\n+    replaced = body.replace(/(\\s*[\\n\\r]\\s*){2,}/g, '<p />\\n');\n+    body = replaced;\n+\n+    let toProcess = {};\n+\n+    /**\n+     * 5 explicit steps in 3 passes:\n+     * (1) Collect tagged items\n+     * (2) Remove duplicates\n+     * (3) Sort force-lowercase by length\n+     * (4) Replace with placeholder\n+     * (5) Replace placeholders with final text\n+     */\n+    const sortAndPlaceholderize = function (tooProcess) {\n+      if (tooProcess) {\n+        g2t_each(\n+          Object.keys(tooProcess).sort(function (a, b) {\n+            // Go by order of largest to smallest\n+            return b.length - a.length;\n+          }),\n+          function (value) {\n+            const replace = tooProcess[value];\n+            const swap = `${unique_placeholder_k}${(count++).toString()}`;\n+            const re = new RegExp(\n+              regexp_k.begin + self.escapeRegExp(value) + regexp_k.end,\n+              'gi'\n+            );\n+            const replaced = body.replace(re, `%${swap}%`); // Replace occurance with placeholder\n+            if (body !== replaced) {\n+              body = replaced;\n+              replacer_dict[swap] = replace;\n+            }\n+          }\n+        );\n+      }\n+    };\n+    const processMarkdown = function (elementTag, replaceText) {\n+      if (elementTag && replaceText && featureEnabled(elementTag)) {\n+        toProcess = preprocess[elementTag] || {};\n+        $(elementTag, $html).each(function (index, value) {\n+          let text = ($(this).text() || '').trim();\n+          if (text && text.length > min_text_length_k) {\n+            let replace = self.replacer(replaceText, { text: text });\n+            toProcess[text.toLowerCase()] = replace; // Intentionally overwrites duplicates\n+          }\n+        });\n+        sortAndPlaceholderize(toProcess);\n+      }\n+    };\n+    /**\n+     * Repeat replace for max attempts or when done, whatever comes first\n+     */\n+    const repeatReplace = function (body, inRegexp, replaceWith) {\n+      let replace1 = '';\n+      for (let iter = max_replace_attempts_k; iter > 0; iter--) {\n+        replace1 = body.replace(inRegexp, replaceWith);\n+        if (body === replace1) {\n+          iter = 0; // All done\n+        } else {\n+          body = replace1;\n+        }\n+      }\n+      return body;\n+    };\n+\n+    // bullet lists:\n+    // ul li -> \" * \"\n+    processMarkdown('ul li', '<p />* %text%<p />');\n+\n+    // numeric lists:\n+    // ol li -> \" 1. \"\n+    processMarkdown('ol li', '<p />1. %text%<p />');\n+\n+    // headers:\n+    // H1 -> #\n+    // H2 -> ##\n+    // H3 -> ###\n+    // H4 -> ####\n+    // H5 -> #####\n+    // H6 -> ######\n+    if (featureEnabled('h')) {\n+      toProcess = preprocess['h'] || {};\n+      $(':header', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let nodeName = $(this).prop('nodeName') || '0';\n+        if (nodeName && text && text.length > min_text_length_k) {\n+          let x = nodeName.substr(-1);\n+          toProcess[text.toLowerCase()] = `\\n${'#'.repeat(x)} ${text}\\n`; // Intentionally overwrites duplicates\n+        }\n+      });\n+      sortAndPlaceholderize(toProcess);\n+    }\n+\n+    replaced = this.replacer(body, replacer_dict); // Replace initial batch of <div> like placeholders\n+    body = replaced;\n+    replacer_dict = {}; // Reset\n+    count = 0; // Reset\n+\n+    // bold: b -> **text**\n+    processMarkdown('b', ' **%text%** ');\n+\n+    // italics: i -> _text_\n+    processMarkdown('i', ' _%text%_ ');\n+\n+    // links:\n+    // a -> [text](html)\n+    if (featureEnabled('a')) {\n+      toProcess = preprocess['a'] || {};\n+      $('a', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let href = ($(this).prop('href') || '').trim(); // Was attr\n+        /*\n+              var uri_display = self.uriForDisplay(href);\n+              var comment = ' \"' + text + ' via ' + uri_display + '\"';\n+              var re = new RegExp(self.escapeRegExp(text), \"i\");\n+              if (uri.match(re)) {\n+                  comment = ' \"Open ' + uri_display + '\"';\n+              }\n+              */\n+        if (href && text && text.length >= min_text_length_k) {\n+          toProcess[text.toLowerCase()] = self.anchorMarkdownify(text, href); // Comment seemed like too much extra text // Intentionally overwrites duplicates\n+        }\n+      });\n+      sortAndPlaceholderize(toProcess);\n+    }\n+\n+    /* DISABLED (Ace, 16-Jan-2017): Images kinda make a mess, until requested lets not markdownify them:\n+      // images:\n+      // img -> ![alt_text](html)\n+      if (featureEnabled('img')) {\n+          $('img', $html).each(function(index, value) {\n+              var text = ($(this).prop(\"alt\") || \"\").trim(); // Was attr\n+              var href = ($(this).prop(\"src\") || \"\").trim(); // Was attr\n+              // var uri_display = self.uriForDisplay(href);\n+              if (href && text && text.length >= min_text_length_k) {\n+                  toProcess[text.toLowerCase()] = self.anchorMarkdownify(text, href); // Comment seemed like too much extra text // Intentionally overwrites duplicates\n+              }\n+          });\n+          sortAndPlaceholderize(toProcess);\n+      }\n+      */\n+\n+    replaced = this.replacer(body, replacer_dict); // Replace second batch of <span> like placeholders\n+    body = replaced;\n+\n+    // Replace bullets following a CRLF:\n+    replaced = body.replace(/\\s*[\\n\\r]+\\s*[·-]+\\s*/g, '<p />* '); // = [\\u00B7\\u2022]\n+    body = replaced;\n+\n+    // Replace remaining bullets with asterisks:\n+    replaced = body.replace(/[·]/g, '*');\n+    body = replaced;\n+\n+    // ORDER MATTERS FOR THIS NEXT SET:\n+    // (1) Replace <space>CRLF<space> with just CR:\n+    replaced = body.replace(/\\s*[\\n\\r]+\\s*/g, '\\n');\n+    body = replaced;\n+\n+    // (2) Replace 2 or more spaces with just one:\n+    replaced = repeatReplace(body, new RegExp('\\\\s{2,}', 'g'), ' ');\n+    body = replaced;\n+\n+    // (3) Replace paragraph markers with CR+CR:\n+    replaced = body.replace(/\\s*<p \\/>\\s*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // (4) Replace 3 or more CRs with just two:\n+    replaced = repeatReplace(body, new RegExp('\\\\n{3,}', 'g'), '\\n\\n');\n+    body = replaced;\n+\n+    // (5) Trim excess at beginning and end:\n+    replaced = body.trim();\n+    body = replaced;\n+\n+    return body;\n+  }\n+\n+  /**\n+   * Determine luminance of a color so we can augment with darker/lighter background\n+   */\n+  luminance(color) {\n+    let bkColorLight = 'lightGray'; // or white\n+    let bkColorDark = 'darkGray'; // 'gray' is even darker\n+    let bkColorReturn = bkColorLight;\n+\n+    let re = new RegExp('rgb\\\\D+(\\\\d+)\\\\D+(\\\\d+)\\\\D+(\\\\d+)');\n+    let matched = color.match(re, 'i');\n+    if (matched && matched.length > 2) {\n+      // 0 is total string:\n+      let r = matched[1];\n+      let g = matched[2];\n+      let b = matched[3];\n+      // var 1 = matched[4]; // if alpha is provided\n+\n+      let luma = 0.2126 * r + 0.7152 * g + 0.0722 * b; // per ITU-R BT.709\n+\n+      if (luma < 40) {\n+        bkColorReturn = bkColorDark;\n+      } else {\n+        bkColorReturn = bkColorLight;\n+      }\n+    } else {\n+      bkColorReturn = bkColorLight; // RegExp failed, assume dark color\n+    }\n+\n+    return 'inherit'; // Use: bkColorReturn if you want to adjust background based on text perceived brightness\n+  }\n+\n+  /**\n+   * HTML bookend a string\n+   */\n+  bookend(bookend, text, style) {\n+    return (\n+      '<' +\n+      bookend +\n+      (style ? ' style=\"' + style + '\"' : '') +\n+      '>' +\n+      (text || '') +\n+      '</' +\n+      bookend +\n+      '>'\n+    );\n+  }\n+\n+  /**\n+   * Get selected text\n+   * http://stackoverflow.com/questions/5379120/get-the-highlighted-selected-text\n+   */\n+  getSelectedText() {\n+    let text = '';\n+    let activeEl = document.activeElement;\n+    let activeElTagName = activeEl ? activeEl.tagName.toLowerCase() : null;\n+    if (\n+      (activeElTagName == 'textarea' || activeElTagName == 'input') &&\n+      /^(?:text|search|password|tel|url)$/i.test(activeEl.type) &&\n+      typeof activeEl.selectionStart == 'number'\n+    ) {\n+      text = activeEl.value\n+        .slice(activeEl.selectionStart, activeEl.selectionEnd)\n+        .trim();\n+    } else if (document.selection) {\n+      text = document.selection.createRange().text.trim();\n+    } else if (document.getSelection) {\n+      text = document.getSelection().toString().trim();\n+    } else if (window.getSelection) {\n+      text = window.getSelection().toString().trim();\n+    }\n+    return text;\n+  }\n+\n+  /**\n+   * Truncate a string\n+   */\n+  truncate(text, max, add) {\n+    let retn = text || '';\n+    const add_k = this.decodeEntities(add || '');\n+    const max_k = max - add_k.length;\n+\n+    if (text && text.length > max_k) {\n+      retn = text.slice(0, max_k) + add_k;\n+    }\n+    return retn;\n+  }\n+\n+  /***\n+   * Middle-truncate a string\n+   */\n+  midTruncate(text, max, add) {\n+    let retn = text || '';\n+    const add_k = this.decodeEntities(add || '');\n+    const max_k = Math.abs((max || 0) - add_k.length);\n+    const mid_k = (max_k + 0.01) / 2;\n+\n+    if (text && text.length > max_k) {\n+      retn = text.slice(0, mid_k + 1) + add_k + text.slice(-mid_k);\n+    }\n+    return retn;\n+  }\n+\n+  /**\n+   * Load settings\n+   */\n+  loadSettings(popup) {\n+    const self = this;\n+    const setID = self.CHROME_SETTINGS_ID;\n+    chrome.storage.sync.get(setID, function (response) {\n+      if (response?.[setID]) {\n+        // NOTE (Ace, 7-Feb-2017): Might need to store these off the app object:\n+        try {\n+          self.popupView.data.settings = JSON.parse(response[setID]);\n+        } catch (err) {\n+          g2t_log(\n+            'loadSettings: JSON parse failed! Error: ' + JSON.stringify(err)\n+          );\n+        }\n+      }\n+      if (popup) {\n+        popup.init_popup();\n+        self.updateData();\n+      }\n+    });\n+  }\n+\n+  /**\n+   * Save settings\n+   */\n+  saveSettings() {\n+    const self = this;\n+    const setID = self.CHROME_SETTINGS_ID;\n+    let settings = Object.assign({}, self.popupView.data.settings);\n+\n+    // Delete large, potentially needing secure, data bits:\n+    settings.description = '';\n+    settings.title = '';\n+    settings.attachments = [];\n+    settings.images = [];\n+    delete settings.description;\n+    delete settings.title;\n+    delete settings.attachments;\n+    delete settings.images;\n+\n+    const settings_string_k = JSON.stringify(settings);\n+\n+    hash = {};\n+    hash[setID] = settings_string_k;",
    "path": "chrome_manifest_v3/class_app.js",
    "commit_id": "3bbc7b0b5b5abfda366260c45d6f2cecebf28af3",
    "original_commit_id": "ae0a391b6759338b0ec3c3292da07e458841ab71",
    "user": {
      "login": "coderabbitai[bot]",
      "id": 136622811,
      "node_id": "BOT_kgDOCCSy2w",
      "avatar_url": "https://avatars.githubusercontent.com/in/347564?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/coderabbitai%5Bbot%5D",
      "html_url": "https://github.com/apps/coderabbitai",
      "followers_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "_⚠️ Potential issue_\n\n**Declare hash. Missing declaration.**\n\n\n```diff\n-    hash = {};\n+    const hash = {};\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>📝 Committable suggestion</summary>\n\n> ‼️ **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n    const hash = {};\n    hash[setID] = settings_string_k;\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>🤖 Prompt for AI Agents</summary>\n\n```\nIn chrome_manifest_v3/class_app.js around lines 745 to 746, the variable 'hash'\nis used without declaration. Declare 'hash' using 'let' or 'const' before\nassigning it an empty object to ensure proper variable scoping and avoid\npotential reference errors.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:lion -->\n\n<!-- This is an auto-generated reply by CodeRabbit -->\n\n✅ Addressed in commit dfe3bc8\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "created_at": "2025-07-13T21:43:19Z",
    "updated_at": "2025-07-14T04:56:29Z",
    "html_url": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203532553",
    "pull_request_url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532553"
      },
      "html": {
        "href": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203532553"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532553/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 745,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 746,
    "side": "RIGHT",
    "original_position": 746,
    "position": null,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532554",
    "pull_request_review_id": 3014319788,
    "id": 2203532554,
    "node_id": "PRRC_kwDOD1hYKM6DVz0K",
    "diff_hunk": "@@ -0,0 +1,848 @@\n+/** Gmail2Trello Application - ES6 Class Version\n+ */\n+\n+var Gmail2Trello = Gmail2Trello || {}; // Namespace initialization - must be var to guarantee correct scope\n+\n+class App {\n+  constructor() {\n+    this.CHROME_SETTINGS_ID = 'g2t_user_settings';\n+    this.UNIQUE_URI_VAR = 'g2t_filename';\n+\n+    this.model = new Gmail2Trello.Model(this);\n+    this.gmailView = new Gmail2Trello.GmailView(this);\n+    this.popupView = new Gmail2Trello.PopupView(this);\n+\n+    this.bindEvents();\n+  }\n+\n+  bindEvents() {\n+    const self = this;\n+\n+    /*** Data's events binding ***/\n+    this.model.event.addListener('onBeforeAuthorize', function () {\n+      self.popupView.bindData(''); // Intentionally blank\n+      self.popupView.showMessage(self, 'Authorizing...');\n+    });\n+\n+    this.model.event.addListener('onAuthorizeFail', function () {\n+      // self.model.isInitialized = false;\n+      self.popupView.showMessage(\n+        self,\n+        'Trello authorization failed <button id=\"showsignout\">Sign out and try again</button>'\n+      );\n+    });\n+\n+    this.model.event.addListener('onAuthorized', function () {\n+      // g2t_log('onAuthorized');\n+      // g2t_log(\"Status: \" + Trello.authorized().toString());\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+    });\n+\n+    this.model.event.addListener('onBeforeLoadTrello', function () {\n+      self.popupView.showMessage(self, 'Loading Trello data...');\n+    });\n+\n+    this.model.event.addListener('onTrelloDataReady', function () {\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+\n+      self.popupView.bindData(self.model);\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloListSuccess', function () {\n+      self.popupView.updateLists();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloCardsSuccess', function () {\n+      self.popupView.updateCards();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloLabelsSuccess', function () {\n+      self.popupView.updateLabels();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloMembersSuccess', function () {\n+      self.popupView.updateMembers();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener(\n+      'onCardSubmitComplete',\n+      function (target, params) {\n+        self.popupView.displaySubmitCompleteForm();\n+        // If card lists or labels have been updated, reload:\n+        const data_k = params?.data || {};\n+        const emailId = data_k?.emailId || 0;\n+        const boardId_k = data_k?.data?.board?.id || 0;\n+        const listId_k = data_k?.data?.list?.id || 0;\n+        const cardId_k = data_k?.data?.card?.id || 0;\n+        const idBoard_k = data_k?.idBoard || 0;\n+        const idList_k = data_k?.idList || 0;\n+        const idCard_k = data_k?.idCard || 0;\n+        const boardId = boardId_k || idBoard_k || 0;\n+        const listId = listId_k || idList_k || 0;\n+        const cardId = cardId_k || idCard_k || 0;\n+        // NOTE (acoven@2020-05-23): Users expect when creating a brand new card,\n+        // we'll remember that new card ID and then keep defaulting to it for\n+        // subsequent updates to that email. That means we'll have to get the return\n+        // value/url from Trello and dissect that, potentially doing this update\n+        // in that routine:\n+        self.model.emailBoardListCardMapUpdate({\n+          emailId,\n+          boardId,\n+          listId,\n+          cardId,\n+        });\n+\n+        if (boardId) {\n+          self.model.loadTrelloLabels(boardId);\n+          self.model.loadTrelloMembers(boardId);\n+        }\n+        if (listId) {\n+          self.model.loadTrelloCards(listId);\n+        }\n+      }\n+    );\n+\n+    this.model.event.addListener('onAPIFailure', function (target, params) {\n+      self.popupView.displayAPIFailedForm(params);\n+    });\n+\n+    /*** PopupView's events binding ***/\n+\n+    this.popupView.event.addListener('onPopupVisible', function () {\n+      if (!self.model.isInitialized) {\n+        self.popupView.showMessage(self, 'Initializing...');\n+        self.popupView.$popupContent.hide();\n+        self.model.init();\n+      } else {\n+        self.popupView.reset();\n+      }\n+\n+      const trelloUser_k = self?.model?.trello?.user || {};\n+      const fullName = trelloUser_k?.fullName || '';\n+\n+      self.gmailView.parsingData = false;\n+      self.model.gmail = self.gmailView.parseData({ fullName });\n+      self.popupView.bindGmailData(self.model.gmail);\n+      self.popupView.event.fire('periodicChecks');\n+    });\n+\n+    this.popupView.event.addListener('periodicChecks', function () {\n+      setTimeout(function () {\n+        self.popupView.periodicChecks();\n+      }, 3000);\n+    });\n+\n+    this.popupView.event.addListener('onBoardChanged', function (target, params) {\n+      let boardId = params.boardId;\n+      if (boardId !== '_' && boardId !== '' && boardId !== null) {\n+        self.model.loadTrelloLists(boardId);\n+        self.model.loadTrelloLabels(boardId);\n+        self.model.loadTrelloMembers(boardId);\n+      }\n+    });\n+\n+    this.popupView.event.addListener('onListChanged', function (target, params) {\n+      let listId = params.listId;\n+      self.model.loadTrelloCards(listId);\n+    });\n+\n+    this.popupView.event.addListener('onSubmit', function () {\n+      self.model.submit();\n+    });\n+\n+    this.popupView.event.addListener('checkTrelloAuthorized', function () {\n+      self.popupView.showMessage(self, 'Authorizing...');\n+      self.model.checkTrelloAuthorized();\n+    });\n+\n+    this.popupView.event.addListener('onRequestDeauthorizeTrello', function () {\n+      g2t_log('onRequestDeauthorizeTrello');\n+      self.model.deauthorizeTrello();\n+      self.popupView.clearBoard();\n+    });\n+\n+    const eventDetectButton = function () {\n+      if (self.gmailView.preDetect()) {\n+        self.popupView.$toolBar = self.gmailView.$toolBar;\n+        self.popupView.confirmPopup();\n+      }\n+    };\n+\n+    this.popupView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    // GMailView's events:\n+\n+    this.gmailView.event.addListener('onDetected', function () {\n+      self.popupView.$toolBar = self.gmailView.$toolBar;\n+      self.popupView.init();\n+    });\n+\n+    this.gmailView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    chrome.runtime.onMessage.addListener(function (\n+      request,\n+      sender,\n+      sendResponse\n+    ) {\n+      if (request?.message === 'g2t_keyboard_shortcut') {\n+        self.popupView.showPopup();\n+      }\n+    });\n+  }\n+\n+  updateData() {\n+    const self = this;\n+\n+    const fullName = self?.model?.trello?.user?.fullName || '';\n+\n+    self.popupView.bindData(self.model);\n+\n+    self.gmailView.parsingData = false;\n+    self.model.gmail = self.gmailView.parseData({ fullName });\n+    self.popupView.bindGmailData(self.model.gmail);\n+  }\n+\n+  initialize() {\n+    const self = this;\n+\n+    this.model.isInitialized = false;\n+\n+    // g2t_log('App:initialize');\n+\n+    this.gmailView.detect();\n+\n+    service = analytics.getService('gmail-2-trello');\n+\n+    // Get a Tracker using your Google Analytics app Tracking ID.\n+    tracker = service.getTracker('G-0QPEDL7YDL'); // Was: UA-8469046-1 -> UA-42442437-4\n+\n+    // Record an \"appView\" each time the user launches your app or goes to a new\n+    // screen within the app.\n+    tracker.sendAppView('PopupView');\n+  }\n+\n+  /**\n+   * Correctly escape RegExp\n+   */\n+  escapeRegExp(str) {\n+    return str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n+  }\n+\n+  /**\n+   * Utility routine to replace variables\n+   */\n+  replacer(text, dict) {\n+    let self = this;",
    "path": "chrome_manifest_v3/class_app.js",
    "commit_id": "3bbc7b0b5b5abfda366260c45d6f2cecebf28af3",
    "original_commit_id": "ae0a391b6759338b0ec3c3292da07e458841ab71",
    "user": {
      "login": "coderabbitai[bot]",
      "id": 136622811,
      "node_id": "BOT_kgDOCCSy2w",
      "avatar_url": "https://avatars.githubusercontent.com/in/347564?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/coderabbitai%5Bbot%5D",
      "html_url": "https://github.com/apps/coderabbitai",
      "followers_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "_🛠️ Refactor suggestion_\n\n**Use const for self.**\n\nPer project convention.\n\n```diff\n-    let self = this;\n+    const self = this;\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>📝 Committable suggestion</summary>\n\n> ‼️ **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n    const self = this;\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>🧰 Tools</summary>\n\n<details>\n<summary>🪛 Biome (1.9.4)</summary>\n\n[error] 245-245: This let declares a variable that is only assigned once.\n\n'self' is never reassigned.\n\nSafe fix: Use const instead.\n\n\n(lint/style/useConst)\n\n</details>\n\n</details>\n\n<details>\n<summary>🤖 Prompt for AI Agents</summary>\n\n```\nIn chrome_manifest_v3/class_app.js at line 245, change the declaration of the\nvariable 'self' from 'let' to 'const' to follow the project convention of using\nconst for variables that are not reassigned.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:lion -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->\n\n✅ Addressed in commit f609e13",
    "created_at": "2025-07-13T21:43:19Z",
    "updated_at": "2025-07-14T01:51:54Z",
    "html_url": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203532554",
    "pull_request_url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532554"
      },
      "html": {
        "href": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203532554"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532554/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 245,
    "side": "RIGHT",
    "original_position": 245,
    "position": null,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532555",
    "pull_request_review_id": 3014319788,
    "id": 2203532555,
    "node_id": "PRRC_kwDOD1hYKM6DVz0L",
    "diff_hunk": "@@ -0,0 +1,848 @@\n+/** Gmail2Trello Application - ES6 Class Version\n+ */\n+\n+var Gmail2Trello = Gmail2Trello || {}; // Namespace initialization - must be var to guarantee correct scope\n+\n+class App {\n+  constructor() {\n+    this.CHROME_SETTINGS_ID = 'g2t_user_settings';\n+    this.UNIQUE_URI_VAR = 'g2t_filename';\n+\n+    this.model = new Gmail2Trello.Model(this);\n+    this.gmailView = new Gmail2Trello.GmailView(this);\n+    this.popupView = new Gmail2Trello.PopupView(this);\n+\n+    this.bindEvents();\n+  }\n+\n+  bindEvents() {\n+    const self = this;\n+\n+    /*** Data's events binding ***/\n+    this.model.event.addListener('onBeforeAuthorize', function () {\n+      self.popupView.bindData(''); // Intentionally blank\n+      self.popupView.showMessage(self, 'Authorizing...');\n+    });\n+\n+    this.model.event.addListener('onAuthorizeFail', function () {\n+      // self.model.isInitialized = false;\n+      self.popupView.showMessage(\n+        self,\n+        'Trello authorization failed <button id=\"showsignout\">Sign out and try again</button>'\n+      );\n+    });\n+\n+    this.model.event.addListener('onAuthorized', function () {\n+      // g2t_log('onAuthorized');\n+      // g2t_log(\"Status: \" + Trello.authorized().toString());\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+    });\n+\n+    this.model.event.addListener('onBeforeLoadTrello', function () {\n+      self.popupView.showMessage(self, 'Loading Trello data...');\n+    });\n+\n+    this.model.event.addListener('onTrelloDataReady', function () {\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+\n+      self.popupView.bindData(self.model);\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloListSuccess', function () {\n+      self.popupView.updateLists();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloCardsSuccess', function () {\n+      self.popupView.updateCards();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloLabelsSuccess', function () {\n+      self.popupView.updateLabels();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloMembersSuccess', function () {\n+      self.popupView.updateMembers();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener(\n+      'onCardSubmitComplete',\n+      function (target, params) {\n+        self.popupView.displaySubmitCompleteForm();\n+        // If card lists or labels have been updated, reload:\n+        const data_k = params?.data || {};\n+        const emailId = data_k?.emailId || 0;\n+        const boardId_k = data_k?.data?.board?.id || 0;\n+        const listId_k = data_k?.data?.list?.id || 0;\n+        const cardId_k = data_k?.data?.card?.id || 0;\n+        const idBoard_k = data_k?.idBoard || 0;\n+        const idList_k = data_k?.idList || 0;\n+        const idCard_k = data_k?.idCard || 0;\n+        const boardId = boardId_k || idBoard_k || 0;\n+        const listId = listId_k || idList_k || 0;\n+        const cardId = cardId_k || idCard_k || 0;\n+        // NOTE (acoven@2020-05-23): Users expect when creating a brand new card,\n+        // we'll remember that new card ID and then keep defaulting to it for\n+        // subsequent updates to that email. That means we'll have to get the return\n+        // value/url from Trello and dissect that, potentially doing this update\n+        // in that routine:\n+        self.model.emailBoardListCardMapUpdate({\n+          emailId,\n+          boardId,\n+          listId,\n+          cardId,\n+        });\n+\n+        if (boardId) {\n+          self.model.loadTrelloLabels(boardId);\n+          self.model.loadTrelloMembers(boardId);\n+        }\n+        if (listId) {\n+          self.model.loadTrelloCards(listId);\n+        }\n+      }\n+    );\n+\n+    this.model.event.addListener('onAPIFailure', function (target, params) {\n+      self.popupView.displayAPIFailedForm(params);\n+    });\n+\n+    /*** PopupView's events binding ***/\n+\n+    this.popupView.event.addListener('onPopupVisible', function () {\n+      if (!self.model.isInitialized) {\n+        self.popupView.showMessage(self, 'Initializing...');\n+        self.popupView.$popupContent.hide();\n+        self.model.init();\n+      } else {\n+        self.popupView.reset();\n+      }\n+\n+      const trelloUser_k = self?.model?.trello?.user || {};\n+      const fullName = trelloUser_k?.fullName || '';\n+\n+      self.gmailView.parsingData = false;\n+      self.model.gmail = self.gmailView.parseData({ fullName });\n+      self.popupView.bindGmailData(self.model.gmail);\n+      self.popupView.event.fire('periodicChecks');\n+    });\n+\n+    this.popupView.event.addListener('periodicChecks', function () {\n+      setTimeout(function () {\n+        self.popupView.periodicChecks();\n+      }, 3000);\n+    });\n+\n+    this.popupView.event.addListener('onBoardChanged', function (target, params) {\n+      let boardId = params.boardId;\n+      if (boardId !== '_' && boardId !== '' && boardId !== null) {\n+        self.model.loadTrelloLists(boardId);\n+        self.model.loadTrelloLabels(boardId);\n+        self.model.loadTrelloMembers(boardId);\n+      }\n+    });\n+\n+    this.popupView.event.addListener('onListChanged', function (target, params) {\n+      let listId = params.listId;\n+      self.model.loadTrelloCards(listId);\n+    });\n+\n+    this.popupView.event.addListener('onSubmit', function () {\n+      self.model.submit();\n+    });\n+\n+    this.popupView.event.addListener('checkTrelloAuthorized', function () {\n+      self.popupView.showMessage(self, 'Authorizing...');\n+      self.model.checkTrelloAuthorized();\n+    });\n+\n+    this.popupView.event.addListener('onRequestDeauthorizeTrello', function () {\n+      g2t_log('onRequestDeauthorizeTrello');\n+      self.model.deauthorizeTrello();\n+      self.popupView.clearBoard();\n+    });\n+\n+    const eventDetectButton = function () {\n+      if (self.gmailView.preDetect()) {\n+        self.popupView.$toolBar = self.gmailView.$toolBar;\n+        self.popupView.confirmPopup();\n+      }\n+    };\n+\n+    this.popupView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    // GMailView's events:\n+\n+    this.gmailView.event.addListener('onDetected', function () {\n+      self.popupView.$toolBar = self.gmailView.$toolBar;\n+      self.popupView.init();\n+    });\n+\n+    this.gmailView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    chrome.runtime.onMessage.addListener(function (\n+      request,\n+      sender,\n+      sendResponse\n+    ) {\n+      if (request?.message === 'g2t_keyboard_shortcut') {\n+        self.popupView.showPopup();\n+      }\n+    });\n+  }\n+\n+  updateData() {\n+    const self = this;\n+\n+    const fullName = self?.model?.trello?.user?.fullName || '';\n+\n+    self.popupView.bindData(self.model);\n+\n+    self.gmailView.parsingData = false;\n+    self.model.gmail = self.gmailView.parseData({ fullName });\n+    self.popupView.bindGmailData(self.model.gmail);\n+  }\n+\n+  initialize() {\n+    const self = this;\n+\n+    this.model.isInitialized = false;\n+\n+    // g2t_log('App:initialize');\n+\n+    this.gmailView.detect();\n+\n+    service = analytics.getService('gmail-2-trello');\n+\n+    // Get a Tracker using your Google Analytics app Tracking ID.\n+    tracker = service.getTracker('G-0QPEDL7YDL'); // Was: UA-8469046-1 -> UA-42442437-4\n+\n+    // Record an \"appView\" each time the user launches your app or goes to a new\n+    // screen within the app.\n+    tracker.sendAppView('PopupView');\n+  }\n+\n+  /**\n+   * Correctly escape RegExp\n+   */\n+  escapeRegExp(str) {\n+    return str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n+  }\n+\n+  /**\n+   * Utility routine to replace variables\n+   */\n+  replacer(text, dict) {\n+    let self = this;\n+\n+    if (!text || text.length < 1) {\n+      // g2t_log('Require text!');\n+      return '';\n+    } else if (!dict || dict.length < 2) {\n+      g2t_log('replacer: Require dictionary!');\n+      return text;\n+    }\n+\n+    let re, new_text;\n+    const replacify = function () {\n+      g2t_each(dict, function (value, key) {\n+        re = new RegExp(`%${self.escapeRegExp(key)}%`, 'gi');\n+        new_text = text.replace(re, value);\n+        text = new_text;\n+      });\n+    };\n+\n+    let runaway_max = 3;\n+    while (text.indexOf('%') !== -1 && runaway_max-- > 0) {\n+      replacify();\n+    }\n+\n+    return text;\n+  }\n+\n+  /**\n+   * Make displayable URI\n+   */\n+  uriForDisplay(uri) {\n+    const uri_display_trigger_length_k = 20;\n+    const uri_length_max_k = 40;\n+    let uri_display = uri || '';\n+    if (uri_display.length > uri_display_trigger_length_k) {\n+      let re = RegExp('^\\\\w+://([\\\\w./_-]+).*?([\\\\w._-]*)$');\n+      let matched = uri_display.match(re);\n+      if (matched && matched.length > 1) {\n+        const filename_k =\n+          matched[2].length < uri_length_max_k\n+            ? matched[2]\n+            : matched[2].slice(-uri_length_max_k);\n+        let prelude = matched[1].substr(0, uri_length_max_k);\n+        if (matched[1].length > uri_length_max_k) {\n+          prelude += '...';\n+        } else if (filename_k.length > 0) {\n+          prelude += ':';\n+        }\n+\n+        uri_display = prelude + filename_k;\n+      }\n+    }\n+    return uri_display;\n+  }\n+\n+  /**\n+   * Make anchored backlink\n+   */\n+  anchorMarkdownify(text, href, comment) {\n+    let text1 = (text || '').trim();\n+    let text1lc = text1.toLowerCase();\n+    let href1 = (href || '').trim();\n+    let href1lc = href1.toLowerCase();\n+    let comment1 = (comment || '').trim();",
    "path": "chrome_manifest_v3/class_app.js",
    "commit_id": "3bbc7b0b5b5abfda366260c45d6f2cecebf28af3",
    "original_commit_id": "ae0a391b6759338b0ec3c3292da07e458841ab71",
    "user": {
      "login": "coderabbitai[bot]",
      "id": 136622811,
      "node_id": "BOT_kgDOCCSy2w",
      "avatar_url": "https://avatars.githubusercontent.com/in/347564?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/coderabbitai%5Bbot%5D",
      "html_url": "https://github.com/apps/coderabbitai",
      "followers_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "_🧹 Nitpick (assertive)_\n\n**Use const. Not reassigned.**\n\n\n```diff\n-    let text1 = (text || '').trim();\n-    let text1lc = text1.toLowerCase();\n-    let href1 = (href || '').trim();\n-    let href1lc = href1.toLowerCase();\n-    let comment1 = (comment || '').trim();\n+    const text1 = (text || '').trim();\n+    const text1lc = text1.toLowerCase();\n+    const href1 = (href || '').trim();\n+    const href1lc = href1.toLowerCase();\n+    const comment1 = (comment || '').trim();\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>📝 Committable suggestion</summary>\n\n> ‼️ **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n    const text1 = (text || '').trim();\n    const text1lc = text1.toLowerCase();\n    const href1 = (href || '').trim();\n    const href1lc = href1.toLowerCase();\n    const comment1 = (comment || '').trim();\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>🧰 Tools</summary>\n\n<details>\n<summary>🪛 Biome (1.9.4)</summary>\n\n[error] 304-304: This let declares a variable that is only assigned once.\n\n'text1' is never reassigned.\n\nSafe fix: Use const instead.\n\n\n(lint/style/useConst)\n\n---\n\n[error] 305-305: This let declares a variable that is only assigned once.\n\n'text1lc' is never reassigned.\n\nSafe fix: Use const instead.\n\n\n(lint/style/useConst)\n\n---\n\n[error] 306-306: This let declares a variable that is only assigned once.\n\n'href1' is never reassigned.\n\nSafe fix: Use const instead.\n\n\n(lint/style/useConst)\n\n---\n\n[error] 307-307: This let declares a variable that is only assigned once.\n\n'href1lc' is never reassigned.\n\nSafe fix: Use const instead.\n\n\n(lint/style/useConst)\n\n---\n\n[error] 308-308: This let declares a variable that is only assigned once.\n\n'comment1' is never reassigned.\n\nSafe fix: Use const instead.\n\n\n(lint/style/useConst)\n\n</details>\n\n</details>\n\n<details>\n<summary>🤖 Prompt for AI Agents</summary>\n\n```\nIn chrome_manifest_v3/class_app.js around lines 304 to 308, the variables text1,\ntext1lc, href1, href1lc, and comment1 are declared with let but never\nreassigned. Change their declarations from let to const to reflect that they are\nconstants and improve code clarity.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:lion -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "created_at": "2025-07-13T21:43:19Z",
    "updated_at": "2025-07-13T21:43:21Z",
    "html_url": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203532555",
    "pull_request_url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532555"
      },
      "html": {
        "href": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203532555"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532555/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 304,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 308,
    "side": "RIGHT",
    "original_position": 308,
    "position": null,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532556",
    "pull_request_review_id": 3014319788,
    "id": 2203532556,
    "node_id": "PRRC_kwDOD1hYKM6DVz0M",
    "diff_hunk": "@@ -0,0 +1,848 @@\n+/** Gmail2Trello Application - ES6 Class Version\n+ */\n+\n+var Gmail2Trello = Gmail2Trello || {}; // Namespace initialization - must be var to guarantee correct scope\n+\n+class App {\n+  constructor() {\n+    this.CHROME_SETTINGS_ID = 'g2t_user_settings';\n+    this.UNIQUE_URI_VAR = 'g2t_filename';\n+\n+    this.model = new Gmail2Trello.Model(this);\n+    this.gmailView = new Gmail2Trello.GmailView(this);\n+    this.popupView = new Gmail2Trello.PopupView(this);\n+\n+    this.bindEvents();\n+  }\n+\n+  bindEvents() {\n+    const self = this;\n+\n+    /*** Data's events binding ***/\n+    this.model.event.addListener('onBeforeAuthorize', function () {\n+      self.popupView.bindData(''); // Intentionally blank\n+      self.popupView.showMessage(self, 'Authorizing...');\n+    });\n+\n+    this.model.event.addListener('onAuthorizeFail', function () {\n+      // self.model.isInitialized = false;\n+      self.popupView.showMessage(\n+        self,\n+        'Trello authorization failed <button id=\"showsignout\">Sign out and try again</button>'\n+      );\n+    });\n+\n+    this.model.event.addListener('onAuthorized', function () {\n+      // g2t_log('onAuthorized');\n+      // g2t_log(\"Status: \" + Trello.authorized().toString());\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+    });\n+\n+    this.model.event.addListener('onBeforeLoadTrello', function () {\n+      self.popupView.showMessage(self, 'Loading Trello data...');\n+    });\n+\n+    this.model.event.addListener('onTrelloDataReady', function () {\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+\n+      self.popupView.bindData(self.model);\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloListSuccess', function () {\n+      self.popupView.updateLists();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloCardsSuccess', function () {\n+      self.popupView.updateCards();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloLabelsSuccess', function () {\n+      self.popupView.updateLabels();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloMembersSuccess', function () {\n+      self.popupView.updateMembers();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener(\n+      'onCardSubmitComplete',\n+      function (target, params) {\n+        self.popupView.displaySubmitCompleteForm();\n+        // If card lists or labels have been updated, reload:\n+        const data_k = params?.data || {};\n+        const emailId = data_k?.emailId || 0;\n+        const boardId_k = data_k?.data?.board?.id || 0;\n+        const listId_k = data_k?.data?.list?.id || 0;\n+        const cardId_k = data_k?.data?.card?.id || 0;\n+        const idBoard_k = data_k?.idBoard || 0;\n+        const idList_k = data_k?.idList || 0;\n+        const idCard_k = data_k?.idCard || 0;\n+        const boardId = boardId_k || idBoard_k || 0;\n+        const listId = listId_k || idList_k || 0;\n+        const cardId = cardId_k || idCard_k || 0;\n+        // NOTE (acoven@2020-05-23): Users expect when creating a brand new card,\n+        // we'll remember that new card ID and then keep defaulting to it for\n+        // subsequent updates to that email. That means we'll have to get the return\n+        // value/url from Trello and dissect that, potentially doing this update\n+        // in that routine:\n+        self.model.emailBoardListCardMapUpdate({\n+          emailId,\n+          boardId,\n+          listId,\n+          cardId,\n+        });\n+\n+        if (boardId) {\n+          self.model.loadTrelloLabels(boardId);\n+          self.model.loadTrelloMembers(boardId);\n+        }\n+        if (listId) {\n+          self.model.loadTrelloCards(listId);\n+        }\n+      }\n+    );\n+\n+    this.model.event.addListener('onAPIFailure', function (target, params) {\n+      self.popupView.displayAPIFailedForm(params);\n+    });\n+\n+    /*** PopupView's events binding ***/\n+\n+    this.popupView.event.addListener('onPopupVisible', function () {\n+      if (!self.model.isInitialized) {\n+        self.popupView.showMessage(self, 'Initializing...');\n+        self.popupView.$popupContent.hide();\n+        self.model.init();\n+      } else {\n+        self.popupView.reset();\n+      }\n+\n+      const trelloUser_k = self?.model?.trello?.user || {};\n+      const fullName = trelloUser_k?.fullName || '';\n+\n+      self.gmailView.parsingData = false;\n+      self.model.gmail = self.gmailView.parseData({ fullName });\n+      self.popupView.bindGmailData(self.model.gmail);\n+      self.popupView.event.fire('periodicChecks');\n+    });\n+\n+    this.popupView.event.addListener('periodicChecks', function () {\n+      setTimeout(function () {\n+        self.popupView.periodicChecks();\n+      }, 3000);\n+    });\n+\n+    this.popupView.event.addListener('onBoardChanged', function (target, params) {\n+      let boardId = params.boardId;\n+      if (boardId !== '_' && boardId !== '' && boardId !== null) {\n+        self.model.loadTrelloLists(boardId);\n+        self.model.loadTrelloLabels(boardId);\n+        self.model.loadTrelloMembers(boardId);\n+      }\n+    });\n+\n+    this.popupView.event.addListener('onListChanged', function (target, params) {\n+      let listId = params.listId;\n+      self.model.loadTrelloCards(listId);\n+    });\n+\n+    this.popupView.event.addListener('onSubmit', function () {\n+      self.model.submit();\n+    });\n+\n+    this.popupView.event.addListener('checkTrelloAuthorized', function () {\n+      self.popupView.showMessage(self, 'Authorizing...');\n+      self.model.checkTrelloAuthorized();\n+    });\n+\n+    this.popupView.event.addListener('onRequestDeauthorizeTrello', function () {\n+      g2t_log('onRequestDeauthorizeTrello');\n+      self.model.deauthorizeTrello();\n+      self.popupView.clearBoard();\n+    });\n+\n+    const eventDetectButton = function () {\n+      if (self.gmailView.preDetect()) {\n+        self.popupView.$toolBar = self.gmailView.$toolBar;\n+        self.popupView.confirmPopup();\n+      }\n+    };\n+\n+    this.popupView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    // GMailView's events:\n+\n+    this.gmailView.event.addListener('onDetected', function () {\n+      self.popupView.$toolBar = self.gmailView.$toolBar;\n+      self.popupView.init();\n+    });\n+\n+    this.gmailView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    chrome.runtime.onMessage.addListener(function (\n+      request,\n+      sender,\n+      sendResponse\n+    ) {\n+      if (request?.message === 'g2t_keyboard_shortcut') {\n+        self.popupView.showPopup();\n+      }\n+    });\n+  }\n+\n+  updateData() {\n+    const self = this;\n+\n+    const fullName = self?.model?.trello?.user?.fullName || '';\n+\n+    self.popupView.bindData(self.model);\n+\n+    self.gmailView.parsingData = false;\n+    self.model.gmail = self.gmailView.parseData({ fullName });\n+    self.popupView.bindGmailData(self.model.gmail);\n+  }\n+\n+  initialize() {\n+    const self = this;\n+\n+    this.model.isInitialized = false;\n+\n+    // g2t_log('App:initialize');\n+\n+    this.gmailView.detect();\n+\n+    service = analytics.getService('gmail-2-trello');\n+\n+    // Get a Tracker using your Google Analytics app Tracking ID.\n+    tracker = service.getTracker('G-0QPEDL7YDL'); // Was: UA-8469046-1 -> UA-42442437-4\n+\n+    // Record an \"appView\" each time the user launches your app or goes to a new\n+    // screen within the app.\n+    tracker.sendAppView('PopupView');\n+  }\n+\n+  /**\n+   * Correctly escape RegExp\n+   */\n+  escapeRegExp(str) {\n+    return str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n+  }\n+\n+  /**\n+   * Utility routine to replace variables\n+   */\n+  replacer(text, dict) {\n+    let self = this;\n+\n+    if (!text || text.length < 1) {\n+      // g2t_log('Require text!');\n+      return '';\n+    } else if (!dict || dict.length < 2) {\n+      g2t_log('replacer: Require dictionary!');\n+      return text;\n+    }\n+\n+    let re, new_text;\n+    const replacify = function () {\n+      g2t_each(dict, function (value, key) {\n+        re = new RegExp(`%${self.escapeRegExp(key)}%`, 'gi');\n+        new_text = text.replace(re, value);\n+        text = new_text;\n+      });\n+    };\n+\n+    let runaway_max = 3;\n+    while (text.indexOf('%') !== -1 && runaway_max-- > 0) {\n+      replacify();\n+    }\n+\n+    return text;\n+  }\n+\n+  /**\n+   * Make displayable URI\n+   */\n+  uriForDisplay(uri) {\n+    const uri_display_trigger_length_k = 20;\n+    const uri_length_max_k = 40;\n+    let uri_display = uri || '';\n+    if (uri_display.length > uri_display_trigger_length_k) {\n+      let re = RegExp('^\\\\w+://([\\\\w./_-]+).*?([\\\\w._-]*)$');\n+      let matched = uri_display.match(re);\n+      if (matched && matched.length > 1) {\n+        const filename_k =\n+          matched[2].length < uri_length_max_k\n+            ? matched[2]\n+            : matched[2].slice(-uri_length_max_k);\n+        let prelude = matched[1].substr(0, uri_length_max_k);\n+        if (matched[1].length > uri_length_max_k) {\n+          prelude += '...';\n+        } else if (filename_k.length > 0) {\n+          prelude += ':';\n+        }\n+\n+        uri_display = prelude + filename_k;\n+      }\n+    }\n+    return uri_display;\n+  }\n+\n+  /**\n+   * Make anchored backlink\n+   */\n+  anchorMarkdownify(text, href, comment) {\n+    let text1 = (text || '').trim();\n+    let text1lc = text1.toLowerCase();\n+    let href1 = (href || '').trim();\n+    let href1lc = href1.toLowerCase();\n+    let comment1 = (comment || '').trim();\n+\n+    let retn = '';\n+\n+    if (text1.length < 1 && href1.length < 1) {\n+      // Intetionally blank\n+    } else if (text1lc === href1lc) {\n+      retn = ` <${href1}> `; // This renders correctly in Trello as a sole URL\n+      // NOTE (Ace, 17-Feb-2017): Turns out Trello doesn't support markdown [] only, so we'll construct a nice displayable text vs url:\n+      // text1 = this.uriForDisplay(text1);\n+    } else if (`mailto:${text1lc}` === href1lc) {\n+      retn = ` <${text1}> `; // This renders correctly in Trello as a mailto: url\n+    } else {\n+      const comment1QuotedSpaced = comment1.length > 0 ? ` \"${comment1}\"` : '';\n+      retn = ` [${text1}](<${href1}>${comment1QuotedSpaced}) `;\n+    }\n+\n+    return retn;\n+  }\n+\n+  /**\n+   * Split an email into name and domain\n+   */\n+  splitEmailDomain(email = '') {\n+    const split = email.split('@');\n+    const name = split[0] || '';\n+    const domain = split[1] || '';\n+    return {\n+      name,\n+      domain,\n+    };\n+  }\n+\n+  /**\n+   * Add trailing char if not empty:\n+   */\n+  addChar(front = '', back = '', addChar = ' ') {\n+    if (front.length > 0) {\n+      if (back.length > 0) {\n+        return `${front}${addChar}${back}`;\n+      } else {\n+        return `${front}${addChar}`;\n+      }\n+    } else if (back.length > 0) {\n+      return `${addChar}${back}`;\n+    } else {\n+      return '';\n+    }\n+  }\n+\n+  /**\n+   * Add trailing space if not empty:\n+   */\n+  addSpace(front = '', back = '') {\n+    return this.addChar(front, back, ' ');\n+  }\n+\n+  /**\n+   * Add trailing CRLF if not empty:\n+   */\n+  addCRLF(front = '', back = '') {\n+    return this.addChar(front, back, '\\n');\n+  }\n+\n+  /**\n+   * Markdownify a text block\n+   */\n+  markdownify($emailBody, features, preprocess) {\n+    if (!$emailBody || $emailBody.length < 1) {\n+      g2t_log('markdownify: Require emailBody!');\n+      return;\n+    }\n+    const self = this;\n+\n+    const min_text_length_k = 4;\n+    const max_replace_attempts_k = 10;\n+    const regexp_k = {\n+      begin: '(^|\\\\s+|<|\\\\[|\\\\(|\\\\b|(?=\\\\W+))',\n+      end: '($|\\\\s+|>|\\\\]|\\\\)|\\\\b|(?=\\\\W+))',\n+    };\n+    const unique_placeholder_k = 'g2t_placeholder:'; // Unique placeholder tag\n+\n+    let count = 0;\n+    let replacer_dict = {};\n+\n+    const featureEnabled = (elementTag = '') =>\n+      features === false ? false : features?.[elementTag] !== false;\n+\n+    let $html = $emailBody || ''; // Was: $emailBody.innerHTML || \"\";\n+    // let body = $emailBody.text() || \"\";\n+    let body = $emailBody.html() || '';\n+\n+    // Different encodings handle CRLF differently, so we'll process the main body as html and convert to text:\n+    // Convert paragraph marker to two returns:\n+    let replaced = body.replace(/\\s*[\\n\\r]*<p[^>]*>\\s*[\\n\\r]*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // Convert br marker to one return:\n+    replaced = body.replace(/\\s*[\\n\\r]*<br[^>]*>\\s*[\\n\\r]*/g, '\\n');\n+    body = replaced;\n+\n+    // Remove all other html markers:\n+    replaced = body.replace(/<[^>]*>/g, '');\n+    body = replaced;\n+\n+    // Decode HTML entities:\n+    replaced = self.decodeEntities(body);\n+    body = replaced;\n+\n+    // Replace hr:\n+    replaced = body.replace(/\\s*-{3,}\\s*/g, '---\\n');\n+    body = replaced;\n+\n+    // Convert crlf x 2 (or more) to paragraph markers:\n+    replaced = body.replace(/(\\s*[\\n\\r]\\s*){2,}/g, '<p />\\n');\n+    body = replaced;\n+\n+    let toProcess = {};\n+\n+    /**\n+     * 5 explicit steps in 3 passes:\n+     * (1) Collect tagged items\n+     * (2) Remove duplicates\n+     * (3) Sort force-lowercase by length\n+     * (4) Replace with placeholder\n+     * (5) Replace placeholders with final text\n+     */\n+    const sortAndPlaceholderize = function (tooProcess) {\n+      if (tooProcess) {\n+        g2t_each(\n+          Object.keys(tooProcess).sort(function (a, b) {\n+            // Go by order of largest to smallest\n+            return b.length - a.length;\n+          }),\n+          function (value) {\n+            const replace = tooProcess[value];\n+            const swap = `${unique_placeholder_k}${(count++).toString()}`;\n+            const re = new RegExp(\n+              regexp_k.begin + self.escapeRegExp(value) + regexp_k.end,\n+              'gi'\n+            );\n+            const replaced = body.replace(re, `%${swap}%`); // Replace occurance with placeholder\n+            if (body !== replaced) {\n+              body = replaced;\n+              replacer_dict[swap] = replace;\n+            }\n+          }\n+        );\n+      }\n+    };\n+    const processMarkdown = function (elementTag, replaceText) {\n+      if (elementTag && replaceText && featureEnabled(elementTag)) {\n+        toProcess = preprocess[elementTag] || {};\n+        $(elementTag, $html).each(function (index, value) {\n+          let text = ($(this).text() || '').trim();\n+          if (text && text.length > min_text_length_k) {\n+            let replace = self.replacer(replaceText, { text: text });\n+            toProcess[text.toLowerCase()] = replace; // Intentionally overwrites duplicates\n+          }\n+        });\n+        sortAndPlaceholderize(toProcess);\n+      }\n+    };\n+    /**\n+     * Repeat replace for max attempts or when done, whatever comes first\n+     */\n+    const repeatReplace = function (body, inRegexp, replaceWith) {\n+      let replace1 = '';\n+      for (let iter = max_replace_attempts_k; iter > 0; iter--) {\n+        replace1 = body.replace(inRegexp, replaceWith);\n+        if (body === replace1) {\n+          iter = 0; // All done\n+        } else {\n+          body = replace1;\n+        }\n+      }\n+      return body;\n+    };\n+\n+    // bullet lists:\n+    // ul li -> \" * \"\n+    processMarkdown('ul li', '<p />* %text%<p />');\n+\n+    // numeric lists:\n+    // ol li -> \" 1. \"\n+    processMarkdown('ol li', '<p />1. %text%<p />');\n+\n+    // headers:\n+    // H1 -> #\n+    // H2 -> ##\n+    // H3 -> ###\n+    // H4 -> ####\n+    // H5 -> #####\n+    // H6 -> ######\n+    if (featureEnabled('h')) {\n+      toProcess = preprocess['h'] || {};\n+      $(':header', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let nodeName = $(this).prop('nodeName') || '0';\n+        if (nodeName && text && text.length > min_text_length_k) {\n+          let x = nodeName.substr(-1);\n+          toProcess[text.toLowerCase()] = `\\n${'#'.repeat(x)} ${text}\\n`; // Intentionally overwrites duplicates\n+        }\n+      });\n+      sortAndPlaceholderize(toProcess);\n+    }\n+\n+    replaced = this.replacer(body, replacer_dict); // Replace initial batch of <div> like placeholders\n+    body = replaced;\n+    replacer_dict = {}; // Reset\n+    count = 0; // Reset\n+\n+    // bold: b -> **text**\n+    processMarkdown('b', ' **%text%** ');\n+\n+    // italics: i -> _text_\n+    processMarkdown('i', ' _%text%_ ');\n+\n+    // links:\n+    // a -> [text](html)\n+    if (featureEnabled('a')) {\n+      toProcess = preprocess['a'] || {};\n+      $('a', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let href = ($(this).prop('href') || '').trim(); // Was attr\n+        /*\n+              var uri_display = self.uriForDisplay(href);\n+              var comment = ' \"' + text + ' via ' + uri_display + '\"';\n+              var re = new RegExp(self.escapeRegExp(text), \"i\");\n+              if (uri.match(re)) {\n+                  comment = ' \"Open ' + uri_display + '\"';\n+              }\n+              */\n+        if (href && text && text.length >= min_text_length_k) {\n+          toProcess[text.toLowerCase()] = self.anchorMarkdownify(text, href); // Comment seemed like too much extra text // Intentionally overwrites duplicates\n+        }\n+      });\n+      sortAndPlaceholderize(toProcess);\n+    }\n+\n+    /* DISABLED (Ace, 16-Jan-2017): Images kinda make a mess, until requested lets not markdownify them:\n+      // images:\n+      // img -> ![alt_text](html)\n+      if (featureEnabled('img')) {\n+          $('img', $html).each(function(index, value) {\n+              var text = ($(this).prop(\"alt\") || \"\").trim(); // Was attr\n+              var href = ($(this).prop(\"src\") || \"\").trim(); // Was attr\n+              // var uri_display = self.uriForDisplay(href);\n+              if (href && text && text.length >= min_text_length_k) {\n+                  toProcess[text.toLowerCase()] = self.anchorMarkdownify(text, href); // Comment seemed like too much extra text // Intentionally overwrites duplicates\n+              }\n+          });\n+          sortAndPlaceholderize(toProcess);\n+      }\n+      */\n+\n+    replaced = this.replacer(body, replacer_dict); // Replace second batch of <span> like placeholders\n+    body = replaced;\n+\n+    // Replace bullets following a CRLF:\n+    replaced = body.replace(/\\s*[\\n\\r]+\\s*[·-]+\\s*/g, '<p />* '); // = [\\u00B7\\u2022]\n+    body = replaced;\n+\n+    // Replace remaining bullets with asterisks:\n+    replaced = body.replace(/[·]/g, '*');\n+    body = replaced;\n+\n+    // ORDER MATTERS FOR THIS NEXT SET:\n+    // (1) Replace <space>CRLF<space> with just CR:\n+    replaced = body.replace(/\\s*[\\n\\r]+\\s*/g, '\\n');\n+    body = replaced;\n+\n+    // (2) Replace 2 or more spaces with just one:\n+    replaced = repeatReplace(body, new RegExp('\\\\s{2,}', 'g'), ' ');\n+    body = replaced;\n+\n+    // (3) Replace paragraph markers with CR+CR:\n+    replaced = body.replace(/\\s*<p \\/>\\s*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // (4) Replace 3 or more CRs with just two:\n+    replaced = repeatReplace(body, new RegExp('\\\\n{3,}', 'g'), '\\n\\n');\n+    body = replaced;\n+\n+    // (5) Trim excess at beginning and end:\n+    replaced = body.trim();\n+    body = replaced;\n+\n+    return body;\n+  }\n+\n+  /**\n+   * Determine luminance of a color so we can augment with darker/lighter background\n+   */\n+  luminance(color) {\n+    let bkColorLight = 'lightGray'; // or white\n+    let bkColorDark = 'darkGray'; // 'gray' is even darker\n+    let bkColorReturn = bkColorLight;\n+\n+    let re = new RegExp('rgb\\\\D+(\\\\d+)\\\\D+(\\\\d+)\\\\D+(\\\\d+)');\n+    let matched = color.match(re, 'i');\n+    if (matched && matched.length > 2) {\n+      // 0 is total string:\n+      let r = matched[1];\n+      let g = matched[2];\n+      let b = matched[3];\n+      // var 1 = matched[4]; // if alpha is provided\n+\n+      let luma = 0.2126 * r + 0.7152 * g + 0.0722 * b; // per ITU-R BT.709\n+\n+      if (luma < 40) {\n+        bkColorReturn = bkColorDark;\n+      } else {\n+        bkColorReturn = bkColorLight;\n+      }\n+    } else {\n+      bkColorReturn = bkColorLight; // RegExp failed, assume dark color\n+    }\n+\n+    return 'inherit'; // Use: bkColorReturn if you want to adjust background based on text perceived brightness\n+  }\n+\n+  /**\n+   * HTML bookend a string\n+   */\n+  bookend(bookend, text, style) {\n+    return (\n+      '<' +\n+      bookend +\n+      (style ? ' style=\"' + style + '\"' : '') +\n+      '>' +\n+      (text || '') +\n+      '</' +\n+      bookend +\n+      '>'\n+    );\n+  }\n+\n+  /**\n+   * Get selected text\n+   * http://stackoverflow.com/questions/5379120/get-the-highlighted-selected-text\n+   */\n+  getSelectedText() {\n+    let text = '';\n+    let activeEl = document.activeElement;\n+    let activeElTagName = activeEl ? activeEl.tagName.toLowerCase() : null;\n+    if (\n+      (activeElTagName == 'textarea' || activeElTagName == 'input') &&\n+      /^(?:text|search|password|tel|url)$/i.test(activeEl.type) &&\n+      typeof activeEl.selectionStart == 'number'",
    "path": "chrome_manifest_v3/class_app.js",
    "commit_id": "3bbc7b0b5b5abfda366260c45d6f2cecebf28af3",
    "original_commit_id": "ae0a391b6759338b0ec3c3292da07e458841ab71",
    "user": {
      "login": "coderabbitai[bot]",
      "id": 136622811,
      "node_id": "BOT_kgDOCCSy2w",
      "avatar_url": "https://avatars.githubusercontent.com/in/347564?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/coderabbitai%5Bbot%5D",
      "html_url": "https://github.com/apps/coderabbitai",
      "followers_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "_🧹 Nitpick (assertive)_\n\n**Use strict equality.**\n\n\n```diff\n     if (\n-      (activeElTagName == 'textarea' || activeElTagName == 'input') &&\n+      (activeElTagName === 'textarea' || activeElTagName === 'input') &&\n       /^(?:text|search|password|tel|url)$/i.test(activeEl.type) &&\n-      typeof activeEl.selectionStart == 'number'\n+      typeof activeEl.selectionStart === 'number'\n     ) {\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>📝 Committable suggestion</summary>\n\n> ‼️ **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n    if (\n      (activeElTagName === 'textarea' || activeElTagName === 'input') &&\n      /^(?:text|search|password|tel|url)$/i.test(activeEl.type) &&\n      typeof activeEl.selectionStart === 'number'\n    ) {\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>🤖 Prompt for AI Agents</summary>\n\n```\nIn chrome_manifest_v3/class_app.js around lines 654 to 657, replace the loose\nequality checks (==) with strict equality checks (===) for comparing\nactiveElTagName to 'textarea' and 'input'. This ensures type-safe comparisons\nand avoids unexpected type coercion.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:lion -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "created_at": "2025-07-13T21:43:19Z",
    "updated_at": "2025-07-13T21:43:21Z",
    "html_url": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203532556",
    "pull_request_url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532556"
      },
      "html": {
        "href": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203532556"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532556/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 654,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 657,
    "side": "RIGHT",
    "original_position": 657,
    "position": null,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532557",
    "pull_request_review_id": 3014319788,
    "id": 2203532557,
    "node_id": "PRRC_kwDOD1hYKM6DVz0N",
    "diff_hunk": "@@ -0,0 +1,848 @@\n+/** Gmail2Trello Application - ES6 Class Version\n+ */\n+\n+var Gmail2Trello = Gmail2Trello || {}; // Namespace initialization - must be var to guarantee correct scope\n+\n+class App {\n+  constructor() {\n+    this.CHROME_SETTINGS_ID = 'g2t_user_settings';\n+    this.UNIQUE_URI_VAR = 'g2t_filename';\n+\n+    this.model = new Gmail2Trello.Model(this);\n+    this.gmailView = new Gmail2Trello.GmailView(this);\n+    this.popupView = new Gmail2Trello.PopupView(this);\n+\n+    this.bindEvents();\n+  }\n+\n+  bindEvents() {\n+    const self = this;\n+\n+    /*** Data's events binding ***/\n+    this.model.event.addListener('onBeforeAuthorize', function () {\n+      self.popupView.bindData(''); // Intentionally blank\n+      self.popupView.showMessage(self, 'Authorizing...');\n+    });\n+\n+    this.model.event.addListener('onAuthorizeFail', function () {\n+      // self.model.isInitialized = false;\n+      self.popupView.showMessage(\n+        self,\n+        'Trello authorization failed <button id=\"showsignout\">Sign out and try again</button>'\n+      );\n+    });\n+\n+    this.model.event.addListener('onAuthorized', function () {\n+      // g2t_log('onAuthorized');\n+      // g2t_log(\"Status: \" + Trello.authorized().toString());\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+    });\n+\n+    this.model.event.addListener('onBeforeLoadTrello', function () {\n+      self.popupView.showMessage(self, 'Loading Trello data...');\n+    });\n+\n+    this.model.event.addListener('onTrelloDataReady', function () {\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+\n+      self.popupView.bindData(self.model);\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloListSuccess', function () {\n+      self.popupView.updateLists();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloCardsSuccess', function () {\n+      self.popupView.updateCards();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloLabelsSuccess', function () {\n+      self.popupView.updateLabels();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloMembersSuccess', function () {\n+      self.popupView.updateMembers();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener(\n+      'onCardSubmitComplete',\n+      function (target, params) {\n+        self.popupView.displaySubmitCompleteForm();\n+        // If card lists or labels have been updated, reload:\n+        const data_k = params?.data || {};\n+        const emailId = data_k?.emailId || 0;\n+        const boardId_k = data_k?.data?.board?.id || 0;\n+        const listId_k = data_k?.data?.list?.id || 0;\n+        const cardId_k = data_k?.data?.card?.id || 0;\n+        const idBoard_k = data_k?.idBoard || 0;\n+        const idList_k = data_k?.idList || 0;\n+        const idCard_k = data_k?.idCard || 0;\n+        const boardId = boardId_k || idBoard_k || 0;\n+        const listId = listId_k || idList_k || 0;\n+        const cardId = cardId_k || idCard_k || 0;\n+        // NOTE (acoven@2020-05-23): Users expect when creating a brand new card,\n+        // we'll remember that new card ID and then keep defaulting to it for\n+        // subsequent updates to that email. That means we'll have to get the return\n+        // value/url from Trello and dissect that, potentially doing this update\n+        // in that routine:\n+        self.model.emailBoardListCardMapUpdate({\n+          emailId,\n+          boardId,\n+          listId,\n+          cardId,\n+        });\n+\n+        if (boardId) {\n+          self.model.loadTrelloLabels(boardId);\n+          self.model.loadTrelloMembers(boardId);\n+        }\n+        if (listId) {\n+          self.model.loadTrelloCards(listId);\n+        }\n+      }\n+    );\n+\n+    this.model.event.addListener('onAPIFailure', function (target, params) {\n+      self.popupView.displayAPIFailedForm(params);\n+    });\n+\n+    /*** PopupView's events binding ***/\n+\n+    this.popupView.event.addListener('onPopupVisible', function () {\n+      if (!self.model.isInitialized) {\n+        self.popupView.showMessage(self, 'Initializing...');\n+        self.popupView.$popupContent.hide();\n+        self.model.init();\n+      } else {\n+        self.popupView.reset();\n+      }\n+\n+      const trelloUser_k = self?.model?.trello?.user || {};\n+      const fullName = trelloUser_k?.fullName || '';\n+\n+      self.gmailView.parsingData = false;\n+      self.model.gmail = self.gmailView.parseData({ fullName });\n+      self.popupView.bindGmailData(self.model.gmail);\n+      self.popupView.event.fire('periodicChecks');\n+    });\n+\n+    this.popupView.event.addListener('periodicChecks', function () {\n+      setTimeout(function () {\n+        self.popupView.periodicChecks();\n+      }, 3000);\n+    });\n+\n+    this.popupView.event.addListener('onBoardChanged', function (target, params) {\n+      let boardId = params.boardId;\n+      if (boardId !== '_' && boardId !== '' && boardId !== null) {\n+        self.model.loadTrelloLists(boardId);\n+        self.model.loadTrelloLabels(boardId);\n+        self.model.loadTrelloMembers(boardId);\n+      }\n+    });\n+\n+    this.popupView.event.addListener('onListChanged', function (target, params) {\n+      let listId = params.listId;\n+      self.model.loadTrelloCards(listId);\n+    });\n+\n+    this.popupView.event.addListener('onSubmit', function () {\n+      self.model.submit();\n+    });\n+\n+    this.popupView.event.addListener('checkTrelloAuthorized', function () {\n+      self.popupView.showMessage(self, 'Authorizing...');\n+      self.model.checkTrelloAuthorized();\n+    });\n+\n+    this.popupView.event.addListener('onRequestDeauthorizeTrello', function () {\n+      g2t_log('onRequestDeauthorizeTrello');\n+      self.model.deauthorizeTrello();\n+      self.popupView.clearBoard();\n+    });\n+\n+    const eventDetectButton = function () {\n+      if (self.gmailView.preDetect()) {\n+        self.popupView.$toolBar = self.gmailView.$toolBar;\n+        self.popupView.confirmPopup();\n+      }\n+    };\n+\n+    this.popupView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    // GMailView's events:\n+\n+    this.gmailView.event.addListener('onDetected', function () {\n+      self.popupView.$toolBar = self.gmailView.$toolBar;\n+      self.popupView.init();\n+    });\n+\n+    this.gmailView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    chrome.runtime.onMessage.addListener(function (\n+      request,\n+      sender,\n+      sendResponse\n+    ) {\n+      if (request?.message === 'g2t_keyboard_shortcut') {\n+        self.popupView.showPopup();\n+      }\n+    });\n+  }\n+\n+  updateData() {\n+    const self = this;\n+\n+    const fullName = self?.model?.trello?.user?.fullName || '';\n+\n+    self.popupView.bindData(self.model);\n+\n+    self.gmailView.parsingData = false;\n+    self.model.gmail = self.gmailView.parseData({ fullName });\n+    self.popupView.bindGmailData(self.model.gmail);\n+  }\n+\n+  initialize() {\n+    const self = this;\n+\n+    this.model.isInitialized = false;\n+\n+    // g2t_log('App:initialize');\n+\n+    this.gmailView.detect();\n+\n+    service = analytics.getService('gmail-2-trello');\n+\n+    // Get a Tracker using your Google Analytics app Tracking ID.\n+    tracker = service.getTracker('G-0QPEDL7YDL'); // Was: UA-8469046-1 -> UA-42442437-4\n+\n+    // Record an \"appView\" each time the user launches your app or goes to a new\n+    // screen within the app.\n+    tracker.sendAppView('PopupView');\n+  }\n+\n+  /**\n+   * Correctly escape RegExp\n+   */\n+  escapeRegExp(str) {\n+    return str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n+  }\n+\n+  /**\n+   * Utility routine to replace variables\n+   */\n+  replacer(text, dict) {\n+    let self = this;\n+\n+    if (!text || text.length < 1) {\n+      // g2t_log('Require text!');\n+      return '';\n+    } else if (!dict || dict.length < 2) {\n+      g2t_log('replacer: Require dictionary!');\n+      return text;\n+    }\n+\n+    let re, new_text;\n+    const replacify = function () {\n+      g2t_each(dict, function (value, key) {\n+        re = new RegExp(`%${self.escapeRegExp(key)}%`, 'gi');\n+        new_text = text.replace(re, value);\n+        text = new_text;\n+      });\n+    };\n+\n+    let runaway_max = 3;\n+    while (text.indexOf('%') !== -1 && runaway_max-- > 0) {\n+      replacify();\n+    }\n+\n+    return text;\n+  }\n+\n+  /**\n+   * Make displayable URI\n+   */\n+  uriForDisplay(uri) {\n+    const uri_display_trigger_length_k = 20;\n+    const uri_length_max_k = 40;\n+    let uri_display = uri || '';\n+    if (uri_display.length > uri_display_trigger_length_k) {\n+      let re = RegExp('^\\\\w+://([\\\\w./_-]+).*?([\\\\w._-]*)$');\n+      let matched = uri_display.match(re);\n+      if (matched && matched.length > 1) {\n+        const filename_k =\n+          matched[2].length < uri_length_max_k\n+            ? matched[2]\n+            : matched[2].slice(-uri_length_max_k);\n+        let prelude = matched[1].substr(0, uri_length_max_k);\n+        if (matched[1].length > uri_length_max_k) {\n+          prelude += '...';\n+        } else if (filename_k.length > 0) {\n+          prelude += ':';\n+        }\n+\n+        uri_display = prelude + filename_k;\n+      }\n+    }\n+    return uri_display;\n+  }\n+\n+  /**\n+   * Make anchored backlink\n+   */\n+  anchorMarkdownify(text, href, comment) {\n+    let text1 = (text || '').trim();\n+    let text1lc = text1.toLowerCase();\n+    let href1 = (href || '').trim();\n+    let href1lc = href1.toLowerCase();\n+    let comment1 = (comment || '').trim();\n+\n+    let retn = '';\n+\n+    if (text1.length < 1 && href1.length < 1) {\n+      // Intetionally blank\n+    } else if (text1lc === href1lc) {\n+      retn = ` <${href1}> `; // This renders correctly in Trello as a sole URL\n+      // NOTE (Ace, 17-Feb-2017): Turns out Trello doesn't support markdown [] only, so we'll construct a nice displayable text vs url:\n+      // text1 = this.uriForDisplay(text1);\n+    } else if (`mailto:${text1lc}` === href1lc) {\n+      retn = ` <${text1}> `; // This renders correctly in Trello as a mailto: url\n+    } else {\n+      const comment1QuotedSpaced = comment1.length > 0 ? ` \"${comment1}\"` : '';\n+      retn = ` [${text1}](<${href1}>${comment1QuotedSpaced}) `;\n+    }\n+\n+    return retn;\n+  }\n+\n+  /**\n+   * Split an email into name and domain\n+   */\n+  splitEmailDomain(email = '') {\n+    const split = email.split('@');\n+    const name = split[0] || '';\n+    const domain = split[1] || '';\n+    return {\n+      name,\n+      domain,\n+    };\n+  }\n+\n+  /**\n+   * Add trailing char if not empty:\n+   */\n+  addChar(front = '', back = '', addChar = ' ') {\n+    if (front.length > 0) {\n+      if (back.length > 0) {\n+        return `${front}${addChar}${back}`;\n+      } else {\n+        return `${front}${addChar}`;\n+      }\n+    } else if (back.length > 0) {\n+      return `${addChar}${back}`;\n+    } else {\n+      return '';\n+    }\n+  }\n+\n+  /**\n+   * Add trailing space if not empty:\n+   */\n+  addSpace(front = '', back = '') {\n+    return this.addChar(front, back, ' ');\n+  }\n+\n+  /**\n+   * Add trailing CRLF if not empty:\n+   */\n+  addCRLF(front = '', back = '') {\n+    return this.addChar(front, back, '\\n');\n+  }\n+\n+  /**\n+   * Markdownify a text block\n+   */\n+  markdownify($emailBody, features, preprocess) {\n+    if (!$emailBody || $emailBody.length < 1) {\n+      g2t_log('markdownify: Require emailBody!');\n+      return;\n+    }\n+    const self = this;\n+\n+    const min_text_length_k = 4;\n+    const max_replace_attempts_k = 10;\n+    const regexp_k = {\n+      begin: '(^|\\\\s+|<|\\\\[|\\\\(|\\\\b|(?=\\\\W+))',\n+      end: '($|\\\\s+|>|\\\\]|\\\\)|\\\\b|(?=\\\\W+))',\n+    };\n+    const unique_placeholder_k = 'g2t_placeholder:'; // Unique placeholder tag\n+\n+    let count = 0;\n+    let replacer_dict = {};\n+\n+    const featureEnabled = (elementTag = '') =>\n+      features === false ? false : features?.[elementTag] !== false;\n+\n+    let $html = $emailBody || ''; // Was: $emailBody.innerHTML || \"\";\n+    // let body = $emailBody.text() || \"\";\n+    let body = $emailBody.html() || '';\n+\n+    // Different encodings handle CRLF differently, so we'll process the main body as html and convert to text:\n+    // Convert paragraph marker to two returns:\n+    let replaced = body.replace(/\\s*[\\n\\r]*<p[^>]*>\\s*[\\n\\r]*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // Convert br marker to one return:\n+    replaced = body.replace(/\\s*[\\n\\r]*<br[^>]*>\\s*[\\n\\r]*/g, '\\n');\n+    body = replaced;\n+\n+    // Remove all other html markers:\n+    replaced = body.replace(/<[^>]*>/g, '');\n+    body = replaced;\n+\n+    // Decode HTML entities:\n+    replaced = self.decodeEntities(body);\n+    body = replaced;\n+\n+    // Replace hr:\n+    replaced = body.replace(/\\s*-{3,}\\s*/g, '---\\n');\n+    body = replaced;\n+\n+    // Convert crlf x 2 (or more) to paragraph markers:\n+    replaced = body.replace(/(\\s*[\\n\\r]\\s*){2,}/g, '<p />\\n');\n+    body = replaced;\n+\n+    let toProcess = {};\n+\n+    /**\n+     * 5 explicit steps in 3 passes:\n+     * (1) Collect tagged items\n+     * (2) Remove duplicates\n+     * (3) Sort force-lowercase by length\n+     * (4) Replace with placeholder\n+     * (5) Replace placeholders with final text\n+     */\n+    const sortAndPlaceholderize = function (tooProcess) {\n+      if (tooProcess) {\n+        g2t_each(\n+          Object.keys(tooProcess).sort(function (a, b) {\n+            // Go by order of largest to smallest\n+            return b.length - a.length;\n+          }),\n+          function (value) {\n+            const replace = tooProcess[value];\n+            const swap = `${unique_placeholder_k}${(count++).toString()}`;\n+            const re = new RegExp(\n+              regexp_k.begin + self.escapeRegExp(value) + regexp_k.end,\n+              'gi'\n+            );\n+            const replaced = body.replace(re, `%${swap}%`); // Replace occurance with placeholder\n+            if (body !== replaced) {\n+              body = replaced;\n+              replacer_dict[swap] = replace;\n+            }\n+          }\n+        );\n+      }\n+    };\n+    const processMarkdown = function (elementTag, replaceText) {\n+      if (elementTag && replaceText && featureEnabled(elementTag)) {\n+        toProcess = preprocess[elementTag] || {};\n+        $(elementTag, $html).each(function (index, value) {\n+          let text = ($(this).text() || '').trim();\n+          if (text && text.length > min_text_length_k) {\n+            let replace = self.replacer(replaceText, { text: text });\n+            toProcess[text.toLowerCase()] = replace; // Intentionally overwrites duplicates\n+          }\n+        });\n+        sortAndPlaceholderize(toProcess);\n+      }\n+    };\n+    /**\n+     * Repeat replace for max attempts or when done, whatever comes first\n+     */\n+    const repeatReplace = function (body, inRegexp, replaceWith) {\n+      let replace1 = '';\n+      for (let iter = max_replace_attempts_k; iter > 0; iter--) {\n+        replace1 = body.replace(inRegexp, replaceWith);\n+        if (body === replace1) {\n+          iter = 0; // All done\n+        } else {\n+          body = replace1;\n+        }\n+      }\n+      return body;\n+    };",
    "path": "chrome_manifest_v3/class_app.js",
    "commit_id": "3bbc7b0b5b5abfda366260c45d6f2cecebf28af3",
    "original_commit_id": "ae0a391b6759338b0ec3c3292da07e458841ab71",
    "user": {
      "login": "coderabbitai[bot]",
      "id": 136622811,
      "node_id": "BOT_kgDOCCSy2w",
      "avatar_url": "https://avatars.githubusercontent.com/in/347564?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/coderabbitai%5Bbot%5D",
      "html_url": "https://github.com/apps/coderabbitai",
      "followers_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "_🛠️ Refactor suggestion_\n\n**Don't mutate parameters.**\n\nHard to track.\n\n```diff\n-  const repeatReplace = function (body, inRegexp, replaceWith) {\n+  const repeatReplace = function (bodyText, inRegexp, replaceWith) {\n+    let body = bodyText;\n     let replace1 = '';\n     for (let iter = max_replace_attempts_k; iter > 0; iter--) {\n       replace1 = body.replace(inRegexp, replaceWith);\n       if (body === replace1) {\n         iter = 0; // All done\n       } else {\n         body = replace1;\n       }\n     }\n     return body;\n   };\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>📝 Committable suggestion</summary>\n\n> ‼️ **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n    const repeatReplace = function (bodyText, inRegexp, replaceWith) {\n      let body = bodyText;\n      let replace1 = '';\n      for (let iter = max_replace_attempts_k; iter > 0; iter--) {\n        replace1 = body.replace(inRegexp, replaceWith);\n        if (body === replace1) {\n          iter = 0; // All done\n        } else {\n          body = replace1;\n        }\n      }\n      return body;\n    };\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>🧰 Tools</summary>\n\n<details>\n<summary>🪛 Biome (1.9.4)</summary>\n\n[error] 481-481: Reassigning a function parameter is confusing.\n\nThe parameter is declared here:\n\nUse a local variable instead.\n\n(lint/style/noParameterAssign)\n\n</details>\n\n</details>\n\n<details>\n<summary>🤖 Prompt for AI Agents</summary>\n\n```\nIn chrome_manifest_v3/class_app.js around lines 474 to 485, the function\nrepeatReplace mutates the input parameter 'body' inside the loop, which is hard\nto track and can cause side effects. To fix this, create a new local variable to\nhold the intermediate replacement results instead of modifying 'body' directly.\nUse this new variable for replacements and return it at the end, leaving the\noriginal 'body' parameter unchanged.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:lion -->\n\n<!-- This is an auto-generated reply by CodeRabbit -->\n\n✅ Addressed in commit bd3e941\n\n<!-- This is an auto-generated reply by CodeRabbit -->",
    "created_at": "2025-07-13T21:43:19Z",
    "updated_at": "2025-07-14T04:53:55Z",
    "html_url": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203532557",
    "pull_request_url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532557"
      },
      "html": {
        "href": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203532557"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532557/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 474,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 485,
    "side": "RIGHT",
    "original_position": 485,
    "position": null,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532565",
    "pull_request_review_id": 3014319788,
    "id": 2203532565,
    "node_id": "PRRC_kwDOD1hYKM6DVz0V",
    "diff_hunk": "@@ -0,0 +1,848 @@\n+/** Gmail2Trello Application - ES6 Class Version\n+ */\n+\n+var Gmail2Trello = Gmail2Trello || {}; // Namespace initialization - must be var to guarantee correct scope\n+\n+class App {\n+  constructor() {\n+    this.CHROME_SETTINGS_ID = 'g2t_user_settings';\n+    this.UNIQUE_URI_VAR = 'g2t_filename';\n+\n+    this.model = new Gmail2Trello.Model(this);\n+    this.gmailView = new Gmail2Trello.GmailView(this);\n+    this.popupView = new Gmail2Trello.PopupView(this);\n+\n+    this.bindEvents();\n+  }\n+\n+  bindEvents() {\n+    const self = this;\n+\n+    /*** Data's events binding ***/\n+    this.model.event.addListener('onBeforeAuthorize', function () {\n+      self.popupView.bindData(''); // Intentionally blank\n+      self.popupView.showMessage(self, 'Authorizing...');\n+    });\n+\n+    this.model.event.addListener('onAuthorizeFail', function () {\n+      // self.model.isInitialized = false;\n+      self.popupView.showMessage(\n+        self,\n+        'Trello authorization failed <button id=\"showsignout\">Sign out and try again</button>'\n+      );\n+    });\n+\n+    this.model.event.addListener('onAuthorized', function () {\n+      // g2t_log('onAuthorized');\n+      // g2t_log(\"Status: \" + Trello.authorized().toString());\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+    });\n+\n+    this.model.event.addListener('onBeforeLoadTrello', function () {\n+      self.popupView.showMessage(self, 'Loading Trello data...');\n+    });\n+\n+    this.model.event.addListener('onTrelloDataReady', function () {\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+\n+      self.popupView.bindData(self.model);\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloListSuccess', function () {\n+      self.popupView.updateLists();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloCardsSuccess', function () {\n+      self.popupView.updateCards();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloLabelsSuccess', function () {\n+      self.popupView.updateLabels();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloMembersSuccess', function () {\n+      self.popupView.updateMembers();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener(\n+      'onCardSubmitComplete',\n+      function (target, params) {\n+        self.popupView.displaySubmitCompleteForm();\n+        // If card lists or labels have been updated, reload:\n+        const data_k = params?.data || {};\n+        const emailId = data_k?.emailId || 0;\n+        const boardId_k = data_k?.data?.board?.id || 0;\n+        const listId_k = data_k?.data?.list?.id || 0;\n+        const cardId_k = data_k?.data?.card?.id || 0;\n+        const idBoard_k = data_k?.idBoard || 0;\n+        const idList_k = data_k?.idList || 0;\n+        const idCard_k = data_k?.idCard || 0;\n+        const boardId = boardId_k || idBoard_k || 0;\n+        const listId = listId_k || idList_k || 0;\n+        const cardId = cardId_k || idCard_k || 0;\n+        // NOTE (acoven@2020-05-23): Users expect when creating a brand new card,\n+        // we'll remember that new card ID and then keep defaulting to it for\n+        // subsequent updates to that email. That means we'll have to get the return\n+        // value/url from Trello and dissect that, potentially doing this update\n+        // in that routine:\n+        self.model.emailBoardListCardMapUpdate({\n+          emailId,\n+          boardId,\n+          listId,\n+          cardId,\n+        });\n+\n+        if (boardId) {\n+          self.model.loadTrelloLabels(boardId);\n+          self.model.loadTrelloMembers(boardId);\n+        }\n+        if (listId) {\n+          self.model.loadTrelloCards(listId);\n+        }\n+      }\n+    );\n+\n+    this.model.event.addListener('onAPIFailure', function (target, params) {\n+      self.popupView.displayAPIFailedForm(params);\n+    });\n+\n+    /*** PopupView's events binding ***/\n+\n+    this.popupView.event.addListener('onPopupVisible', function () {\n+      if (!self.model.isInitialized) {\n+        self.popupView.showMessage(self, 'Initializing...');\n+        self.popupView.$popupContent.hide();\n+        self.model.init();\n+      } else {\n+        self.popupView.reset();\n+      }\n+\n+      const trelloUser_k = self?.model?.trello?.user || {};\n+      const fullName = trelloUser_k?.fullName || '';\n+\n+      self.gmailView.parsingData = false;\n+      self.model.gmail = self.gmailView.parseData({ fullName });\n+      self.popupView.bindGmailData(self.model.gmail);\n+      self.popupView.event.fire('periodicChecks');\n+    });\n+\n+    this.popupView.event.addListener('periodicChecks', function () {\n+      setTimeout(function () {\n+        self.popupView.periodicChecks();\n+      }, 3000);\n+    });\n+\n+    this.popupView.event.addListener('onBoardChanged', function (target, params) {\n+      let boardId = params.boardId;\n+      if (boardId !== '_' && boardId !== '' && boardId !== null) {\n+        self.model.loadTrelloLists(boardId);\n+        self.model.loadTrelloLabels(boardId);\n+        self.model.loadTrelloMembers(boardId);\n+      }\n+    });\n+\n+    this.popupView.event.addListener('onListChanged', function (target, params) {\n+      let listId = params.listId;\n+      self.model.loadTrelloCards(listId);\n+    });\n+\n+    this.popupView.event.addListener('onSubmit', function () {\n+      self.model.submit();\n+    });\n+\n+    this.popupView.event.addListener('checkTrelloAuthorized', function () {\n+      self.popupView.showMessage(self, 'Authorizing...');\n+      self.model.checkTrelloAuthorized();\n+    });\n+\n+    this.popupView.event.addListener('onRequestDeauthorizeTrello', function () {\n+      g2t_log('onRequestDeauthorizeTrello');\n+      self.model.deauthorizeTrello();\n+      self.popupView.clearBoard();\n+    });\n+\n+    const eventDetectButton = function () {\n+      if (self.gmailView.preDetect()) {\n+        self.popupView.$toolBar = self.gmailView.$toolBar;\n+        self.popupView.confirmPopup();\n+      }\n+    };\n+\n+    this.popupView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    // GMailView's events:\n+\n+    this.gmailView.event.addListener('onDetected', function () {\n+      self.popupView.$toolBar = self.gmailView.$toolBar;\n+      self.popupView.init();\n+    });\n+\n+    this.gmailView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    chrome.runtime.onMessage.addListener(function (\n+      request,\n+      sender,\n+      sendResponse\n+    ) {\n+      if (request?.message === 'g2t_keyboard_shortcut') {\n+        self.popupView.showPopup();\n+      }\n+    });\n+  }\n+\n+  updateData() {\n+    const self = this;\n+\n+    const fullName = self?.model?.trello?.user?.fullName || '';\n+\n+    self.popupView.bindData(self.model);\n+\n+    self.gmailView.parsingData = false;\n+    self.model.gmail = self.gmailView.parseData({ fullName });\n+    self.popupView.bindGmailData(self.model.gmail);\n+  }\n+\n+  initialize() {\n+    const self = this;\n+\n+    this.model.isInitialized = false;\n+\n+    // g2t_log('App:initialize');\n+\n+    this.gmailView.detect();\n+\n+    service = analytics.getService('gmail-2-trello');\n+\n+    // Get a Tracker using your Google Analytics app Tracking ID.\n+    tracker = service.getTracker('G-0QPEDL7YDL'); // Was: UA-8469046-1 -> UA-42442437-4\n+\n+    // Record an \"appView\" each time the user launches your app or goes to a new\n+    // screen within the app.\n+    tracker.sendAppView('PopupView');\n+  }\n+\n+  /**\n+   * Correctly escape RegExp\n+   */\n+  escapeRegExp(str) {\n+    return str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n+  }\n+\n+  /**\n+   * Utility routine to replace variables\n+   */\n+  replacer(text, dict) {\n+    let self = this;\n+\n+    if (!text || text.length < 1) {\n+      // g2t_log('Require text!');\n+      return '';\n+    } else if (!dict || dict.length < 2) {\n+      g2t_log('replacer: Require dictionary!');\n+      return text;\n+    }\n+\n+    let re, new_text;\n+    const replacify = function () {\n+      g2t_each(dict, function (value, key) {\n+        re = new RegExp(`%${self.escapeRegExp(key)}%`, 'gi');\n+        new_text = text.replace(re, value);\n+        text = new_text;\n+      });\n+    };",
    "path": "chrome_manifest_v3/class_app.js",
    "commit_id": "3bbc7b0b5b5abfda366260c45d6f2cecebf28af3",
    "original_commit_id": "ae0a391b6759338b0ec3c3292da07e458841ab71",
    "user": {
      "login": "coderabbitai[bot]",
      "id": 136622811,
      "node_id": "BOT_kgDOCCSy2w",
      "avatar_url": "https://avatars.githubusercontent.com/in/347564?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/coderabbitai%5Bbot%5D",
      "html_url": "https://github.com/apps/coderabbitai",
      "followers_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "_🛠️ Refactor suggestion_\n\n**Don't reassign parameters. Confusing.**\n\n\n```diff\n   const replacify = function () {\n+    let result = text;\n     g2t_each(dict, function (value, key) {\n       re = new RegExp(`%${self.escapeRegExp(key)}%`, 'gi');\n-      new_text = text.replace(re, value);\n-      text = new_text;\n+      new_text = result.replace(re, value);\n+      result = new_text;\n     });\n+    return result;\n   };\n```\n\nThen update the while loop:\n```diff\n-  while (text.indexOf('%') !== -1 && runaway_max-- > 0) {\n-    replacify();\n+  while (text.indexOf('%') !== -1 && runaway_max-- > 0) {\n+    text = replacify();\n   }\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>📝 Committable suggestion</summary>\n\n> ‼️ **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n    let re, new_text;\n    const replacify = function () {\n      let result = text;\n      g2t_each(dict, function (value, key) {\n        re = new RegExp(`%${self.escapeRegExp(key)}%`, 'gi');\n        new_text = result.replace(re, value);\n        result = new_text;\n      });\n      return result;\n    };\n\n    while (text.indexOf('%') !== -1 && runaway_max-- > 0) {\n      text = replacify();\n    }\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>🧰 Tools</summary>\n\n<details>\n<summary>🪛 Biome (1.9.4)</summary>\n\n[error] 255-255: Declare variables separately\n\nUnsafe fix: Break out into multiple declarations\n\n\n(lint/style/useSingleVarDeclarator)\n\n---\n\n[error] 260-260: Reassigning a function parameter is confusing.\n\nThe parameter is declared here:\n\nUse a local variable instead.\n\n(lint/style/noParameterAssign)\n\n</details>\n\n</details>\n\n<details>\n<summary>🤖 Prompt for AI Agents</summary>\n\n```\nIn chrome_manifest_v3/class_app.js around lines 255 to 262, the function\nreplacify reassigns the parameter 'text', which is confusing and should be\navoided. To fix this, create a new variable inside replacify to hold the updated\ntext instead of reassigning the parameter. Then update the while loop to use\nthis new variable for further processing without modifying the original\nparameter directly.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:lion -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "created_at": "2025-07-13T21:43:20Z",
    "updated_at": "2025-07-13T21:43:22Z",
    "html_url": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203532565",
    "pull_request_url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532565"
      },
      "html": {
        "href": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203532565"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532565/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 255,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 262,
    "side": "RIGHT",
    "original_position": 262,
    "position": null,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532566",
    "pull_request_review_id": 3014319788,
    "id": 2203532566,
    "node_id": "PRRC_kwDOD1hYKM6DVz0W",
    "diff_hunk": "@@ -0,0 +1,848 @@\n+/** Gmail2Trello Application - ES6 Class Version\n+ */\n+\n+var Gmail2Trello = Gmail2Trello || {}; // Namespace initialization - must be var to guarantee correct scope\n+\n+class App {\n+  constructor() {\n+    this.CHROME_SETTINGS_ID = 'g2t_user_settings';\n+    this.UNIQUE_URI_VAR = 'g2t_filename';\n+\n+    this.model = new Gmail2Trello.Model(this);\n+    this.gmailView = new Gmail2Trello.GmailView(this);\n+    this.popupView = new Gmail2Trello.PopupView(this);\n+\n+    this.bindEvents();\n+  }\n+\n+  bindEvents() {\n+    const self = this;",
    "path": "chrome_manifest_v3/class_app.js",
    "commit_id": "3bbc7b0b5b5abfda366260c45d6f2cecebf28af3",
    "original_commit_id": "ae0a391b6759338b0ec3c3292da07e458841ab71",
    "user": {
      "login": "coderabbitai[bot]",
      "id": 136622811,
      "node_id": "BOT_kgDOCCSy2w",
      "avatar_url": "https://avatars.githubusercontent.com/in/347564?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/coderabbitai%5Bbot%5D",
      "html_url": "https://github.com/apps/coderabbitai",
      "followers_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "_🛠️ Refactor suggestion_\n\n**Convert callbacks to arrow functions. Remove self.**\n\nPer project standards. I am the Batman.\n\n```diff\n-  bindEvents() {\n-    const self = this;\n+  bindEvents() {\n```\n\nThen convert all event listeners:\n```diff\n-    this.model.event.addListener('onBeforeAuthorize', function () {\n-      self.popupView.bindData(''); // Intentionally blank\n-      self.popupView.showMessage(self, 'Authorizing...');\n+    this.model.event.addListener('onBeforeAuthorize', () => {\n+      this.popupView.bindData(''); // Intentionally blank\n+      this.popupView.showMessage(this, 'Authorizing...');\n     });\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>📝 Committable suggestion</summary>\n\n> ‼️ **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n  bindEvents() {\n    // Removed: const self = this;\n\n    this.model.event.addListener('onBeforeAuthorize', () => {\n      this.popupView.bindData(''); // Intentionally blank\n      this.popupView.showMessage(this, 'Authorizing...');\n    });\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>🤖 Prompt for AI Agents</summary>\n\n```\nIn chrome_manifest_v3/class_app.js at line 19, replace the use of 'const self =\nthis;' by converting the callback functions to arrow functions to preserve the\nlexical 'this' context. Remove the 'self' variable entirely and update all event\nlisteners accordingly to use arrow functions instead of traditional function\nexpressions.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:lion -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->\n\n✅ Addressed in commit f609e13",
    "created_at": "2025-07-13T21:43:20Z",
    "updated_at": "2025-07-14T01:52:15Z",
    "html_url": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203532566",
    "pull_request_url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532566"
      },
      "html": {
        "href": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203532566"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532566/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 19,
    "side": "RIGHT",
    "original_position": 19,
    "position": null,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532567",
    "pull_request_review_id": 3014319788,
    "id": 2203532567,
    "node_id": "PRRC_kwDOD1hYKM6DVz0X",
    "diff_hunk": "@@ -0,0 +1,848 @@\n+/** Gmail2Trello Application - ES6 Class Version\n+ */\n+\n+var Gmail2Trello = Gmail2Trello || {}; // Namespace initialization - must be var to guarantee correct scope\n+\n+class App {\n+  constructor() {\n+    this.CHROME_SETTINGS_ID = 'g2t_user_settings';\n+    this.UNIQUE_URI_VAR = 'g2t_filename';\n+\n+    this.model = new Gmail2Trello.Model(this);\n+    this.gmailView = new Gmail2Trello.GmailView(this);\n+    this.popupView = new Gmail2Trello.PopupView(this);\n+\n+    this.bindEvents();\n+  }\n+\n+  bindEvents() {\n+    const self = this;\n+\n+    /*** Data's events binding ***/\n+    this.model.event.addListener('onBeforeAuthorize', function () {\n+      self.popupView.bindData(''); // Intentionally blank\n+      self.popupView.showMessage(self, 'Authorizing...');\n+    });\n+\n+    this.model.event.addListener('onAuthorizeFail', function () {\n+      // self.model.isInitialized = false;\n+      self.popupView.showMessage(\n+        self,\n+        'Trello authorization failed <button id=\"showsignout\">Sign out and try again</button>'\n+      );\n+    });\n+\n+    this.model.event.addListener('onAuthorized', function () {\n+      // g2t_log('onAuthorized');\n+      // g2t_log(\"Status: \" + Trello.authorized().toString());\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+    });\n+\n+    this.model.event.addListener('onBeforeLoadTrello', function () {\n+      self.popupView.showMessage(self, 'Loading Trello data...');\n+    });\n+\n+    this.model.event.addListener('onTrelloDataReady', function () {\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+\n+      self.popupView.bindData(self.model);\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloListSuccess', function () {\n+      self.popupView.updateLists();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloCardsSuccess', function () {\n+      self.popupView.updateCards();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloLabelsSuccess', function () {\n+      self.popupView.updateLabels();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloMembersSuccess', function () {\n+      self.popupView.updateMembers();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener(\n+      'onCardSubmitComplete',\n+      function (target, params) {\n+        self.popupView.displaySubmitCompleteForm();\n+        // If card lists or labels have been updated, reload:\n+        const data_k = params?.data || {};\n+        const emailId = data_k?.emailId || 0;\n+        const boardId_k = data_k?.data?.board?.id || 0;\n+        const listId_k = data_k?.data?.list?.id || 0;\n+        const cardId_k = data_k?.data?.card?.id || 0;\n+        const idBoard_k = data_k?.idBoard || 0;\n+        const idList_k = data_k?.idList || 0;\n+        const idCard_k = data_k?.idCard || 0;\n+        const boardId = boardId_k || idBoard_k || 0;\n+        const listId = listId_k || idList_k || 0;\n+        const cardId = cardId_k || idCard_k || 0;\n+        // NOTE (acoven@2020-05-23): Users expect when creating a brand new card,\n+        // we'll remember that new card ID and then keep defaulting to it for\n+        // subsequent updates to that email. That means we'll have to get the return\n+        // value/url from Trello and dissect that, potentially doing this update\n+        // in that routine:\n+        self.model.emailBoardListCardMapUpdate({\n+          emailId,\n+          boardId,\n+          listId,\n+          cardId,\n+        });\n+\n+        if (boardId) {\n+          self.model.loadTrelloLabels(boardId);\n+          self.model.loadTrelloMembers(boardId);\n+        }\n+        if (listId) {\n+          self.model.loadTrelloCards(listId);\n+        }\n+      }\n+    );\n+\n+    this.model.event.addListener('onAPIFailure', function (target, params) {\n+      self.popupView.displayAPIFailedForm(params);\n+    });\n+\n+    /*** PopupView's events binding ***/\n+\n+    this.popupView.event.addListener('onPopupVisible', function () {\n+      if (!self.model.isInitialized) {\n+        self.popupView.showMessage(self, 'Initializing...');\n+        self.popupView.$popupContent.hide();\n+        self.model.init();\n+      } else {\n+        self.popupView.reset();\n+      }\n+\n+      const trelloUser_k = self?.model?.trello?.user || {};\n+      const fullName = trelloUser_k?.fullName || '';\n+\n+      self.gmailView.parsingData = false;\n+      self.model.gmail = self.gmailView.parseData({ fullName });\n+      self.popupView.bindGmailData(self.model.gmail);\n+      self.popupView.event.fire('periodicChecks');\n+    });\n+\n+    this.popupView.event.addListener('periodicChecks', function () {\n+      setTimeout(function () {\n+        self.popupView.periodicChecks();\n+      }, 3000);\n+    });\n+\n+    this.popupView.event.addListener('onBoardChanged', function (target, params) {\n+      let boardId = params.boardId;\n+      if (boardId !== '_' && boardId !== '' && boardId !== null) {\n+        self.model.loadTrelloLists(boardId);\n+        self.model.loadTrelloLabels(boardId);\n+        self.model.loadTrelloMembers(boardId);\n+      }\n+    });\n+\n+    this.popupView.event.addListener('onListChanged', function (target, params) {\n+      let listId = params.listId;\n+      self.model.loadTrelloCards(listId);\n+    });\n+\n+    this.popupView.event.addListener('onSubmit', function () {\n+      self.model.submit();\n+    });\n+\n+    this.popupView.event.addListener('checkTrelloAuthorized', function () {\n+      self.popupView.showMessage(self, 'Authorizing...');\n+      self.model.checkTrelloAuthorized();\n+    });\n+\n+    this.popupView.event.addListener('onRequestDeauthorizeTrello', function () {\n+      g2t_log('onRequestDeauthorizeTrello');\n+      self.model.deauthorizeTrello();\n+      self.popupView.clearBoard();\n+    });\n+\n+    const eventDetectButton = function () {\n+      if (self.gmailView.preDetect()) {\n+        self.popupView.$toolBar = self.gmailView.$toolBar;\n+        self.popupView.confirmPopup();\n+      }\n+    };\n+\n+    this.popupView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    // GMailView's events:\n+\n+    this.gmailView.event.addListener('onDetected', function () {\n+      self.popupView.$toolBar = self.gmailView.$toolBar;\n+      self.popupView.init();\n+    });\n+\n+    this.gmailView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    chrome.runtime.onMessage.addListener(function (\n+      request,\n+      sender,\n+      sendResponse\n+    ) {\n+      if (request?.message === 'g2t_keyboard_shortcut') {\n+        self.popupView.showPopup();\n+      }\n+    });\n+  }\n+\n+  updateData() {\n+    const self = this;\n+\n+    const fullName = self?.model?.trello?.user?.fullName || '';\n+\n+    self.popupView.bindData(self.model);\n+\n+    self.gmailView.parsingData = false;\n+    self.model.gmail = self.gmailView.parseData({ fullName });\n+    self.popupView.bindGmailData(self.model.gmail);\n+  }\n+\n+  initialize() {\n+    const self = this;",
    "path": "chrome_manifest_v3/class_app.js",
    "commit_id": "3bbc7b0b5b5abfda366260c45d6f2cecebf28af3",
    "original_commit_id": "ae0a391b6759338b0ec3c3292da07e458841ab71",
    "user": {
      "login": "coderabbitai[bot]",
      "id": 136622811,
      "node_id": "BOT_kgDOCCSy2w",
      "avatar_url": "https://avatars.githubusercontent.com/in/347564?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/coderabbitai%5Bbot%5D",
      "html_url": "https://github.com/apps/coderabbitai",
      "followers_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "_🛠️ Refactor suggestion_\n\n**Remove self. Not needed.**\n\n\n```diff\n-  initialize() {\n-    const self = this;\n-\n-    this.model.isInitialized = false;\n+  initialize() {\n+    this.model.isInitialized = false;\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>📝 Committable suggestion</summary>\n\n> ‼️ **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n  initialize() {\n    this.model.isInitialized = false;\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>🧰 Tools</summary>\n\n<details>\n<summary>🪛 Biome (1.9.4)</summary>\n\n[error] 216-216: This aliasing of this is unnecessary.\n\nArrow functions inherits `this` from their enclosing scope.\nSafe fix: Use this instead of an alias.\n\n\n(lint/complexity/noUselessThisAlias)\n\n</details>\n\n</details>\n\n<details>\n<summary>🤖 Prompt for AI Agents</summary>\n\n```\nIn chrome_manifest_v3/class_app.js at line 216, the declaration of the variable\n'self' is unnecessary and should be removed. Simply delete the line 'const self\n= this;' to clean up the code without affecting functionality.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:lion -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->\n\n✅ Addressed in commits 8198420 to 909c137",
    "created_at": "2025-07-13T21:43:20Z",
    "updated_at": "2025-07-14T04:13:05Z",
    "html_url": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203532567",
    "pull_request_url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532567"
      },
      "html": {
        "href": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203532567"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532567/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 216,
    "side": "RIGHT",
    "original_position": 216,
    "position": null,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532568",
    "pull_request_review_id": 3014319788,
    "id": 2203532568,
    "node_id": "PRRC_kwDOD1hYKM6DVz0Y",
    "diff_hunk": "@@ -0,0 +1,848 @@\n+/** Gmail2Trello Application - ES6 Class Version\n+ */\n+\n+var Gmail2Trello = Gmail2Trello || {}; // Namespace initialization - must be var to guarantee correct scope\n+\n+class App {\n+  constructor() {\n+    this.CHROME_SETTINGS_ID = 'g2t_user_settings';\n+    this.UNIQUE_URI_VAR = 'g2t_filename';\n+\n+    this.model = new Gmail2Trello.Model(this);\n+    this.gmailView = new Gmail2Trello.GmailView(this);\n+    this.popupView = new Gmail2Trello.PopupView(this);\n+\n+    this.bindEvents();\n+  }\n+\n+  bindEvents() {\n+    const self = this;\n+\n+    /*** Data's events binding ***/\n+    this.model.event.addListener('onBeforeAuthorize', function () {\n+      self.popupView.bindData(''); // Intentionally blank\n+      self.popupView.showMessage(self, 'Authorizing...');\n+    });\n+\n+    this.model.event.addListener('onAuthorizeFail', function () {\n+      // self.model.isInitialized = false;\n+      self.popupView.showMessage(\n+        self,\n+        'Trello authorization failed <button id=\"showsignout\">Sign out and try again</button>'\n+      );\n+    });\n+\n+    this.model.event.addListener('onAuthorized', function () {\n+      // g2t_log('onAuthorized');\n+      // g2t_log(\"Status: \" + Trello.authorized().toString());\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+    });\n+\n+    this.model.event.addListener('onBeforeLoadTrello', function () {\n+      self.popupView.showMessage(self, 'Loading Trello data...');\n+    });\n+\n+    this.model.event.addListener('onTrelloDataReady', function () {\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+\n+      self.popupView.bindData(self.model);\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloListSuccess', function () {\n+      self.popupView.updateLists();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloCardsSuccess', function () {\n+      self.popupView.updateCards();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloLabelsSuccess', function () {\n+      self.popupView.updateLabels();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloMembersSuccess', function () {\n+      self.popupView.updateMembers();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener(\n+      'onCardSubmitComplete',\n+      function (target, params) {\n+        self.popupView.displaySubmitCompleteForm();\n+        // If card lists or labels have been updated, reload:\n+        const data_k = params?.data || {};\n+        const emailId = data_k?.emailId || 0;\n+        const boardId_k = data_k?.data?.board?.id || 0;\n+        const listId_k = data_k?.data?.list?.id || 0;\n+        const cardId_k = data_k?.data?.card?.id || 0;\n+        const idBoard_k = data_k?.idBoard || 0;\n+        const idList_k = data_k?.idList || 0;\n+        const idCard_k = data_k?.idCard || 0;\n+        const boardId = boardId_k || idBoard_k || 0;\n+        const listId = listId_k || idList_k || 0;\n+        const cardId = cardId_k || idCard_k || 0;\n+        // NOTE (acoven@2020-05-23): Users expect when creating a brand new card,\n+        // we'll remember that new card ID and then keep defaulting to it for\n+        // subsequent updates to that email. That means we'll have to get the return\n+        // value/url from Trello and dissect that, potentially doing this update\n+        // in that routine:\n+        self.model.emailBoardListCardMapUpdate({\n+          emailId,\n+          boardId,\n+          listId,\n+          cardId,\n+        });\n+\n+        if (boardId) {\n+          self.model.loadTrelloLabels(boardId);\n+          self.model.loadTrelloMembers(boardId);\n+        }\n+        if (listId) {\n+          self.model.loadTrelloCards(listId);\n+        }\n+      }\n+    );\n+\n+    this.model.event.addListener('onAPIFailure', function (target, params) {\n+      self.popupView.displayAPIFailedForm(params);\n+    });\n+\n+    /*** PopupView's events binding ***/\n+\n+    this.popupView.event.addListener('onPopupVisible', function () {\n+      if (!self.model.isInitialized) {\n+        self.popupView.showMessage(self, 'Initializing...');\n+        self.popupView.$popupContent.hide();\n+        self.model.init();\n+      } else {\n+        self.popupView.reset();\n+      }\n+\n+      const trelloUser_k = self?.model?.trello?.user || {};\n+      const fullName = trelloUser_k?.fullName || '';\n+\n+      self.gmailView.parsingData = false;\n+      self.model.gmail = self.gmailView.parseData({ fullName });\n+      self.popupView.bindGmailData(self.model.gmail);\n+      self.popupView.event.fire('periodicChecks');\n+    });\n+\n+    this.popupView.event.addListener('periodicChecks', function () {\n+      setTimeout(function () {\n+        self.popupView.periodicChecks();\n+      }, 3000);\n+    });\n+\n+    this.popupView.event.addListener('onBoardChanged', function (target, params) {\n+      let boardId = params.boardId;\n+      if (boardId !== '_' && boardId !== '' && boardId !== null) {\n+        self.model.loadTrelloLists(boardId);\n+        self.model.loadTrelloLabels(boardId);\n+        self.model.loadTrelloMembers(boardId);\n+      }\n+    });\n+\n+    this.popupView.event.addListener('onListChanged', function (target, params) {\n+      let listId = params.listId;\n+      self.model.loadTrelloCards(listId);\n+    });\n+\n+    this.popupView.event.addListener('onSubmit', function () {\n+      self.model.submit();\n+    });\n+\n+    this.popupView.event.addListener('checkTrelloAuthorized', function () {\n+      self.popupView.showMessage(self, 'Authorizing...');\n+      self.model.checkTrelloAuthorized();\n+    });\n+\n+    this.popupView.event.addListener('onRequestDeauthorizeTrello', function () {\n+      g2t_log('onRequestDeauthorizeTrello');\n+      self.model.deauthorizeTrello();\n+      self.popupView.clearBoard();\n+    });\n+\n+    const eventDetectButton = function () {\n+      if (self.gmailView.preDetect()) {\n+        self.popupView.$toolBar = self.gmailView.$toolBar;\n+        self.popupView.confirmPopup();\n+      }\n+    };\n+\n+    this.popupView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    // GMailView's events:\n+\n+    this.gmailView.event.addListener('onDetected', function () {\n+      self.popupView.$toolBar = self.gmailView.$toolBar;\n+      self.popupView.init();\n+    });\n+\n+    this.gmailView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    chrome.runtime.onMessage.addListener(function (\n+      request,\n+      sender,\n+      sendResponse\n+    ) {\n+      if (request?.message === 'g2t_keyboard_shortcut') {\n+        self.popupView.showPopup();\n+      }\n+    });\n+  }\n+\n+  updateData() {\n+    const self = this;\n+\n+    const fullName = self?.model?.trello?.user?.fullName || '';\n+\n+    self.popupView.bindData(self.model);\n+\n+    self.gmailView.parsingData = false;\n+    self.model.gmail = self.gmailView.parseData({ fullName });\n+    self.popupView.bindGmailData(self.model.gmail);\n+  }\n+\n+  initialize() {\n+    const self = this;\n+\n+    this.model.isInitialized = false;\n+\n+    // g2t_log('App:initialize');\n+\n+    this.gmailView.detect();\n+\n+    service = analytics.getService('gmail-2-trello');\n+\n+    // Get a Tracker using your Google Analytics app Tracking ID.\n+    tracker = service.getTracker('G-0QPEDL7YDL'); // Was: UA-8469046-1 -> UA-42442437-4\n+\n+    // Record an \"appView\" each time the user launches your app or goes to a new\n+    // screen within the app.\n+    tracker.sendAppView('PopupView');\n+  }\n+\n+  /**\n+   * Correctly escape RegExp\n+   */\n+  escapeRegExp(str) {\n+    return str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n+  }\n+\n+  /**\n+   * Utility routine to replace variables\n+   */\n+  replacer(text, dict) {\n+    let self = this;\n+\n+    if (!text || text.length < 1) {\n+      // g2t_log('Require text!');\n+      return '';\n+    } else if (!dict || dict.length < 2) {\n+      g2t_log('replacer: Require dictionary!');\n+      return text;\n+    }\n+\n+    let re, new_text;\n+    const replacify = function () {\n+      g2t_each(dict, function (value, key) {\n+        re = new RegExp(`%${self.escapeRegExp(key)}%`, 'gi');\n+        new_text = text.replace(re, value);\n+        text = new_text;\n+      });\n+    };\n+\n+    let runaway_max = 3;\n+    while (text.indexOf('%') !== -1 && runaway_max-- > 0) {\n+      replacify();\n+    }\n+\n+    return text;\n+  }\n+\n+  /**\n+   * Make displayable URI\n+   */\n+  uriForDisplay(uri) {\n+    const uri_display_trigger_length_k = 20;\n+    const uri_length_max_k = 40;\n+    let uri_display = uri || '';\n+    if (uri_display.length > uri_display_trigger_length_k) {\n+      let re = RegExp('^\\\\w+://([\\\\w./_-]+).*?([\\\\w._-]*)$');\n+      let matched = uri_display.match(re);\n+      if (matched && matched.length > 1) {\n+        const filename_k =\n+          matched[2].length < uri_length_max_k\n+            ? matched[2]\n+            : matched[2].slice(-uri_length_max_k);\n+        let prelude = matched[1].substr(0, uri_length_max_k);\n+        if (matched[1].length > uri_length_max_k) {\n+          prelude += '...';\n+        } else if (filename_k.length > 0) {\n+          prelude += ':';\n+        }\n+\n+        uri_display = prelude + filename_k;\n+      }\n+    }\n+    return uri_display;\n+  }\n+\n+  /**\n+   * Make anchored backlink\n+   */\n+  anchorMarkdownify(text, href, comment) {\n+    let text1 = (text || '').trim();\n+    let text1lc = text1.toLowerCase();\n+    let href1 = (href || '').trim();\n+    let href1lc = href1.toLowerCase();\n+    let comment1 = (comment || '').trim();\n+\n+    let retn = '';\n+\n+    if (text1.length < 1 && href1.length < 1) {\n+      // Intetionally blank\n+    } else if (text1lc === href1lc) {\n+      retn = ` <${href1}> `; // This renders correctly in Trello as a sole URL\n+      // NOTE (Ace, 17-Feb-2017): Turns out Trello doesn't support markdown [] only, so we'll construct a nice displayable text vs url:\n+      // text1 = this.uriForDisplay(text1);\n+    } else if (`mailto:${text1lc}` === href1lc) {\n+      retn = ` <${text1}> `; // This renders correctly in Trello as a mailto: url\n+    } else {\n+      const comment1QuotedSpaced = comment1.length > 0 ? ` \"${comment1}\"` : '';\n+      retn = ` [${text1}](<${href1}>${comment1QuotedSpaced}) `;\n+    }\n+\n+    return retn;\n+  }\n+\n+  /**\n+   * Split an email into name and domain\n+   */\n+  splitEmailDomain(email = '') {\n+    const split = email.split('@');\n+    const name = split[0] || '';\n+    const domain = split[1] || '';\n+    return {\n+      name,\n+      domain,\n+    };\n+  }\n+\n+  /**\n+   * Add trailing char if not empty:\n+   */\n+  addChar(front = '', back = '', addChar = ' ') {\n+    if (front.length > 0) {\n+      if (back.length > 0) {\n+        return `${front}${addChar}${back}`;\n+      } else {\n+        return `${front}${addChar}`;\n+      }\n+    } else if (back.length > 0) {\n+      return `${addChar}${back}`;\n+    } else {\n+      return '';\n+    }\n+  }\n+\n+  /**\n+   * Add trailing space if not empty:\n+   */\n+  addSpace(front = '', back = '') {\n+    return this.addChar(front, back, ' ');\n+  }\n+\n+  /**\n+   * Add trailing CRLF if not empty:\n+   */\n+  addCRLF(front = '', back = '') {\n+    return this.addChar(front, back, '\\n');\n+  }\n+\n+  /**\n+   * Markdownify a text block\n+   */\n+  markdownify($emailBody, features, preprocess) {\n+    if (!$emailBody || $emailBody.length < 1) {\n+      g2t_log('markdownify: Require emailBody!');\n+      return;\n+    }\n+    const self = this;\n+\n+    const min_text_length_k = 4;\n+    const max_replace_attempts_k = 10;\n+    const regexp_k = {\n+      begin: '(^|\\\\s+|<|\\\\[|\\\\(|\\\\b|(?=\\\\W+))',\n+      end: '($|\\\\s+|>|\\\\]|\\\\)|\\\\b|(?=\\\\W+))',\n+    };\n+    const unique_placeholder_k = 'g2t_placeholder:'; // Unique placeholder tag\n+\n+    let count = 0;\n+    let replacer_dict = {};\n+\n+    const featureEnabled = (elementTag = '') =>\n+      features === false ? false : features?.[elementTag] !== false;\n+\n+    let $html = $emailBody || ''; // Was: $emailBody.innerHTML || \"\";\n+    // let body = $emailBody.text() || \"\";\n+    let body = $emailBody.html() || '';\n+\n+    // Different encodings handle CRLF differently, so we'll process the main body as html and convert to text:\n+    // Convert paragraph marker to two returns:\n+    let replaced = body.replace(/\\s*[\\n\\r]*<p[^>]*>\\s*[\\n\\r]*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // Convert br marker to one return:\n+    replaced = body.replace(/\\s*[\\n\\r]*<br[^>]*>\\s*[\\n\\r]*/g, '\\n');\n+    body = replaced;\n+\n+    // Remove all other html markers:\n+    replaced = body.replace(/<[^>]*>/g, '');\n+    body = replaced;\n+\n+    // Decode HTML entities:\n+    replaced = self.decodeEntities(body);\n+    body = replaced;\n+\n+    // Replace hr:\n+    replaced = body.replace(/\\s*-{3,}\\s*/g, '---\\n');\n+    body = replaced;\n+\n+    // Convert crlf x 2 (or more) to paragraph markers:\n+    replaced = body.replace(/(\\s*[\\n\\r]\\s*){2,}/g, '<p />\\n');\n+    body = replaced;\n+\n+    let toProcess = {};\n+\n+    /**\n+     * 5 explicit steps in 3 passes:\n+     * (1) Collect tagged items\n+     * (2) Remove duplicates\n+     * (3) Sort force-lowercase by length\n+     * (4) Replace with placeholder\n+     * (5) Replace placeholders with final text\n+     */\n+    const sortAndPlaceholderize = function (tooProcess) {\n+      if (tooProcess) {\n+        g2t_each(\n+          Object.keys(tooProcess).sort(function (a, b) {\n+            // Go by order of largest to smallest\n+            return b.length - a.length;\n+          }),\n+          function (value) {\n+            const replace = tooProcess[value];\n+            const swap = `${unique_placeholder_k}${(count++).toString()}`;\n+            const re = new RegExp(\n+              regexp_k.begin + self.escapeRegExp(value) + regexp_k.end,\n+              'gi'\n+            );\n+            const replaced = body.replace(re, `%${swap}%`); // Replace occurance with placeholder\n+            if (body !== replaced) {\n+              body = replaced;\n+              replacer_dict[swap] = replace;\n+            }\n+          }\n+        );\n+      }\n+    };\n+    const processMarkdown = function (elementTag, replaceText) {\n+      if (elementTag && replaceText && featureEnabled(elementTag)) {\n+        toProcess = preprocess[elementTag] || {};\n+        $(elementTag, $html).each(function (index, value) {\n+          let text = ($(this).text() || '').trim();\n+          if (text && text.length > min_text_length_k) {\n+            let replace = self.replacer(replaceText, { text: text });\n+            toProcess[text.toLowerCase()] = replace; // Intentionally overwrites duplicates\n+          }\n+        });\n+        sortAndPlaceholderize(toProcess);\n+      }\n+    };\n+    /**\n+     * Repeat replace for max attempts or when done, whatever comes first\n+     */\n+    const repeatReplace = function (body, inRegexp, replaceWith) {\n+      let replace1 = '';\n+      for (let iter = max_replace_attempts_k; iter > 0; iter--) {\n+        replace1 = body.replace(inRegexp, replaceWith);\n+        if (body === replace1) {\n+          iter = 0; // All done\n+        } else {\n+          body = replace1;\n+        }\n+      }\n+      return body;\n+    };\n+\n+    // bullet lists:\n+    // ul li -> \" * \"\n+    processMarkdown('ul li', '<p />* %text%<p />');\n+\n+    // numeric lists:\n+    // ol li -> \" 1. \"\n+    processMarkdown('ol li', '<p />1. %text%<p />');\n+\n+    // headers:\n+    // H1 -> #\n+    // H2 -> ##\n+    // H3 -> ###\n+    // H4 -> ####\n+    // H5 -> #####\n+    // H6 -> ######\n+    if (featureEnabled('h')) {\n+      toProcess = preprocess['h'] || {};\n+      $(':header', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let nodeName = $(this).prop('nodeName') || '0';\n+        if (nodeName && text && text.length > min_text_length_k) {\n+          let x = nodeName.substr(-1);\n+          toProcess[text.toLowerCase()] = `\\n${'#'.repeat(x)} ${text}\\n`; // Intentionally overwrites duplicates\n+        }\n+      });\n+      sortAndPlaceholderize(toProcess);\n+    }\n+\n+    replaced = this.replacer(body, replacer_dict); // Replace initial batch of <div> like placeholders\n+    body = replaced;\n+    replacer_dict = {}; // Reset\n+    count = 0; // Reset\n+\n+    // bold: b -> **text**\n+    processMarkdown('b', ' **%text%** ');\n+\n+    // italics: i -> _text_\n+    processMarkdown('i', ' _%text%_ ');\n+\n+    // links:\n+    // a -> [text](html)\n+    if (featureEnabled('a')) {\n+      toProcess = preprocess['a'] || {};\n+      $('a', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let href = ($(this).prop('href') || '').trim(); // Was attr\n+        /*\n+              var uri_display = self.uriForDisplay(href);\n+              var comment = ' \"' + text + ' via ' + uri_display + '\"';\n+              var re = new RegExp(self.escapeRegExp(text), \"i\");\n+              if (uri.match(re)) {\n+                  comment = ' \"Open ' + uri_display + '\"';\n+              }\n+              */\n+        if (href && text && text.length >= min_text_length_k) {\n+          toProcess[text.toLowerCase()] = self.anchorMarkdownify(text, href); // Comment seemed like too much extra text // Intentionally overwrites duplicates\n+        }\n+      });\n+      sortAndPlaceholderize(toProcess);\n+    }\n+\n+    /* DISABLED (Ace, 16-Jan-2017): Images kinda make a mess, until requested lets not markdownify them:\n+      // images:\n+      // img -> ![alt_text](html)\n+      if (featureEnabled('img')) {\n+          $('img', $html).each(function(index, value) {\n+              var text = ($(this).prop(\"alt\") || \"\").trim(); // Was attr\n+              var href = ($(this).prop(\"src\") || \"\").trim(); // Was attr\n+              // var uri_display = self.uriForDisplay(href);\n+              if (href && text && text.length >= min_text_length_k) {\n+                  toProcess[text.toLowerCase()] = self.anchorMarkdownify(text, href); // Comment seemed like too much extra text // Intentionally overwrites duplicates\n+              }\n+          });\n+          sortAndPlaceholderize(toProcess);\n+      }\n+      */\n+\n+    replaced = this.replacer(body, replacer_dict); // Replace second batch of <span> like placeholders\n+    body = replaced;\n+\n+    // Replace bullets following a CRLF:\n+    replaced = body.replace(/\\s*[\\n\\r]+\\s*[·-]+\\s*/g, '<p />* '); // = [\\u00B7\\u2022]\n+    body = replaced;\n+\n+    // Replace remaining bullets with asterisks:\n+    replaced = body.replace(/[·]/g, '*');\n+    body = replaced;\n+\n+    // ORDER MATTERS FOR THIS NEXT SET:\n+    // (1) Replace <space>CRLF<space> with just CR:\n+    replaced = body.replace(/\\s*[\\n\\r]+\\s*/g, '\\n');\n+    body = replaced;\n+\n+    // (2) Replace 2 or more spaces with just one:\n+    replaced = repeatReplace(body, new RegExp('\\\\s{2,}', 'g'), ' ');\n+    body = replaced;\n+\n+    // (3) Replace paragraph markers with CR+CR:\n+    replaced = body.replace(/\\s*<p \\/>\\s*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // (4) Replace 3 or more CRs with just two:\n+    replaced = repeatReplace(body, new RegExp('\\\\n{3,}', 'g'), '\\n\\n');\n+    body = replaced;\n+\n+    // (5) Trim excess at beginning and end:\n+    replaced = body.trim();\n+    body = replaced;\n+\n+    return body;\n+  }\n+\n+  /**\n+   * Determine luminance of a color so we can augment with darker/lighter background\n+   */\n+  luminance(color) {\n+    let bkColorLight = 'lightGray'; // or white\n+    let bkColorDark = 'darkGray'; // 'gray' is even darker\n+    let bkColorReturn = bkColorLight;\n+\n+    let re = new RegExp('rgb\\\\D+(\\\\d+)\\\\D+(\\\\d+)\\\\D+(\\\\d+)');\n+    let matched = color.match(re, 'i');\n+    if (matched && matched.length > 2) {\n+      // 0 is total string:\n+      let r = matched[1];\n+      let g = matched[2];\n+      let b = matched[3];\n+      // var 1 = matched[4]; // if alpha is provided\n+\n+      let luma = 0.2126 * r + 0.7152 * g + 0.0722 * b; // per ITU-R BT.709\n+\n+      if (luma < 40) {\n+        bkColorReturn = bkColorDark;\n+      } else {\n+        bkColorReturn = bkColorLight;\n+      }\n+    } else {\n+      bkColorReturn = bkColorLight; // RegExp failed, assume dark color\n+    }\n+\n+    return 'inherit'; // Use: bkColorReturn if you want to adjust background based on text perceived brightness\n+  }\n+\n+  /**\n+   * HTML bookend a string\n+   */\n+  bookend(bookend, text, style) {\n+    return (\n+      '<' +\n+      bookend +\n+      (style ? ' style=\"' + style + '\"' : '') +\n+      '>' +\n+      (text || '') +\n+      '</' +\n+      bookend +\n+      '>'\n+    );\n+  }\n+\n+  /**\n+   * Get selected text\n+   * http://stackoverflow.com/questions/5379120/get-the-highlighted-selected-text\n+   */\n+  getSelectedText() {\n+    let text = '';\n+    let activeEl = document.activeElement;\n+    let activeElTagName = activeEl ? activeEl.tagName.toLowerCase() : null;\n+    if (\n+      (activeElTagName == 'textarea' || activeElTagName == 'input') &&\n+      /^(?:text|search|password|tel|url)$/i.test(activeEl.type) &&\n+      typeof activeEl.selectionStart == 'number'\n+    ) {\n+      text = activeEl.value\n+        .slice(activeEl.selectionStart, activeEl.selectionEnd)\n+        .trim();\n+    } else if (document.selection) {\n+      text = document.selection.createRange().text.trim();\n+    } else if (document.getSelection) {\n+      text = document.getSelection().toString().trim();\n+    } else if (window.getSelection) {\n+      text = window.getSelection().toString().trim();\n+    }\n+    return text;\n+  }\n+\n+  /**\n+   * Truncate a string\n+   */\n+  truncate(text, max, add) {\n+    let retn = text || '';\n+    const add_k = this.decodeEntities(add || '');\n+    const max_k = max - add_k.length;\n+\n+    if (text && text.length > max_k) {\n+      retn = text.slice(0, max_k) + add_k;\n+    }\n+    return retn;\n+  }\n+\n+  /***\n+   * Middle-truncate a string\n+   */\n+  midTruncate(text, max, add) {\n+    let retn = text || '';\n+    const add_k = this.decodeEntities(add || '');\n+    const max_k = Math.abs((max || 0) - add_k.length);\n+    const mid_k = (max_k + 0.01) / 2;\n+\n+    if (text && text.length > max_k) {\n+      retn = text.slice(0, mid_k + 1) + add_k + text.slice(-mid_k);\n+    }\n+    return retn;\n+  }\n+\n+  /**\n+   * Load settings\n+   */\n+  loadSettings(popup) {\n+    const self = this;\n+    const setID = self.CHROME_SETTINGS_ID;\n+    chrome.storage.sync.get(setID, function (response) {\n+      if (response?.[setID]) {\n+        // NOTE (Ace, 7-Feb-2017): Might need to store these off the app object:\n+        try {\n+          self.popupView.data.settings = JSON.parse(response[setID]);\n+        } catch (err) {\n+          g2t_log(\n+            'loadSettings: JSON parse failed! Error: ' + JSON.stringify(err)\n+          );\n+        }\n+      }\n+      if (popup) {\n+        popup.init_popup();\n+        self.updateData();\n+      }\n+    });\n+  }\n+\n+  /**\n+   * Save settings\n+   */\n+  saveSettings() {\n+    const self = this;\n+    const setID = self.CHROME_SETTINGS_ID;\n+    let settings = Object.assign({}, self.popupView.data.settings);\n+\n+    // Delete large, potentially needing secure, data bits:\n+    settings.description = '';\n+    settings.title = '';\n+    settings.attachments = [];\n+    settings.images = [];\n+    delete settings.description;\n+    delete settings.title;\n+    delete settings.attachments;\n+    delete settings.images;\n+\n+    const settings_string_k = JSON.stringify(settings);\n+\n+    hash = {};\n+    hash[setID] = settings_string_k;\n+\n+    if (self.lastSettingsSave !== settings_string_k) {\n+      try {\n+        chrome.storage.sync.set(hash); // NOTE (Ace, 7-Feb-2017): Might need to store these off the app object\n+        self.lastSettingsSave = settings_string_k;\n+      } catch (error) {\n+        g2t_log(\n+          `saveSettings ERROR: extension context invalidated - failed \"chrome.storage.sync.set\"`\n+        );\n+        self?.popupView?.displayExtensionInvalidReload();\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Encode entities\n+   */\n+  encodeEntities(s) {\n+    let ta = document.createElement('textarea');\n+    ta.value = s;\n+    return ta.innerHTML;\n+    // jQuery way, less safe: return $(\"<textarea />\").text(s).html();\n+  }\n+\n+  /**\n+   * Decode entities\n+   */\n+  decodeEntities(s) {\n+    const self = this;\n+    const dict_k = { '...': '&hellip;', '*': '&bullet;', '-': '&mdash;' };\n+    let re, new_s;\n+    g2t_each(dict_k, function (value, key) {\n+      // value is already available from the callback parameter\n+      re = new RegExp(self.escapeRegExp(key), 'gi');\n+      new_s = s.replace(re, value);\n+      s = new_s;\n+    });\n+    try {\n+      new_s = decodeURIComponent(s);\n+      s = new_s;\n+    } catch (e) {\n+      // Didn't work. Ignore.\n+    }\n+    let ta = document.createElement('textarea');\n+    ta.style.cssText = 'white-space: pre-line;';\n+    ta.innerHTML = s;\n+    return ta.value;\n+    // jQuery way, less safe: return $(\"<textarea />\").html(s).text();\n+  }",
    "path": "chrome_manifest_v3/class_app.js",
    "commit_id": "3bbc7b0b5b5abfda366260c45d6f2cecebf28af3",
    "original_commit_id": "ae0a391b6759338b0ec3c3292da07e458841ab71",
    "user": {
      "login": "coderabbitai[bot]",
      "id": 136622811,
      "node_id": "BOT_kgDOCCSy2w",
      "avatar_url": "https://avatars.githubusercontent.com/in/347564?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/coderabbitai%5Bbot%5D",
      "html_url": "https://github.com/apps/coderabbitai",
      "followers_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "_🛠️ Refactor suggestion_\n\n**Don't reassign parameters. Use const for ta.**\n\n\n```diff\n   decodeEntities(s) {\n     const self = this;\n     const dict_k = { '...': '&hellip;', '*': '&bullet;', '-': '&mdash;' };\n-    let re, new_s;\n+    let re, new_s, result = s;\n     g2t_each(dict_k, function (value, key) {\n       // value is already available from the callback parameter\n       re = new RegExp(self.escapeRegExp(key), 'gi');\n-      new_s = s.replace(re, value);\n-      s = new_s;\n+      new_s = result.replace(re, value);\n+      result = new_s;\n     });\n     try {\n-      new_s = decodeURIComponent(s);\n-      s = new_s;\n+      new_s = decodeURIComponent(result);\n+      result = new_s;\n     } catch (e) {\n       // Didn't work. Ignore.\n     }\n-    let ta = document.createElement('textarea');\n+    const ta = document.createElement('textarea');\n     ta.style.cssText = 'white-space: pre-line;';\n-    ta.innerHTML = s;\n+    ta.innerHTML = result;\n     return ta.value;\n     // jQuery way, less safe: return $(\"<textarea />\").html(s).text();\n   }\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>📝 Committable suggestion</summary>\n\n> ‼️ **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n  decodeEntities(s) {\n    const self = this;\n    const dict_k = { '...': '&hellip;', '*': '&bullet;', '-': '&mdash;' };\n    let re, new_s, result = s;\n    g2t_each(dict_k, function (value, key) {\n      // value is already available from the callback parameter\n      re = new RegExp(self.escapeRegExp(key), 'gi');\n      new_s = result.replace(re, value);\n      result = new_s;\n    });\n    try {\n      new_s = decodeURIComponent(result);\n      result = new_s;\n    } catch (e) {\n      // Didn't work. Ignore.\n    }\n    const ta = document.createElement('textarea');\n    ta.style.cssText = 'white-space: pre-line;';\n    ta.innerHTML = result;\n    return ta.value;\n    // jQuery way, less safe: return $(\"<textarea />\").html(s).text();\n  }\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>🧰 Tools</summary>\n\n<details>\n<summary>🪛 Biome (1.9.4)</summary>\n\n[error] 777-778: Declare variables separately\n\nUnsafe fix: Break out into multiple declarations\n\n\n(lint/style/useSingleVarDeclarator)\n\n---\n\n[error] 782-782: Reassigning a function parameter is confusing.\n\nThe parameter is declared here:\n\nUse a local variable instead.\n\n(lint/style/noParameterAssign)\n\n---\n\n[error] 786-786: Reassigning a function parameter is confusing.\n\nThe parameter is declared here:\n\nUse a local variable instead.\n\n(lint/style/noParameterAssign)\n\n---\n\n[error] 790-790: This let declares a variable that is only assigned once.\n\n'ta' is never reassigned.\n\nSafe fix: Use const instead.\n\n\n(lint/style/useConst)\n\n</details>\n\n</details>\n\n<details>\n<summary>🤖 Prompt for AI Agents</summary>\n\n```\nIn chrome_manifest_v3/class_app.js around lines 774 to 795, the parameter 's' is\nreassigned multiple times, which is discouraged. Refactor the code to avoid\nreassigning 's' by using a new variable for the transformed string instead.\nAlso, declare the 'ta' variable as const since it is not reassigned after\ninitialization.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:lion -->\n\n<!-- This is an auto-generated reply by CodeRabbit -->",
    "created_at": "2025-07-13T21:43:20Z",
    "updated_at": "2025-07-14T04:46:32Z",
    "html_url": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203532568",
    "pull_request_url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532568"
      },
      "html": {
        "href": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203532568"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532568/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 774,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 795,
    "side": "RIGHT",
    "original_position": 795,
    "position": null,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532569",
    "pull_request_review_id": 3014319788,
    "id": 2203532569,
    "node_id": "PRRC_kwDOD1hYKM6DVz0Z",
    "diff_hunk": "@@ -0,0 +1,848 @@\n+/** Gmail2Trello Application - ES6 Class Version\n+ */\n+\n+var Gmail2Trello = Gmail2Trello || {}; // Namespace initialization - must be var to guarantee correct scope\n+\n+class App {\n+  constructor() {\n+    this.CHROME_SETTINGS_ID = 'g2t_user_settings';\n+    this.UNIQUE_URI_VAR = 'g2t_filename';\n+\n+    this.model = new Gmail2Trello.Model(this);\n+    this.gmailView = new Gmail2Trello.GmailView(this);\n+    this.popupView = new Gmail2Trello.PopupView(this);\n+\n+    this.bindEvents();\n+  }\n+\n+  bindEvents() {\n+    const self = this;\n+\n+    /*** Data's events binding ***/\n+    this.model.event.addListener('onBeforeAuthorize', function () {\n+      self.popupView.bindData(''); // Intentionally blank\n+      self.popupView.showMessage(self, 'Authorizing...');\n+    });\n+\n+    this.model.event.addListener('onAuthorizeFail', function () {\n+      // self.model.isInitialized = false;\n+      self.popupView.showMessage(\n+        self,\n+        'Trello authorization failed <button id=\"showsignout\">Sign out and try again</button>'\n+      );\n+    });\n+\n+    this.model.event.addListener('onAuthorized', function () {\n+      // g2t_log('onAuthorized');\n+      // g2t_log(\"Status: \" + Trello.authorized().toString());\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+    });\n+\n+    this.model.event.addListener('onBeforeLoadTrello', function () {\n+      self.popupView.showMessage(self, 'Loading Trello data...');\n+    });\n+\n+    this.model.event.addListener('onTrelloDataReady', function () {\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+\n+      self.popupView.bindData(self.model);\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloListSuccess', function () {\n+      self.popupView.updateLists();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloCardsSuccess', function () {\n+      self.popupView.updateCards();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloLabelsSuccess', function () {\n+      self.popupView.updateLabels();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloMembersSuccess', function () {\n+      self.popupView.updateMembers();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener(\n+      'onCardSubmitComplete',\n+      function (target, params) {\n+        self.popupView.displaySubmitCompleteForm();\n+        // If card lists or labels have been updated, reload:\n+        const data_k = params?.data || {};\n+        const emailId = data_k?.emailId || 0;\n+        const boardId_k = data_k?.data?.board?.id || 0;\n+        const listId_k = data_k?.data?.list?.id || 0;\n+        const cardId_k = data_k?.data?.card?.id || 0;\n+        const idBoard_k = data_k?.idBoard || 0;\n+        const idList_k = data_k?.idList || 0;\n+        const idCard_k = data_k?.idCard || 0;\n+        const boardId = boardId_k || idBoard_k || 0;\n+        const listId = listId_k || idList_k || 0;\n+        const cardId = cardId_k || idCard_k || 0;\n+        // NOTE (acoven@2020-05-23): Users expect when creating a brand new card,\n+        // we'll remember that new card ID and then keep defaulting to it for\n+        // subsequent updates to that email. That means we'll have to get the return\n+        // value/url from Trello and dissect that, potentially doing this update\n+        // in that routine:\n+        self.model.emailBoardListCardMapUpdate({\n+          emailId,\n+          boardId,\n+          listId,\n+          cardId,\n+        });\n+\n+        if (boardId) {\n+          self.model.loadTrelloLabels(boardId);\n+          self.model.loadTrelloMembers(boardId);\n+        }\n+        if (listId) {\n+          self.model.loadTrelloCards(listId);\n+        }\n+      }\n+    );\n+\n+    this.model.event.addListener('onAPIFailure', function (target, params) {\n+      self.popupView.displayAPIFailedForm(params);\n+    });\n+\n+    /*** PopupView's events binding ***/\n+\n+    this.popupView.event.addListener('onPopupVisible', function () {\n+      if (!self.model.isInitialized) {\n+        self.popupView.showMessage(self, 'Initializing...');\n+        self.popupView.$popupContent.hide();\n+        self.model.init();\n+      } else {\n+        self.popupView.reset();\n+      }\n+\n+      const trelloUser_k = self?.model?.trello?.user || {};\n+      const fullName = trelloUser_k?.fullName || '';\n+\n+      self.gmailView.parsingData = false;\n+      self.model.gmail = self.gmailView.parseData({ fullName });\n+      self.popupView.bindGmailData(self.model.gmail);\n+      self.popupView.event.fire('periodicChecks');\n+    });\n+\n+    this.popupView.event.addListener('periodicChecks', function () {\n+      setTimeout(function () {\n+        self.popupView.periodicChecks();\n+      }, 3000);\n+    });\n+\n+    this.popupView.event.addListener('onBoardChanged', function (target, params) {\n+      let boardId = params.boardId;\n+      if (boardId !== '_' && boardId !== '' && boardId !== null) {\n+        self.model.loadTrelloLists(boardId);\n+        self.model.loadTrelloLabels(boardId);\n+        self.model.loadTrelloMembers(boardId);\n+      }\n+    });\n+\n+    this.popupView.event.addListener('onListChanged', function (target, params) {\n+      let listId = params.listId;\n+      self.model.loadTrelloCards(listId);\n+    });\n+\n+    this.popupView.event.addListener('onSubmit', function () {\n+      self.model.submit();\n+    });\n+\n+    this.popupView.event.addListener('checkTrelloAuthorized', function () {\n+      self.popupView.showMessage(self, 'Authorizing...');\n+      self.model.checkTrelloAuthorized();\n+    });\n+\n+    this.popupView.event.addListener('onRequestDeauthorizeTrello', function () {\n+      g2t_log('onRequestDeauthorizeTrello');\n+      self.model.deauthorizeTrello();\n+      self.popupView.clearBoard();\n+    });\n+\n+    const eventDetectButton = function () {\n+      if (self.gmailView.preDetect()) {\n+        self.popupView.$toolBar = self.gmailView.$toolBar;\n+        self.popupView.confirmPopup();\n+      }\n+    };\n+\n+    this.popupView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    // GMailView's events:\n+\n+    this.gmailView.event.addListener('onDetected', function () {\n+      self.popupView.$toolBar = self.gmailView.$toolBar;\n+      self.popupView.init();\n+    });\n+\n+    this.gmailView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    chrome.runtime.onMessage.addListener(function (\n+      request,\n+      sender,\n+      sendResponse\n+    ) {\n+      if (request?.message === 'g2t_keyboard_shortcut') {\n+        self.popupView.showPopup();\n+      }\n+    });\n+  }\n+\n+  updateData() {\n+    const self = this;",
    "path": "chrome_manifest_v3/class_app.js",
    "commit_id": "3bbc7b0b5b5abfda366260c45d6f2cecebf28af3",
    "original_commit_id": "ae0a391b6759338b0ec3c3292da07e458841ab71",
    "user": {
      "login": "coderabbitai[bot]",
      "id": 136622811,
      "node_id": "BOT_kgDOCCSy2w",
      "avatar_url": "https://avatars.githubusercontent.com/in/347564?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/coderabbitai%5Bbot%5D",
      "html_url": "https://github.com/apps/coderabbitai",
      "followers_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "_🛠️ Refactor suggestion_\n\n**Remove unnecessary self. Use this.**\n\nArrow functions inherit this.\n\n```diff\n-  updateData() {\n-    const self = this;\n-\n-    const fullName = self?.model?.trello?.user?.fullName || '';\n+  updateData() {\n+    const fullName = this?.model?.trello?.user?.fullName || '';\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>📝 Committable suggestion</summary>\n\n> ‼️ **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n  updateData() {\n-    const self = this;\n-\n-    const fullName = self?.model?.trello?.user?.fullName || '';\n+    const fullName = this?.model?.trello?.user?.fullName || '';\n    // ... rest of updateData unchanged ...\n  }\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>🧰 Tools</summary>\n\n<details>\n<summary>🪛 Biome (1.9.4)</summary>\n\n[error] 204-204: This aliasing of this is unnecessary.\n\nArrow functions inherits `this` from their enclosing scope.\nSafe fix: Use this instead of an alias.\n\n\n(lint/complexity/noUselessThisAlias)\n\n</details>\n\n</details>\n\n<details>\n<summary>🤖 Prompt for AI Agents</summary>\n\n```\nIn chrome_manifest_v3/class_app.js at line 204, the assignment of 'const self =\nthis;' is unnecessary because arrow functions automatically inherit the 'this'\ncontext. Remove the declaration of 'self' and replace any usage of 'self' within\nthe arrow function with 'this' directly to simplify the code.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:lion -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->\n\n✅ Addressed in commit 8198420",
    "created_at": "2025-07-13T21:43:20Z",
    "updated_at": "2025-07-14T04:11:16Z",
    "html_url": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203532569",
    "pull_request_url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532569"
      },
      "html": {
        "href": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203532569"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532569/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 204,
    "side": "RIGHT",
    "original_position": 204,
    "position": null,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532570",
    "pull_request_review_id": 3014319788,
    "id": 2203532570,
    "node_id": "PRRC_kwDOD1hYKM6DVz0a",
    "diff_hunk": "@@ -0,0 +1,848 @@\n+/** Gmail2Trello Application - ES6 Class Version\n+ */\n+\n+var Gmail2Trello = Gmail2Trello || {}; // Namespace initialization - must be var to guarantee correct scope\n+\n+class App {\n+  constructor() {\n+    this.CHROME_SETTINGS_ID = 'g2t_user_settings';\n+    this.UNIQUE_URI_VAR = 'g2t_filename';\n+\n+    this.model = new Gmail2Trello.Model(this);\n+    this.gmailView = new Gmail2Trello.GmailView(this);\n+    this.popupView = new Gmail2Trello.PopupView(this);\n+\n+    this.bindEvents();\n+  }\n+\n+  bindEvents() {\n+    const self = this;\n+\n+    /*** Data's events binding ***/\n+    this.model.event.addListener('onBeforeAuthorize', function () {\n+      self.popupView.bindData(''); // Intentionally blank\n+      self.popupView.showMessage(self, 'Authorizing...');\n+    });\n+\n+    this.model.event.addListener('onAuthorizeFail', function () {\n+      // self.model.isInitialized = false;\n+      self.popupView.showMessage(\n+        self,\n+        'Trello authorization failed <button id=\"showsignout\">Sign out and try again</button>'\n+      );\n+    });\n+\n+    this.model.event.addListener('onAuthorized', function () {\n+      // g2t_log('onAuthorized');\n+      // g2t_log(\"Status: \" + Trello.authorized().toString());\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+    });\n+\n+    this.model.event.addListener('onBeforeLoadTrello', function () {\n+      self.popupView.showMessage(self, 'Loading Trello data...');\n+    });\n+\n+    this.model.event.addListener('onTrelloDataReady', function () {\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+\n+      self.popupView.bindData(self.model);\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloListSuccess', function () {\n+      self.popupView.updateLists();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloCardsSuccess', function () {\n+      self.popupView.updateCards();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloLabelsSuccess', function () {\n+      self.popupView.updateLabels();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloMembersSuccess', function () {\n+      self.popupView.updateMembers();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener(\n+      'onCardSubmitComplete',\n+      function (target, params) {\n+        self.popupView.displaySubmitCompleteForm();\n+        // If card lists or labels have been updated, reload:\n+        const data_k = params?.data || {};\n+        const emailId = data_k?.emailId || 0;\n+        const boardId_k = data_k?.data?.board?.id || 0;\n+        const listId_k = data_k?.data?.list?.id || 0;\n+        const cardId_k = data_k?.data?.card?.id || 0;\n+        const idBoard_k = data_k?.idBoard || 0;\n+        const idList_k = data_k?.idList || 0;\n+        const idCard_k = data_k?.idCard || 0;\n+        const boardId = boardId_k || idBoard_k || 0;\n+        const listId = listId_k || idList_k || 0;\n+        const cardId = cardId_k || idCard_k || 0;\n+        // NOTE (acoven@2020-05-23): Users expect when creating a brand new card,\n+        // we'll remember that new card ID and then keep defaulting to it for\n+        // subsequent updates to that email. That means we'll have to get the return\n+        // value/url from Trello and dissect that, potentially doing this update\n+        // in that routine:\n+        self.model.emailBoardListCardMapUpdate({\n+          emailId,\n+          boardId,\n+          listId,\n+          cardId,\n+        });\n+\n+        if (boardId) {\n+          self.model.loadTrelloLabels(boardId);\n+          self.model.loadTrelloMembers(boardId);\n+        }\n+        if (listId) {\n+          self.model.loadTrelloCards(listId);\n+        }\n+      }\n+    );\n+\n+    this.model.event.addListener('onAPIFailure', function (target, params) {\n+      self.popupView.displayAPIFailedForm(params);\n+    });\n+\n+    /*** PopupView's events binding ***/\n+\n+    this.popupView.event.addListener('onPopupVisible', function () {\n+      if (!self.model.isInitialized) {\n+        self.popupView.showMessage(self, 'Initializing...');\n+        self.popupView.$popupContent.hide();\n+        self.model.init();\n+      } else {\n+        self.popupView.reset();\n+      }\n+\n+      const trelloUser_k = self?.model?.trello?.user || {};\n+      const fullName = trelloUser_k?.fullName || '';\n+\n+      self.gmailView.parsingData = false;\n+      self.model.gmail = self.gmailView.parseData({ fullName });\n+      self.popupView.bindGmailData(self.model.gmail);\n+      self.popupView.event.fire('periodicChecks');\n+    });\n+\n+    this.popupView.event.addListener('periodicChecks', function () {\n+      setTimeout(function () {\n+        self.popupView.periodicChecks();\n+      }, 3000);\n+    });\n+\n+    this.popupView.event.addListener('onBoardChanged', function (target, params) {\n+      let boardId = params.boardId;\n+      if (boardId !== '_' && boardId !== '' && boardId !== null) {\n+        self.model.loadTrelloLists(boardId);\n+        self.model.loadTrelloLabels(boardId);\n+        self.model.loadTrelloMembers(boardId);\n+      }\n+    });\n+\n+    this.popupView.event.addListener('onListChanged', function (target, params) {\n+      let listId = params.listId;\n+      self.model.loadTrelloCards(listId);\n+    });\n+\n+    this.popupView.event.addListener('onSubmit', function () {\n+      self.model.submit();\n+    });\n+\n+    this.popupView.event.addListener('checkTrelloAuthorized', function () {\n+      self.popupView.showMessage(self, 'Authorizing...');\n+      self.model.checkTrelloAuthorized();\n+    });\n+\n+    this.popupView.event.addListener('onRequestDeauthorizeTrello', function () {\n+      g2t_log('onRequestDeauthorizeTrello');\n+      self.model.deauthorizeTrello();\n+      self.popupView.clearBoard();\n+    });\n+\n+    const eventDetectButton = function () {\n+      if (self.gmailView.preDetect()) {\n+        self.popupView.$toolBar = self.gmailView.$toolBar;\n+        self.popupView.confirmPopup();\n+      }\n+    };\n+\n+    this.popupView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    // GMailView's events:\n+\n+    this.gmailView.event.addListener('onDetected', function () {\n+      self.popupView.$toolBar = self.gmailView.$toolBar;\n+      self.popupView.init();\n+    });\n+\n+    this.gmailView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    chrome.runtime.onMessage.addListener(function (\n+      request,\n+      sender,\n+      sendResponse\n+    ) {\n+      if (request?.message === 'g2t_keyboard_shortcut') {\n+        self.popupView.showPopup();\n+      }\n+    });\n+  }\n+\n+  updateData() {\n+    const self = this;\n+\n+    const fullName = self?.model?.trello?.user?.fullName || '';\n+\n+    self.popupView.bindData(self.model);\n+\n+    self.gmailView.parsingData = false;\n+    self.model.gmail = self.gmailView.parseData({ fullName });\n+    self.popupView.bindGmailData(self.model.gmail);\n+  }\n+\n+  initialize() {\n+    const self = this;\n+\n+    this.model.isInitialized = false;\n+\n+    // g2t_log('App:initialize');\n+\n+    this.gmailView.detect();\n+\n+    service = analytics.getService('gmail-2-trello');\n+\n+    // Get a Tracker using your Google Analytics app Tracking ID.\n+    tracker = service.getTracker('G-0QPEDL7YDL'); // Was: UA-8469046-1 -> UA-42442437-4\n+\n+    // Record an \"appView\" each time the user launches your app or goes to a new\n+    // screen within the app.\n+    tracker.sendAppView('PopupView');\n+  }\n+\n+  /**\n+   * Correctly escape RegExp\n+   */\n+  escapeRegExp(str) {\n+    return str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n+  }\n+\n+  /**\n+   * Utility routine to replace variables\n+   */\n+  replacer(text, dict) {\n+    let self = this;\n+\n+    if (!text || text.length < 1) {\n+      // g2t_log('Require text!');\n+      return '';\n+    } else if (!dict || dict.length < 2) {\n+      g2t_log('replacer: Require dictionary!');\n+      return text;\n+    }\n+\n+    let re, new_text;\n+    const replacify = function () {\n+      g2t_each(dict, function (value, key) {\n+        re = new RegExp(`%${self.escapeRegExp(key)}%`, 'gi');\n+        new_text = text.replace(re, value);\n+        text = new_text;\n+      });\n+    };\n+\n+    let runaway_max = 3;\n+    while (text.indexOf('%') !== -1 && runaway_max-- > 0) {\n+      replacify();\n+    }\n+\n+    return text;\n+  }\n+\n+  /**\n+   * Make displayable URI\n+   */\n+  uriForDisplay(uri) {\n+    const uri_display_trigger_length_k = 20;\n+    const uri_length_max_k = 40;\n+    let uri_display = uri || '';\n+    if (uri_display.length > uri_display_trigger_length_k) {\n+      let re = RegExp('^\\\\w+://([\\\\w./_-]+).*?([\\\\w._-]*)$');\n+      let matched = uri_display.match(re);\n+      if (matched && matched.length > 1) {\n+        const filename_k =\n+          matched[2].length < uri_length_max_k\n+            ? matched[2]\n+            : matched[2].slice(-uri_length_max_k);\n+        let prelude = matched[1].substr(0, uri_length_max_k);\n+        if (matched[1].length > uri_length_max_k) {\n+          prelude += '...';\n+        } else if (filename_k.length > 0) {\n+          prelude += ':';\n+        }\n+\n+        uri_display = prelude + filename_k;\n+      }\n+    }\n+    return uri_display;\n+  }\n+\n+  /**\n+   * Make anchored backlink\n+   */\n+  anchorMarkdownify(text, href, comment) {\n+    let text1 = (text || '').trim();\n+    let text1lc = text1.toLowerCase();\n+    let href1 = (href || '').trim();\n+    let href1lc = href1.toLowerCase();\n+    let comment1 = (comment || '').trim();\n+\n+    let retn = '';\n+\n+    if (text1.length < 1 && href1.length < 1) {\n+      // Intetionally blank\n+    } else if (text1lc === href1lc) {\n+      retn = ` <${href1}> `; // This renders correctly in Trello as a sole URL\n+      // NOTE (Ace, 17-Feb-2017): Turns out Trello doesn't support markdown [] only, so we'll construct a nice displayable text vs url:\n+      // text1 = this.uriForDisplay(text1);\n+    } else if (`mailto:${text1lc}` === href1lc) {\n+      retn = ` <${text1}> `; // This renders correctly in Trello as a mailto: url\n+    } else {\n+      const comment1QuotedSpaced = comment1.length > 0 ? ` \"${comment1}\"` : '';\n+      retn = ` [${text1}](<${href1}>${comment1QuotedSpaced}) `;\n+    }\n+\n+    return retn;\n+  }\n+\n+  /**\n+   * Split an email into name and domain\n+   */\n+  splitEmailDomain(email = '') {\n+    const split = email.split('@');\n+    const name = split[0] || '';\n+    const domain = split[1] || '';\n+    return {\n+      name,\n+      domain,\n+    };\n+  }\n+\n+  /**\n+   * Add trailing char if not empty:\n+   */\n+  addChar(front = '', back = '', addChar = ' ') {\n+    if (front.length > 0) {\n+      if (back.length > 0) {\n+        return `${front}${addChar}${back}`;\n+      } else {\n+        return `${front}${addChar}`;\n+      }\n+    } else if (back.length > 0) {\n+      return `${addChar}${back}`;\n+    } else {\n+      return '';\n+    }\n+  }\n+\n+  /**\n+   * Add trailing space if not empty:\n+   */\n+  addSpace(front = '', back = '') {\n+    return this.addChar(front, back, ' ');\n+  }\n+\n+  /**\n+   * Add trailing CRLF if not empty:\n+   */\n+  addCRLF(front = '', back = '') {\n+    return this.addChar(front, back, '\\n');\n+  }\n+\n+  /**\n+   * Markdownify a text block\n+   */\n+  markdownify($emailBody, features, preprocess) {\n+    if (!$emailBody || $emailBody.length < 1) {\n+      g2t_log('markdownify: Require emailBody!');\n+      return;\n+    }\n+    const self = this;\n+\n+    const min_text_length_k = 4;\n+    const max_replace_attempts_k = 10;\n+    const regexp_k = {\n+      begin: '(^|\\\\s+|<|\\\\[|\\\\(|\\\\b|(?=\\\\W+))',\n+      end: '($|\\\\s+|>|\\\\]|\\\\)|\\\\b|(?=\\\\W+))',\n+    };\n+    const unique_placeholder_k = 'g2t_placeholder:'; // Unique placeholder tag\n+\n+    let count = 0;\n+    let replacer_dict = {};\n+\n+    const featureEnabled = (elementTag = '') =>\n+      features === false ? false : features?.[elementTag] !== false;\n+\n+    let $html = $emailBody || ''; // Was: $emailBody.innerHTML || \"\";\n+    // let body = $emailBody.text() || \"\";\n+    let body = $emailBody.html() || '';\n+\n+    // Different encodings handle CRLF differently, so we'll process the main body as html and convert to text:\n+    // Convert paragraph marker to two returns:\n+    let replaced = body.replace(/\\s*[\\n\\r]*<p[^>]*>\\s*[\\n\\r]*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // Convert br marker to one return:\n+    replaced = body.replace(/\\s*[\\n\\r]*<br[^>]*>\\s*[\\n\\r]*/g, '\\n');\n+    body = replaced;\n+\n+    // Remove all other html markers:\n+    replaced = body.replace(/<[^>]*>/g, '');\n+    body = replaced;\n+\n+    // Decode HTML entities:\n+    replaced = self.decodeEntities(body);\n+    body = replaced;\n+\n+    // Replace hr:\n+    replaced = body.replace(/\\s*-{3,}\\s*/g, '---\\n');\n+    body = replaced;\n+\n+    // Convert crlf x 2 (or more) to paragraph markers:\n+    replaced = body.replace(/(\\s*[\\n\\r]\\s*){2,}/g, '<p />\\n');\n+    body = replaced;\n+\n+    let toProcess = {};\n+\n+    /**\n+     * 5 explicit steps in 3 passes:\n+     * (1) Collect tagged items\n+     * (2) Remove duplicates\n+     * (3) Sort force-lowercase by length\n+     * (4) Replace with placeholder\n+     * (5) Replace placeholders with final text\n+     */\n+    const sortAndPlaceholderize = function (tooProcess) {\n+      if (tooProcess) {\n+        g2t_each(\n+          Object.keys(tooProcess).sort(function (a, b) {\n+            // Go by order of largest to smallest\n+            return b.length - a.length;\n+          }),\n+          function (value) {\n+            const replace = tooProcess[value];\n+            const swap = `${unique_placeholder_k}${(count++).toString()}`;\n+            const re = new RegExp(\n+              regexp_k.begin + self.escapeRegExp(value) + regexp_k.end,\n+              'gi'\n+            );\n+            const replaced = body.replace(re, `%${swap}%`); // Replace occurance with placeholder\n+            if (body !== replaced) {\n+              body = replaced;\n+              replacer_dict[swap] = replace;\n+            }\n+          }\n+        );\n+      }\n+    };\n+    const processMarkdown = function (elementTag, replaceText) {\n+      if (elementTag && replaceText && featureEnabled(elementTag)) {\n+        toProcess = preprocess[elementTag] || {};\n+        $(elementTag, $html).each(function (index, value) {\n+          let text = ($(this).text() || '').trim();\n+          if (text && text.length > min_text_length_k) {\n+            let replace = self.replacer(replaceText, { text: text });\n+            toProcess[text.toLowerCase()] = replace; // Intentionally overwrites duplicates\n+          }\n+        });\n+        sortAndPlaceholderize(toProcess);\n+      }\n+    };\n+    /**\n+     * Repeat replace for max attempts or when done, whatever comes first\n+     */\n+    const repeatReplace = function (body, inRegexp, replaceWith) {\n+      let replace1 = '';\n+      for (let iter = max_replace_attempts_k; iter > 0; iter--) {\n+        replace1 = body.replace(inRegexp, replaceWith);\n+        if (body === replace1) {\n+          iter = 0; // All done\n+        } else {\n+          body = replace1;\n+        }\n+      }\n+      return body;\n+    };\n+\n+    // bullet lists:\n+    // ul li -> \" * \"\n+    processMarkdown('ul li', '<p />* %text%<p />');\n+\n+    // numeric lists:\n+    // ol li -> \" 1. \"\n+    processMarkdown('ol li', '<p />1. %text%<p />');\n+\n+    // headers:\n+    // H1 -> #\n+    // H2 -> ##\n+    // H3 -> ###\n+    // H4 -> ####\n+    // H5 -> #####\n+    // H6 -> ######\n+    if (featureEnabled('h')) {\n+      toProcess = preprocess['h'] || {};\n+      $(':header', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let nodeName = $(this).prop('nodeName') || '0';\n+        if (nodeName && text && text.length > min_text_length_k) {\n+          let x = nodeName.substr(-1);\n+          toProcess[text.toLowerCase()] = `\\n${'#'.repeat(x)} ${text}\\n`; // Intentionally overwrites duplicates\n+        }\n+      });\n+      sortAndPlaceholderize(toProcess);\n+    }\n+\n+    replaced = this.replacer(body, replacer_dict); // Replace initial batch of <div> like placeholders\n+    body = replaced;\n+    replacer_dict = {}; // Reset\n+    count = 0; // Reset\n+\n+    // bold: b -> **text**\n+    processMarkdown('b', ' **%text%** ');\n+\n+    // italics: i -> _text_\n+    processMarkdown('i', ' _%text%_ ');\n+\n+    // links:\n+    // a -> [text](html)\n+    if (featureEnabled('a')) {\n+      toProcess = preprocess['a'] || {};\n+      $('a', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let href = ($(this).prop('href') || '').trim(); // Was attr\n+        /*\n+              var uri_display = self.uriForDisplay(href);\n+              var comment = ' \"' + text + ' via ' + uri_display + '\"';\n+              var re = new RegExp(self.escapeRegExp(text), \"i\");\n+              if (uri.match(re)) {\n+                  comment = ' \"Open ' + uri_display + '\"';\n+              }\n+              */\n+        if (href && text && text.length >= min_text_length_k) {\n+          toProcess[text.toLowerCase()] = self.anchorMarkdownify(text, href); // Comment seemed like too much extra text // Intentionally overwrites duplicates\n+        }\n+      });\n+      sortAndPlaceholderize(toProcess);\n+    }\n+\n+    /* DISABLED (Ace, 16-Jan-2017): Images kinda make a mess, until requested lets not markdownify them:\n+      // images:\n+      // img -> ![alt_text](html)\n+      if (featureEnabled('img')) {\n+          $('img', $html).each(function(index, value) {\n+              var text = ($(this).prop(\"alt\") || \"\").trim(); // Was attr\n+              var href = ($(this).prop(\"src\") || \"\").trim(); // Was attr\n+              // var uri_display = self.uriForDisplay(href);\n+              if (href && text && text.length >= min_text_length_k) {\n+                  toProcess[text.toLowerCase()] = self.anchorMarkdownify(text, href); // Comment seemed like too much extra text // Intentionally overwrites duplicates\n+              }\n+          });\n+          sortAndPlaceholderize(toProcess);\n+      }\n+      */\n+\n+    replaced = this.replacer(body, replacer_dict); // Replace second batch of <span> like placeholders\n+    body = replaced;\n+\n+    // Replace bullets following a CRLF:\n+    replaced = body.replace(/\\s*[\\n\\r]+\\s*[·-]+\\s*/g, '<p />* '); // = [\\u00B7\\u2022]\n+    body = replaced;\n+\n+    // Replace remaining bullets with asterisks:\n+    replaced = body.replace(/[·]/g, '*');\n+    body = replaced;\n+\n+    // ORDER MATTERS FOR THIS NEXT SET:\n+    // (1) Replace <space>CRLF<space> with just CR:\n+    replaced = body.replace(/\\s*[\\n\\r]+\\s*/g, '\\n');\n+    body = replaced;\n+\n+    // (2) Replace 2 or more spaces with just one:\n+    replaced = repeatReplace(body, new RegExp('\\\\s{2,}', 'g'), ' ');\n+    body = replaced;\n+\n+    // (3) Replace paragraph markers with CR+CR:\n+    replaced = body.replace(/\\s*<p \\/>\\s*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // (4) Replace 3 or more CRs with just two:\n+    replaced = repeatReplace(body, new RegExp('\\\\n{3,}', 'g'), '\\n\\n');\n+    body = replaced;\n+\n+    // (5) Trim excess at beginning and end:\n+    replaced = body.trim();\n+    body = replaced;\n+\n+    return body;\n+  }\n+\n+  /**\n+   * Determine luminance of a color so we can augment with darker/lighter background\n+   */\n+  luminance(color) {\n+    let bkColorLight = 'lightGray'; // or white\n+    let bkColorDark = 'darkGray'; // 'gray' is even darker\n+    let bkColorReturn = bkColorLight;\n+\n+    let re = new RegExp('rgb\\\\D+(\\\\d+)\\\\D+(\\\\d+)\\\\D+(\\\\d+)');\n+    let matched = color.match(re, 'i');\n+    if (matched && matched.length > 2) {\n+      // 0 is total string:\n+      let r = matched[1];\n+      let g = matched[2];\n+      let b = matched[3];\n+      // var 1 = matched[4]; // if alpha is provided\n+\n+      let luma = 0.2126 * r + 0.7152 * g + 0.0722 * b; // per ITU-R BT.709\n+\n+      if (luma < 40) {\n+        bkColorReturn = bkColorDark;\n+      } else {\n+        bkColorReturn = bkColorLight;\n+      }\n+    } else {\n+      bkColorReturn = bkColorLight; // RegExp failed, assume dark color\n+    }\n+\n+    return 'inherit'; // Use: bkColorReturn if you want to adjust background based on text perceived brightness\n+  }\n+\n+  /**\n+   * HTML bookend a string\n+   */\n+  bookend(bookend, text, style) {\n+    return (\n+      '<' +\n+      bookend +\n+      (style ? ' style=\"' + style + '\"' : '') +\n+      '>' +\n+      (text || '') +\n+      '</' +\n+      bookend +\n+      '>'\n+    );\n+  }\n+\n+  /**\n+   * Get selected text\n+   * http://stackoverflow.com/questions/5379120/get-the-highlighted-selected-text\n+   */\n+  getSelectedText() {\n+    let text = '';\n+    let activeEl = document.activeElement;\n+    let activeElTagName = activeEl ? activeEl.tagName.toLowerCase() : null;\n+    if (\n+      (activeElTagName == 'textarea' || activeElTagName == 'input') &&\n+      /^(?:text|search|password|tel|url)$/i.test(activeEl.type) &&\n+      typeof activeEl.selectionStart == 'number'\n+    ) {\n+      text = activeEl.value\n+        .slice(activeEl.selectionStart, activeEl.selectionEnd)\n+        .trim();\n+    } else if (document.selection) {\n+      text = document.selection.createRange().text.trim();\n+    } else if (document.getSelection) {\n+      text = document.getSelection().toString().trim();\n+    } else if (window.getSelection) {\n+      text = window.getSelection().toString().trim();\n+    }\n+    return text;\n+  }\n+\n+  /**\n+   * Truncate a string\n+   */\n+  truncate(text, max, add) {\n+    let retn = text || '';\n+    const add_k = this.decodeEntities(add || '');\n+    const max_k = max - add_k.length;\n+\n+    if (text && text.length > max_k) {\n+      retn = text.slice(0, max_k) + add_k;\n+    }\n+    return retn;\n+  }\n+\n+  /***\n+   * Middle-truncate a string\n+   */\n+  midTruncate(text, max, add) {\n+    let retn = text || '';\n+    const add_k = this.decodeEntities(add || '');\n+    const max_k = Math.abs((max || 0) - add_k.length);\n+    const mid_k = (max_k + 0.01) / 2;\n+\n+    if (text && text.length > max_k) {\n+      retn = text.slice(0, mid_k + 1) + add_k + text.slice(-mid_k);\n+    }\n+    return retn;\n+  }\n+\n+  /**\n+   * Load settings\n+   */\n+  loadSettings(popup) {\n+    const self = this;\n+    const setID = self.CHROME_SETTINGS_ID;\n+    chrome.storage.sync.get(setID, function (response) {\n+      if (response?.[setID]) {\n+        // NOTE (Ace, 7-Feb-2017): Might need to store these off the app object:\n+        try {\n+          self.popupView.data.settings = JSON.parse(response[setID]);\n+        } catch (err) {\n+          g2t_log(\n+            'loadSettings: JSON parse failed! Error: ' + JSON.stringify(err)\n+          );\n+        }\n+      }\n+      if (popup) {\n+        popup.init_popup();\n+        self.updateData();\n+      }\n+    });",
    "path": "chrome_manifest_v3/class_app.js",
    "commit_id": "3bbc7b0b5b5abfda366260c45d6f2cecebf28af3",
    "original_commit_id": "ae0a391b6759338b0ec3c3292da07e458841ab71",
    "user": {
      "login": "coderabbitai[bot]",
      "id": 136622811,
      "node_id": "BOT_kgDOCCSy2w",
      "avatar_url": "https://avatars.githubusercontent.com/in/347564?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/coderabbitai%5Bbot%5D",
      "html_url": "https://github.com/apps/coderabbitai",
      "followers_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "_🛠️ Refactor suggestion_\n\n**Remove self. Arrow function preserves this.**\n\nNow whut?\n\n```diff\n   loadSettings(popup) {\n-    const self = this;\n-    const setID = self.CHROME_SETTINGS_ID;\n+    const setID = this.CHROME_SETTINGS_ID;\n     chrome.storage.sync.get(setID, function (response) {\n       if (response?.[setID]) {\n         // NOTE (Ace, 7-Feb-2017): Might need to store these off the app object:\n         try {\n-          self.popupView.data.settings = JSON.parse(response[setID]);\n+          this.popupView.data.settings = JSON.parse(response[setID]);\n         } catch (err) {\n           g2t_log(\n             'loadSettings: JSON parse failed! Error: ' + JSON.stringify(err)\n           );\n         }\n       }\n       if (popup) {\n         popup.init_popup();\n-        self.updateData();\n+        this.updateData();\n       }\n-    });\n+    }.bind(this));\n   }\n```\n\nWait. Regular function. Keep self or convert to arrow:\n```diff\n-    chrome.storage.sync.get(setID, function (response) {\n+    chrome.storage.sync.get(setID, (response) => {\n```\n\n\n> Committable suggestion skipped: line range outside the PR's diff.\n\n<details>\n<summary>🧰 Tools</summary>\n\n<details>\n<summary>🪛 Biome (1.9.4)</summary>\n\n[error] 714-715: Template literals are preferred over string concatenation.\n\nUnsafe fix: Use a template literal.\n\n\n(lint/style/useTemplate)\n\n</details>\n\n</details>\n\n<details>\n<summary>🤖 Prompt for AI Agents</summary>\n\n```\nIn chrome_manifest_v3/class_app.js around lines 704 to 722, the callback to\nchrome.storage.sync.get uses a regular function, so 'this' is not preserved and\n'self' is used to maintain context. To fix this, convert the callback function\nto an arrow function to preserve 'this' and remove the 'self' variable entirely,\nupdating all references from 'self' to 'this' inside the callback.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:lion -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->\n\n✅ Addressed in commit 8198420",
    "created_at": "2025-07-13T21:43:20Z",
    "updated_at": "2025-07-14T04:11:24Z",
    "html_url": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203532570",
    "pull_request_url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532570"
      },
      "html": {
        "href": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203532570"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532570/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 704,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 722,
    "side": "RIGHT",
    "original_position": 722,
    "position": null,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532571",
    "pull_request_review_id": 3014319788,
    "id": 2203532571,
    "node_id": "PRRC_kwDOD1hYKM6DVz0b",
    "diff_hunk": "@@ -0,0 +1,848 @@\n+/** Gmail2Trello Application - ES6 Class Version\n+ */\n+\n+var Gmail2Trello = Gmail2Trello || {}; // Namespace initialization - must be var to guarantee correct scope\n+\n+class App {\n+  constructor() {\n+    this.CHROME_SETTINGS_ID = 'g2t_user_settings';\n+    this.UNIQUE_URI_VAR = 'g2t_filename';\n+\n+    this.model = new Gmail2Trello.Model(this);\n+    this.gmailView = new Gmail2Trello.GmailView(this);\n+    this.popupView = new Gmail2Trello.PopupView(this);\n+\n+    this.bindEvents();\n+  }\n+\n+  bindEvents() {\n+    const self = this;\n+\n+    /*** Data's events binding ***/\n+    this.model.event.addListener('onBeforeAuthorize', function () {\n+      self.popupView.bindData(''); // Intentionally blank\n+      self.popupView.showMessage(self, 'Authorizing...');\n+    });\n+\n+    this.model.event.addListener('onAuthorizeFail', function () {\n+      // self.model.isInitialized = false;\n+      self.popupView.showMessage(\n+        self,\n+        'Trello authorization failed <button id=\"showsignout\">Sign out and try again</button>'\n+      );\n+    });\n+\n+    this.model.event.addListener('onAuthorized', function () {\n+      // g2t_log('onAuthorized');\n+      // g2t_log(\"Status: \" + Trello.authorized().toString());\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+    });\n+\n+    this.model.event.addListener('onBeforeLoadTrello', function () {\n+      self.popupView.showMessage(self, 'Loading Trello data...');\n+    });\n+\n+    this.model.event.addListener('onTrelloDataReady', function () {\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+\n+      self.popupView.bindData(self.model);\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloListSuccess', function () {\n+      self.popupView.updateLists();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloCardsSuccess', function () {\n+      self.popupView.updateCards();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloLabelsSuccess', function () {\n+      self.popupView.updateLabels();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloMembersSuccess', function () {\n+      self.popupView.updateMembers();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener(\n+      'onCardSubmitComplete',\n+      function (target, params) {\n+        self.popupView.displaySubmitCompleteForm();\n+        // If card lists or labels have been updated, reload:\n+        const data_k = params?.data || {};\n+        const emailId = data_k?.emailId || 0;\n+        const boardId_k = data_k?.data?.board?.id || 0;\n+        const listId_k = data_k?.data?.list?.id || 0;\n+        const cardId_k = data_k?.data?.card?.id || 0;\n+        const idBoard_k = data_k?.idBoard || 0;\n+        const idList_k = data_k?.idList || 0;\n+        const idCard_k = data_k?.idCard || 0;\n+        const boardId = boardId_k || idBoard_k || 0;\n+        const listId = listId_k || idList_k || 0;\n+        const cardId = cardId_k || idCard_k || 0;\n+        // NOTE (acoven@2020-05-23): Users expect when creating a brand new card,\n+        // we'll remember that new card ID and then keep defaulting to it for\n+        // subsequent updates to that email. That means we'll have to get the return\n+        // value/url from Trello and dissect that, potentially doing this update\n+        // in that routine:\n+        self.model.emailBoardListCardMapUpdate({\n+          emailId,\n+          boardId,\n+          listId,\n+          cardId,\n+        });\n+\n+        if (boardId) {\n+          self.model.loadTrelloLabels(boardId);\n+          self.model.loadTrelloMembers(boardId);\n+        }\n+        if (listId) {\n+          self.model.loadTrelloCards(listId);\n+        }\n+      }\n+    );\n+\n+    this.model.event.addListener('onAPIFailure', function (target, params) {\n+      self.popupView.displayAPIFailedForm(params);\n+    });\n+\n+    /*** PopupView's events binding ***/\n+\n+    this.popupView.event.addListener('onPopupVisible', function () {\n+      if (!self.model.isInitialized) {\n+        self.popupView.showMessage(self, 'Initializing...');\n+        self.popupView.$popupContent.hide();\n+        self.model.init();\n+      } else {\n+        self.popupView.reset();\n+      }\n+\n+      const trelloUser_k = self?.model?.trello?.user || {};\n+      const fullName = trelloUser_k?.fullName || '';\n+\n+      self.gmailView.parsingData = false;\n+      self.model.gmail = self.gmailView.parseData({ fullName });\n+      self.popupView.bindGmailData(self.model.gmail);\n+      self.popupView.event.fire('periodicChecks');\n+    });\n+\n+    this.popupView.event.addListener('periodicChecks', function () {\n+      setTimeout(function () {\n+        self.popupView.periodicChecks();\n+      }, 3000);\n+    });\n+\n+    this.popupView.event.addListener('onBoardChanged', function (target, params) {\n+      let boardId = params.boardId;\n+      if (boardId !== '_' && boardId !== '' && boardId !== null) {\n+        self.model.loadTrelloLists(boardId);\n+        self.model.loadTrelloLabels(boardId);\n+        self.model.loadTrelloMembers(boardId);\n+      }\n+    });\n+\n+    this.popupView.event.addListener('onListChanged', function (target, params) {\n+      let listId = params.listId;\n+      self.model.loadTrelloCards(listId);\n+    });\n+\n+    this.popupView.event.addListener('onSubmit', function () {\n+      self.model.submit();\n+    });\n+\n+    this.popupView.event.addListener('checkTrelloAuthorized', function () {\n+      self.popupView.showMessage(self, 'Authorizing...');\n+      self.model.checkTrelloAuthorized();\n+    });\n+\n+    this.popupView.event.addListener('onRequestDeauthorizeTrello', function () {\n+      g2t_log('onRequestDeauthorizeTrello');\n+      self.model.deauthorizeTrello();\n+      self.popupView.clearBoard();\n+    });\n+\n+    const eventDetectButton = function () {\n+      if (self.gmailView.preDetect()) {\n+        self.popupView.$toolBar = self.gmailView.$toolBar;\n+        self.popupView.confirmPopup();\n+      }\n+    };\n+\n+    this.popupView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    // GMailView's events:\n+\n+    this.gmailView.event.addListener('onDetected', function () {\n+      self.popupView.$toolBar = self.gmailView.$toolBar;\n+      self.popupView.init();\n+    });\n+\n+    this.gmailView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    chrome.runtime.onMessage.addListener(function (\n+      request,\n+      sender,\n+      sendResponse\n+    ) {\n+      if (request?.message === 'g2t_keyboard_shortcut') {\n+        self.popupView.showPopup();\n+      }\n+    });\n+  }\n+\n+  updateData() {\n+    const self = this;\n+\n+    const fullName = self?.model?.trello?.user?.fullName || '';\n+\n+    self.popupView.bindData(self.model);\n+\n+    self.gmailView.parsingData = false;\n+    self.model.gmail = self.gmailView.parseData({ fullName });\n+    self.popupView.bindGmailData(self.model.gmail);\n+  }\n+\n+  initialize() {\n+    const self = this;\n+\n+    this.model.isInitialized = false;\n+\n+    // g2t_log('App:initialize');\n+\n+    this.gmailView.detect();\n+\n+    service = analytics.getService('gmail-2-trello');\n+\n+    // Get a Tracker using your Google Analytics app Tracking ID.\n+    tracker = service.getTracker('G-0QPEDL7YDL'); // Was: UA-8469046-1 -> UA-42442437-4\n+\n+    // Record an \"appView\" each time the user launches your app or goes to a new\n+    // screen within the app.\n+    tracker.sendAppView('PopupView');\n+  }\n+\n+  /**\n+   * Correctly escape RegExp\n+   */\n+  escapeRegExp(str) {\n+    return str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n+  }\n+\n+  /**\n+   * Utility routine to replace variables\n+   */\n+  replacer(text, dict) {\n+    let self = this;\n+\n+    if (!text || text.length < 1) {\n+      // g2t_log('Require text!');\n+      return '';\n+    } else if (!dict || dict.length < 2) {\n+      g2t_log('replacer: Require dictionary!');\n+      return text;\n+    }\n+\n+    let re, new_text;\n+    const replacify = function () {\n+      g2t_each(dict, function (value, key) {\n+        re = new RegExp(`%${self.escapeRegExp(key)}%`, 'gi');\n+        new_text = text.replace(re, value);\n+        text = new_text;\n+      });\n+    };\n+\n+    let runaway_max = 3;\n+    while (text.indexOf('%') !== -1 && runaway_max-- > 0) {\n+      replacify();\n+    }\n+\n+    return text;\n+  }\n+\n+  /**\n+   * Make displayable URI\n+   */\n+  uriForDisplay(uri) {\n+    const uri_display_trigger_length_k = 20;\n+    const uri_length_max_k = 40;\n+    let uri_display = uri || '';\n+    if (uri_display.length > uri_display_trigger_length_k) {\n+      let re = RegExp('^\\\\w+://([\\\\w./_-]+).*?([\\\\w._-]*)$');\n+      let matched = uri_display.match(re);\n+      if (matched && matched.length > 1) {\n+        const filename_k =\n+          matched[2].length < uri_length_max_k\n+            ? matched[2]\n+            : matched[2].slice(-uri_length_max_k);\n+        let prelude = matched[1].substr(0, uri_length_max_k);\n+        if (matched[1].length > uri_length_max_k) {\n+          prelude += '...';\n+        } else if (filename_k.length > 0) {\n+          prelude += ':';\n+        }\n+\n+        uri_display = prelude + filename_k;\n+      }\n+    }\n+    return uri_display;\n+  }\n+\n+  /**\n+   * Make anchored backlink\n+   */\n+  anchorMarkdownify(text, href, comment) {\n+    let text1 = (text || '').trim();\n+    let text1lc = text1.toLowerCase();\n+    let href1 = (href || '').trim();\n+    let href1lc = href1.toLowerCase();\n+    let comment1 = (comment || '').trim();\n+\n+    let retn = '';\n+\n+    if (text1.length < 1 && href1.length < 1) {\n+      // Intetionally blank\n+    } else if (text1lc === href1lc) {\n+      retn = ` <${href1}> `; // This renders correctly in Trello as a sole URL\n+      // NOTE (Ace, 17-Feb-2017): Turns out Trello doesn't support markdown [] only, so we'll construct a nice displayable text vs url:\n+      // text1 = this.uriForDisplay(text1);\n+    } else if (`mailto:${text1lc}` === href1lc) {\n+      retn = ` <${text1}> `; // This renders correctly in Trello as a mailto: url\n+    } else {\n+      const comment1QuotedSpaced = comment1.length > 0 ? ` \"${comment1}\"` : '';\n+      retn = ` [${text1}](<${href1}>${comment1QuotedSpaced}) `;\n+    }\n+\n+    return retn;\n+  }\n+\n+  /**\n+   * Split an email into name and domain\n+   */\n+  splitEmailDomain(email = '') {\n+    const split = email.split('@');\n+    const name = split[0] || '';\n+    const domain = split[1] || '';\n+    return {\n+      name,\n+      domain,\n+    };\n+  }\n+\n+  /**\n+   * Add trailing char if not empty:\n+   */\n+  addChar(front = '', back = '', addChar = ' ') {\n+    if (front.length > 0) {\n+      if (back.length > 0) {\n+        return `${front}${addChar}${back}`;\n+      } else {\n+        return `${front}${addChar}`;\n+      }\n+    } else if (back.length > 0) {\n+      return `${addChar}${back}`;\n+    } else {\n+      return '';\n+    }\n+  }\n+\n+  /**\n+   * Add trailing space if not empty:\n+   */\n+  addSpace(front = '', back = '') {\n+    return this.addChar(front, back, ' ');\n+  }\n+\n+  /**\n+   * Add trailing CRLF if not empty:\n+   */\n+  addCRLF(front = '', back = '') {\n+    return this.addChar(front, back, '\\n');\n+  }\n+\n+  /**\n+   * Markdownify a text block\n+   */\n+  markdownify($emailBody, features, preprocess) {\n+    if (!$emailBody || $emailBody.length < 1) {\n+      g2t_log('markdownify: Require emailBody!');\n+      return;\n+    }\n+    const self = this;\n+\n+    const min_text_length_k = 4;\n+    const max_replace_attempts_k = 10;\n+    const regexp_k = {\n+      begin: '(^|\\\\s+|<|\\\\[|\\\\(|\\\\b|(?=\\\\W+))',\n+      end: '($|\\\\s+|>|\\\\]|\\\\)|\\\\b|(?=\\\\W+))',\n+    };\n+    const unique_placeholder_k = 'g2t_placeholder:'; // Unique placeholder tag\n+\n+    let count = 0;\n+    let replacer_dict = {};\n+\n+    const featureEnabled = (elementTag = '') =>\n+      features === false ? false : features?.[elementTag] !== false;\n+\n+    let $html = $emailBody || ''; // Was: $emailBody.innerHTML || \"\";\n+    // let body = $emailBody.text() || \"\";\n+    let body = $emailBody.html() || '';\n+\n+    // Different encodings handle CRLF differently, so we'll process the main body as html and convert to text:\n+    // Convert paragraph marker to two returns:\n+    let replaced = body.replace(/\\s*[\\n\\r]*<p[^>]*>\\s*[\\n\\r]*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // Convert br marker to one return:\n+    replaced = body.replace(/\\s*[\\n\\r]*<br[^>]*>\\s*[\\n\\r]*/g, '\\n');\n+    body = replaced;\n+\n+    // Remove all other html markers:\n+    replaced = body.replace(/<[^>]*>/g, '');\n+    body = replaced;\n+\n+    // Decode HTML entities:\n+    replaced = self.decodeEntities(body);\n+    body = replaced;\n+\n+    // Replace hr:\n+    replaced = body.replace(/\\s*-{3,}\\s*/g, '---\\n');\n+    body = replaced;\n+\n+    // Convert crlf x 2 (or more) to paragraph markers:\n+    replaced = body.replace(/(\\s*[\\n\\r]\\s*){2,}/g, '<p />\\n');\n+    body = replaced;\n+\n+    let toProcess = {};\n+\n+    /**\n+     * 5 explicit steps in 3 passes:\n+     * (1) Collect tagged items\n+     * (2) Remove duplicates\n+     * (3) Sort force-lowercase by length\n+     * (4) Replace with placeholder\n+     * (5) Replace placeholders with final text\n+     */\n+    const sortAndPlaceholderize = function (tooProcess) {\n+      if (tooProcess) {\n+        g2t_each(\n+          Object.keys(tooProcess).sort(function (a, b) {\n+            // Go by order of largest to smallest\n+            return b.length - a.length;\n+          }),\n+          function (value) {\n+            const replace = tooProcess[value];\n+            const swap = `${unique_placeholder_k}${(count++).toString()}`;\n+            const re = new RegExp(\n+              regexp_k.begin + self.escapeRegExp(value) + regexp_k.end,\n+              'gi'\n+            );\n+            const replaced = body.replace(re, `%${swap}%`); // Replace occurance with placeholder\n+            if (body !== replaced) {\n+              body = replaced;\n+              replacer_dict[swap] = replace;\n+            }\n+          }\n+        );\n+      }\n+    };\n+    const processMarkdown = function (elementTag, replaceText) {\n+      if (elementTag && replaceText && featureEnabled(elementTag)) {\n+        toProcess = preprocess[elementTag] || {};\n+        $(elementTag, $html).each(function (index, value) {\n+          let text = ($(this).text() || '').trim();\n+          if (text && text.length > min_text_length_k) {\n+            let replace = self.replacer(replaceText, { text: text });\n+            toProcess[text.toLowerCase()] = replace; // Intentionally overwrites duplicates\n+          }\n+        });\n+        sortAndPlaceholderize(toProcess);\n+      }\n+    };\n+    /**\n+     * Repeat replace for max attempts or when done, whatever comes first\n+     */\n+    const repeatReplace = function (body, inRegexp, replaceWith) {\n+      let replace1 = '';\n+      for (let iter = max_replace_attempts_k; iter > 0; iter--) {\n+        replace1 = body.replace(inRegexp, replaceWith);\n+        if (body === replace1) {\n+          iter = 0; // All done\n+        } else {\n+          body = replace1;\n+        }\n+      }\n+      return body;\n+    };\n+\n+    // bullet lists:\n+    // ul li -> \" * \"\n+    processMarkdown('ul li', '<p />* %text%<p />');\n+\n+    // numeric lists:\n+    // ol li -> \" 1. \"\n+    processMarkdown('ol li', '<p />1. %text%<p />');\n+\n+    // headers:\n+    // H1 -> #\n+    // H2 -> ##\n+    // H3 -> ###\n+    // H4 -> ####\n+    // H5 -> #####\n+    // H6 -> ######\n+    if (featureEnabled('h')) {\n+      toProcess = preprocess['h'] || {};\n+      $(':header', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let nodeName = $(this).prop('nodeName') || '0';\n+        if (nodeName && text && text.length > min_text_length_k) {\n+          let x = nodeName.substr(-1);\n+          toProcess[text.toLowerCase()] = `\\n${'#'.repeat(x)} ${text}\\n`; // Intentionally overwrites duplicates\n+        }\n+      });\n+      sortAndPlaceholderize(toProcess);\n+    }\n+\n+    replaced = this.replacer(body, replacer_dict); // Replace initial batch of <div> like placeholders\n+    body = replaced;\n+    replacer_dict = {}; // Reset\n+    count = 0; // Reset\n+\n+    // bold: b -> **text**\n+    processMarkdown('b', ' **%text%** ');\n+\n+    // italics: i -> _text_\n+    processMarkdown('i', ' _%text%_ ');\n+\n+    // links:\n+    // a -> [text](html)\n+    if (featureEnabled('a')) {\n+      toProcess = preprocess['a'] || {};\n+      $('a', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let href = ($(this).prop('href') || '').trim(); // Was attr\n+        /*\n+              var uri_display = self.uriForDisplay(href);\n+              var comment = ' \"' + text + ' via ' + uri_display + '\"';\n+              var re = new RegExp(self.escapeRegExp(text), \"i\");\n+              if (uri.match(re)) {\n+                  comment = ' \"Open ' + uri_display + '\"';\n+              }\n+              */\n+        if (href && text && text.length >= min_text_length_k) {\n+          toProcess[text.toLowerCase()] = self.anchorMarkdownify(text, href); // Comment seemed like too much extra text // Intentionally overwrites duplicates\n+        }\n+      });\n+      sortAndPlaceholderize(toProcess);\n+    }\n+\n+    /* DISABLED (Ace, 16-Jan-2017): Images kinda make a mess, until requested lets not markdownify them:\n+      // images:\n+      // img -> ![alt_text](html)\n+      if (featureEnabled('img')) {\n+          $('img', $html).each(function(index, value) {\n+              var text = ($(this).prop(\"alt\") || \"\").trim(); // Was attr\n+              var href = ($(this).prop(\"src\") || \"\").trim(); // Was attr\n+              // var uri_display = self.uriForDisplay(href);\n+              if (href && text && text.length >= min_text_length_k) {\n+                  toProcess[text.toLowerCase()] = self.anchorMarkdownify(text, href); // Comment seemed like too much extra text // Intentionally overwrites duplicates\n+              }\n+          });\n+          sortAndPlaceholderize(toProcess);\n+      }\n+      */\n+\n+    replaced = this.replacer(body, replacer_dict); // Replace second batch of <span> like placeholders\n+    body = replaced;\n+\n+    // Replace bullets following a CRLF:\n+    replaced = body.replace(/\\s*[\\n\\r]+\\s*[·-]+\\s*/g, '<p />* '); // = [\\u00B7\\u2022]\n+    body = replaced;\n+\n+    // Replace remaining bullets with asterisks:\n+    replaced = body.replace(/[·]/g, '*');\n+    body = replaced;\n+\n+    // ORDER MATTERS FOR THIS NEXT SET:\n+    // (1) Replace <space>CRLF<space> with just CR:\n+    replaced = body.replace(/\\s*[\\n\\r]+\\s*/g, '\\n');\n+    body = replaced;\n+\n+    // (2) Replace 2 or more spaces with just one:\n+    replaced = repeatReplace(body, new RegExp('\\\\s{2,}', 'g'), ' ');\n+    body = replaced;\n+\n+    // (3) Replace paragraph markers with CR+CR:\n+    replaced = body.replace(/\\s*<p \\/>\\s*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // (4) Replace 3 or more CRs with just two:\n+    replaced = repeatReplace(body, new RegExp('\\\\n{3,}', 'g'), '\\n\\n');\n+    body = replaced;\n+\n+    // (5) Trim excess at beginning and end:\n+    replaced = body.trim();\n+    body = replaced;\n+\n+    return body;\n+  }\n+\n+  /**\n+   * Determine luminance of a color so we can augment with darker/lighter background\n+   */\n+  luminance(color) {\n+    let bkColorLight = 'lightGray'; // or white\n+    let bkColorDark = 'darkGray'; // 'gray' is even darker\n+    let bkColorReturn = bkColorLight;\n+\n+    let re = new RegExp('rgb\\\\D+(\\\\d+)\\\\D+(\\\\d+)\\\\D+(\\\\d+)');\n+    let matched = color.match(re, 'i');\n+    if (matched && matched.length > 2) {\n+      // 0 is total string:\n+      let r = matched[1];\n+      let g = matched[2];\n+      let b = matched[3];\n+      // var 1 = matched[4]; // if alpha is provided\n+\n+      let luma = 0.2126 * r + 0.7152 * g + 0.0722 * b; // per ITU-R BT.709\n+\n+      if (luma < 40) {\n+        bkColorReturn = bkColorDark;\n+      } else {\n+        bkColorReturn = bkColorLight;\n+      }\n+    } else {\n+      bkColorReturn = bkColorLight; // RegExp failed, assume dark color\n+    }\n+\n+    return 'inherit'; // Use: bkColorReturn if you want to adjust background based on text perceived brightness\n+  }\n+\n+  /**\n+   * HTML bookend a string\n+   */\n+  bookend(bookend, text, style) {\n+    return (\n+      '<' +\n+      bookend +\n+      (style ? ' style=\"' + style + '\"' : '') +\n+      '>' +\n+      (text || '') +\n+      '</' +\n+      bookend +\n+      '>'\n+    );\n+  }\n+\n+  /**\n+   * Get selected text\n+   * http://stackoverflow.com/questions/5379120/get-the-highlighted-selected-text\n+   */\n+  getSelectedText() {\n+    let text = '';\n+    let activeEl = document.activeElement;\n+    let activeElTagName = activeEl ? activeEl.tagName.toLowerCase() : null;\n+    if (\n+      (activeElTagName == 'textarea' || activeElTagName == 'input') &&\n+      /^(?:text|search|password|tel|url)$/i.test(activeEl.type) &&\n+      typeof activeEl.selectionStart == 'number'\n+    ) {\n+      text = activeEl.value\n+        .slice(activeEl.selectionStart, activeEl.selectionEnd)\n+        .trim();\n+    } else if (document.selection) {\n+      text = document.selection.createRange().text.trim();\n+    } else if (document.getSelection) {\n+      text = document.getSelection().toString().trim();\n+    } else if (window.getSelection) {\n+      text = window.getSelection().toString().trim();\n+    }\n+    return text;\n+  }\n+\n+  /**\n+   * Truncate a string\n+   */\n+  truncate(text, max, add) {\n+    let retn = text || '';\n+    const add_k = this.decodeEntities(add || '');\n+    const max_k = max - add_k.length;\n+\n+    if (text && text.length > max_k) {\n+      retn = text.slice(0, max_k) + add_k;\n+    }\n+    return retn;\n+  }\n+\n+  /***\n+   * Middle-truncate a string\n+   */\n+  midTruncate(text, max, add) {\n+    let retn = text || '';\n+    const add_k = this.decodeEntities(add || '');\n+    const max_k = Math.abs((max || 0) - add_k.length);\n+    const mid_k = (max_k + 0.01) / 2;\n+\n+    if (text && text.length > max_k) {\n+      retn = text.slice(0, mid_k + 1) + add_k + text.slice(-mid_k);\n+    }\n+    return retn;\n+  }\n+\n+  /**\n+   * Load settings\n+   */\n+  loadSettings(popup) {\n+    const self = this;\n+    const setID = self.CHROME_SETTINGS_ID;\n+    chrome.storage.sync.get(setID, function (response) {\n+      if (response?.[setID]) {\n+        // NOTE (Ace, 7-Feb-2017): Might need to store these off the app object:\n+        try {\n+          self.popupView.data.settings = JSON.parse(response[setID]);\n+        } catch (err) {\n+          g2t_log(\n+            'loadSettings: JSON parse failed! Error: ' + JSON.stringify(err)\n+          );\n+        }\n+      }\n+      if (popup) {\n+        popup.init_popup();\n+        self.updateData();\n+      }\n+    });\n+  }\n+\n+  /**\n+   * Save settings\n+   */\n+  saveSettings() {\n+    const self = this;\n+    const setID = self.CHROME_SETTINGS_ID;\n+    let settings = Object.assign({}, self.popupView.data.settings);\n+\n+    // Delete large, potentially needing secure, data bits:\n+    settings.description = '';\n+    settings.title = '';\n+    settings.attachments = [];\n+    settings.images = [];\n+    delete settings.description;\n+    delete settings.title;\n+    delete settings.attachments;\n+    delete settings.images;",
    "path": "chrome_manifest_v3/class_app.js",
    "commit_id": "3bbc7b0b5b5abfda366260c45d6f2cecebf28af3",
    "original_commit_id": "ae0a391b6759338b0ec3c3292da07e458841ab71",
    "user": {
      "login": "coderabbitai[bot]",
      "id": 136622811,
      "node_id": "BOT_kgDOCCSy2w",
      "avatar_url": "https://avatars.githubusercontent.com/in/347564?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/coderabbitai%5Bbot%5D",
      "html_url": "https://github.com/apps/coderabbitai",
      "followers_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "_🧹 Nitpick (assertive)_\n\n**Avoid delete. Use undefined.**\n\nPerformance.\n\n```diff\n     // Delete large, potentially needing secure, data bits:\n     settings.description = '';\n     settings.title = '';\n     settings.attachments = [];\n     settings.images = [];\n-    delete settings.description;\n-    delete settings.title;\n-    delete settings.attachments;\n-    delete settings.images;\n+    settings.description = undefined;\n+    settings.title = undefined;\n+    settings.attachments = undefined;\n+    settings.images = undefined;\n```\n\nWhat now? Just don't set them:\n```diff\n-    let settings = Object.assign({}, self.popupView.data.settings);\n-\n-    // Delete large, potentially needing secure, data bits:\n-    settings.description = '';\n-    settings.title = '';\n-    settings.attachments = [];\n-    settings.images = [];\n-    delete settings.description;\n-    delete settings.title;\n-    delete settings.attachments;\n-    delete settings.images;\n+    const { description, title, attachments, images, ...settings } = this.popupView.data.settings;\n```\n\n\n> Committable suggestion skipped: line range outside the PR's diff.\n\n<details>\n<summary>🧰 Tools</summary>\n\n<details>\n<summary>🪛 Biome (1.9.4)</summary>\n\n[error] 738-738: Avoid the delete operator which can impact performance.\n\nUnsafe fix: Use an undefined assignment instead.\n\n\n(lint/performance/noDelete)\n\n---\n\n[error] 739-739: Avoid the delete operator which can impact performance.\n\nUnsafe fix: Use an undefined assignment instead.\n\n\n(lint/performance/noDelete)\n\n---\n\n[error] 740-740: Avoid the delete operator which can impact performance.\n\nUnsafe fix: Use an undefined assignment instead.\n\n\n(lint/performance/noDelete)\n\n---\n\n[error] 741-741: Avoid the delete operator which can impact performance.\n\nUnsafe fix: Use an undefined assignment instead.\n\n\n(lint/performance/noDelete)\n\n</details>\n\n</details>\n\n<details>\n<summary>🤖 Prompt for AI Agents</summary>\n\n```\nIn chrome_manifest_v3/class_app.js around lines 734 to 741, avoid using the\ndelete operator on object properties due to performance concerns. Instead of\ndeleting settings.description, settings.title, settings.attachments, and\nsettings.images after setting them to empty values, simply do not set these\nproperties at all if they are not needed. Remove both the initial assignments\nand the delete statements to avoid unnecessary operations.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:lion -->\n\n<!-- This is an auto-generated reply by CodeRabbit -->\n\n✅ Addressed in commits dfe3bc8 to 1e307f6\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "created_at": "2025-07-13T21:43:20Z",
    "updated_at": "2025-07-14T04:57:48Z",
    "html_url": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203532571",
    "pull_request_url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532571"
      },
      "html": {
        "href": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203532571"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532571/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 734,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 741,
    "side": "RIGHT",
    "original_position": 741,
    "position": null,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532572",
    "pull_request_review_id": 3014319788,
    "id": 2203532572,
    "node_id": "PRRC_kwDOD1hYKM6DVz0c",
    "diff_hunk": "@@ -0,0 +1,848 @@\n+/** Gmail2Trello Application - ES6 Class Version\n+ */\n+\n+var Gmail2Trello = Gmail2Trello || {}; // Namespace initialization - must be var to guarantee correct scope\n+\n+class App {\n+  constructor() {\n+    this.CHROME_SETTINGS_ID = 'g2t_user_settings';\n+    this.UNIQUE_URI_VAR = 'g2t_filename';\n+\n+    this.model = new Gmail2Trello.Model(this);\n+    this.gmailView = new Gmail2Trello.GmailView(this);\n+    this.popupView = new Gmail2Trello.PopupView(this);\n+\n+    this.bindEvents();\n+  }\n+\n+  bindEvents() {\n+    const self = this;\n+\n+    /*** Data's events binding ***/\n+    this.model.event.addListener('onBeforeAuthorize', function () {\n+      self.popupView.bindData(''); // Intentionally blank\n+      self.popupView.showMessage(self, 'Authorizing...');\n+    });\n+\n+    this.model.event.addListener('onAuthorizeFail', function () {\n+      // self.model.isInitialized = false;\n+      self.popupView.showMessage(\n+        self,\n+        'Trello authorization failed <button id=\"showsignout\">Sign out and try again</button>'\n+      );\n+    });\n+\n+    this.model.event.addListener('onAuthorized', function () {\n+      // g2t_log('onAuthorized');\n+      // g2t_log(\"Status: \" + Trello.authorized().toString());\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+    });\n+\n+    this.model.event.addListener('onBeforeLoadTrello', function () {\n+      self.popupView.showMessage(self, 'Loading Trello data...');\n+    });\n+\n+    this.model.event.addListener('onTrelloDataReady', function () {\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+\n+      self.popupView.bindData(self.model);\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloListSuccess', function () {\n+      self.popupView.updateLists();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloCardsSuccess', function () {\n+      self.popupView.updateCards();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloLabelsSuccess', function () {\n+      self.popupView.updateLabels();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloMembersSuccess', function () {\n+      self.popupView.updateMembers();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener(\n+      'onCardSubmitComplete',\n+      function (target, params) {\n+        self.popupView.displaySubmitCompleteForm();\n+        // If card lists or labels have been updated, reload:\n+        const data_k = params?.data || {};\n+        const emailId = data_k?.emailId || 0;\n+        const boardId_k = data_k?.data?.board?.id || 0;\n+        const listId_k = data_k?.data?.list?.id || 0;\n+        const cardId_k = data_k?.data?.card?.id || 0;\n+        const idBoard_k = data_k?.idBoard || 0;\n+        const idList_k = data_k?.idList || 0;\n+        const idCard_k = data_k?.idCard || 0;\n+        const boardId = boardId_k || idBoard_k || 0;\n+        const listId = listId_k || idList_k || 0;\n+        const cardId = cardId_k || idCard_k || 0;\n+        // NOTE (acoven@2020-05-23): Users expect when creating a brand new card,\n+        // we'll remember that new card ID and then keep defaulting to it for\n+        // subsequent updates to that email. That means we'll have to get the return\n+        // value/url from Trello and dissect that, potentially doing this update\n+        // in that routine:\n+        self.model.emailBoardListCardMapUpdate({\n+          emailId,\n+          boardId,\n+          listId,\n+          cardId,\n+        });\n+\n+        if (boardId) {\n+          self.model.loadTrelloLabels(boardId);\n+          self.model.loadTrelloMembers(boardId);\n+        }\n+        if (listId) {\n+          self.model.loadTrelloCards(listId);\n+        }\n+      }\n+    );\n+\n+    this.model.event.addListener('onAPIFailure', function (target, params) {\n+      self.popupView.displayAPIFailedForm(params);\n+    });\n+\n+    /*** PopupView's events binding ***/\n+\n+    this.popupView.event.addListener('onPopupVisible', function () {\n+      if (!self.model.isInitialized) {\n+        self.popupView.showMessage(self, 'Initializing...');\n+        self.popupView.$popupContent.hide();\n+        self.model.init();\n+      } else {\n+        self.popupView.reset();\n+      }\n+\n+      const trelloUser_k = self?.model?.trello?.user || {};\n+      const fullName = trelloUser_k?.fullName || '';\n+\n+      self.gmailView.parsingData = false;\n+      self.model.gmail = self.gmailView.parseData({ fullName });\n+      self.popupView.bindGmailData(self.model.gmail);\n+      self.popupView.event.fire('periodicChecks');\n+    });\n+\n+    this.popupView.event.addListener('periodicChecks', function () {\n+      setTimeout(function () {\n+        self.popupView.periodicChecks();\n+      }, 3000);\n+    });\n+\n+    this.popupView.event.addListener('onBoardChanged', function (target, params) {\n+      let boardId = params.boardId;\n+      if (boardId !== '_' && boardId !== '' && boardId !== null) {\n+        self.model.loadTrelloLists(boardId);\n+        self.model.loadTrelloLabels(boardId);\n+        self.model.loadTrelloMembers(boardId);\n+      }\n+    });\n+\n+    this.popupView.event.addListener('onListChanged', function (target, params) {\n+      let listId = params.listId;\n+      self.model.loadTrelloCards(listId);\n+    });\n+\n+    this.popupView.event.addListener('onSubmit', function () {\n+      self.model.submit();\n+    });\n+\n+    this.popupView.event.addListener('checkTrelloAuthorized', function () {\n+      self.popupView.showMessage(self, 'Authorizing...');\n+      self.model.checkTrelloAuthorized();\n+    });\n+\n+    this.popupView.event.addListener('onRequestDeauthorizeTrello', function () {\n+      g2t_log('onRequestDeauthorizeTrello');\n+      self.model.deauthorizeTrello();\n+      self.popupView.clearBoard();\n+    });\n+\n+    const eventDetectButton = function () {\n+      if (self.gmailView.preDetect()) {\n+        self.popupView.$toolBar = self.gmailView.$toolBar;\n+        self.popupView.confirmPopup();\n+      }\n+    };\n+\n+    this.popupView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    // GMailView's events:\n+\n+    this.gmailView.event.addListener('onDetected', function () {\n+      self.popupView.$toolBar = self.gmailView.$toolBar;\n+      self.popupView.init();\n+    });\n+\n+    this.gmailView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    chrome.runtime.onMessage.addListener(function (\n+      request,\n+      sender,\n+      sendResponse\n+    ) {\n+      if (request?.message === 'g2t_keyboard_shortcut') {\n+        self.popupView.showPopup();\n+      }\n+    });\n+  }\n+\n+  updateData() {\n+    const self = this;\n+\n+    const fullName = self?.model?.trello?.user?.fullName || '';\n+\n+    self.popupView.bindData(self.model);\n+\n+    self.gmailView.parsingData = false;\n+    self.model.gmail = self.gmailView.parseData({ fullName });\n+    self.popupView.bindGmailData(self.model.gmail);\n+  }\n+\n+  initialize() {\n+    const self = this;\n+\n+    this.model.isInitialized = false;\n+\n+    // g2t_log('App:initialize');\n+\n+    this.gmailView.detect();\n+\n+    service = analytics.getService('gmail-2-trello');\n+\n+    // Get a Tracker using your Google Analytics app Tracking ID.\n+    tracker = service.getTracker('G-0QPEDL7YDL'); // Was: UA-8469046-1 -> UA-42442437-4\n+\n+    // Record an \"appView\" each time the user launches your app or goes to a new\n+    // screen within the app.\n+    tracker.sendAppView('PopupView');\n+  }\n+\n+  /**\n+   * Correctly escape RegExp\n+   */\n+  escapeRegExp(str) {\n+    return str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n+  }\n+\n+  /**\n+   * Utility routine to replace variables\n+   */\n+  replacer(text, dict) {\n+    let self = this;\n+\n+    if (!text || text.length < 1) {\n+      // g2t_log('Require text!');\n+      return '';\n+    } else if (!dict || dict.length < 2) {\n+      g2t_log('replacer: Require dictionary!');\n+      return text;\n+    }\n+\n+    let re, new_text;\n+    const replacify = function () {\n+      g2t_each(dict, function (value, key) {\n+        re = new RegExp(`%${self.escapeRegExp(key)}%`, 'gi');\n+        new_text = text.replace(re, value);\n+        text = new_text;\n+      });\n+    };\n+\n+    let runaway_max = 3;\n+    while (text.indexOf('%') !== -1 && runaway_max-- > 0) {\n+      replacify();\n+    }\n+\n+    return text;\n+  }\n+\n+  /**\n+   * Make displayable URI\n+   */\n+  uriForDisplay(uri) {\n+    const uri_display_trigger_length_k = 20;\n+    const uri_length_max_k = 40;\n+    let uri_display = uri || '';\n+    if (uri_display.length > uri_display_trigger_length_k) {\n+      let re = RegExp('^\\\\w+://([\\\\w./_-]+).*?([\\\\w._-]*)$');\n+      let matched = uri_display.match(re);\n+      if (matched && matched.length > 1) {\n+        const filename_k =\n+          matched[2].length < uri_length_max_k\n+            ? matched[2]\n+            : matched[2].slice(-uri_length_max_k);\n+        let prelude = matched[1].substr(0, uri_length_max_k);\n+        if (matched[1].length > uri_length_max_k) {\n+          prelude += '...';\n+        } else if (filename_k.length > 0) {\n+          prelude += ':';\n+        }\n+\n+        uri_display = prelude + filename_k;\n+      }\n+    }\n+    return uri_display;\n+  }\n+\n+  /**\n+   * Make anchored backlink\n+   */\n+  anchorMarkdownify(text, href, comment) {\n+    let text1 = (text || '').trim();\n+    let text1lc = text1.toLowerCase();\n+    let href1 = (href || '').trim();\n+    let href1lc = href1.toLowerCase();\n+    let comment1 = (comment || '').trim();\n+\n+    let retn = '';\n+\n+    if (text1.length < 1 && href1.length < 1) {\n+      // Intetionally blank\n+    } else if (text1lc === href1lc) {\n+      retn = ` <${href1}> `; // This renders correctly in Trello as a sole URL\n+      // NOTE (Ace, 17-Feb-2017): Turns out Trello doesn't support markdown [] only, so we'll construct a nice displayable text vs url:\n+      // text1 = this.uriForDisplay(text1);\n+    } else if (`mailto:${text1lc}` === href1lc) {\n+      retn = ` <${text1}> `; // This renders correctly in Trello as a mailto: url\n+    } else {\n+      const comment1QuotedSpaced = comment1.length > 0 ? ` \"${comment1}\"` : '';\n+      retn = ` [${text1}](<${href1}>${comment1QuotedSpaced}) `;\n+    }\n+\n+    return retn;\n+  }\n+\n+  /**\n+   * Split an email into name and domain\n+   */\n+  splitEmailDomain(email = '') {\n+    const split = email.split('@');\n+    const name = split[0] || '';\n+    const domain = split[1] || '';\n+    return {\n+      name,\n+      domain,\n+    };\n+  }\n+\n+  /**\n+   * Add trailing char if not empty:\n+   */\n+  addChar(front = '', back = '', addChar = ' ') {\n+    if (front.length > 0) {\n+      if (back.length > 0) {\n+        return `${front}${addChar}${back}`;\n+      } else {\n+        return `${front}${addChar}`;\n+      }\n+    } else if (back.length > 0) {\n+      return `${addChar}${back}`;\n+    } else {\n+      return '';\n+    }\n+  }\n+\n+  /**\n+   * Add trailing space if not empty:\n+   */\n+  addSpace(front = '', back = '') {\n+    return this.addChar(front, back, ' ');\n+  }\n+\n+  /**\n+   * Add trailing CRLF if not empty:\n+   */\n+  addCRLF(front = '', back = '') {\n+    return this.addChar(front, back, '\\n');\n+  }\n+\n+  /**\n+   * Markdownify a text block\n+   */\n+  markdownify($emailBody, features, preprocess) {\n+    if (!$emailBody || $emailBody.length < 1) {\n+      g2t_log('markdownify: Require emailBody!');\n+      return;\n+    }\n+    const self = this;\n+\n+    const min_text_length_k = 4;\n+    const max_replace_attempts_k = 10;\n+    const regexp_k = {\n+      begin: '(^|\\\\s+|<|\\\\[|\\\\(|\\\\b|(?=\\\\W+))',\n+      end: '($|\\\\s+|>|\\\\]|\\\\)|\\\\b|(?=\\\\W+))',\n+    };\n+    const unique_placeholder_k = 'g2t_placeholder:'; // Unique placeholder tag\n+\n+    let count = 0;\n+    let replacer_dict = {};\n+\n+    const featureEnabled = (elementTag = '') =>\n+      features === false ? false : features?.[elementTag] !== false;\n+\n+    let $html = $emailBody || ''; // Was: $emailBody.innerHTML || \"\";\n+    // let body = $emailBody.text() || \"\";\n+    let body = $emailBody.html() || '';\n+\n+    // Different encodings handle CRLF differently, so we'll process the main body as html and convert to text:\n+    // Convert paragraph marker to two returns:\n+    let replaced = body.replace(/\\s*[\\n\\r]*<p[^>]*>\\s*[\\n\\r]*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // Convert br marker to one return:\n+    replaced = body.replace(/\\s*[\\n\\r]*<br[^>]*>\\s*[\\n\\r]*/g, '\\n');\n+    body = replaced;\n+\n+    // Remove all other html markers:\n+    replaced = body.replace(/<[^>]*>/g, '');\n+    body = replaced;\n+\n+    // Decode HTML entities:\n+    replaced = self.decodeEntities(body);\n+    body = replaced;\n+\n+    // Replace hr:\n+    replaced = body.replace(/\\s*-{3,}\\s*/g, '---\\n');\n+    body = replaced;\n+\n+    // Convert crlf x 2 (or more) to paragraph markers:\n+    replaced = body.replace(/(\\s*[\\n\\r]\\s*){2,}/g, '<p />\\n');\n+    body = replaced;\n+\n+    let toProcess = {};\n+\n+    /**\n+     * 5 explicit steps in 3 passes:\n+     * (1) Collect tagged items\n+     * (2) Remove duplicates\n+     * (3) Sort force-lowercase by length\n+     * (4) Replace with placeholder\n+     * (5) Replace placeholders with final text\n+     */\n+    const sortAndPlaceholderize = function (tooProcess) {\n+      if (tooProcess) {\n+        g2t_each(\n+          Object.keys(tooProcess).sort(function (a, b) {\n+            // Go by order of largest to smallest\n+            return b.length - a.length;\n+          }),\n+          function (value) {\n+            const replace = tooProcess[value];\n+            const swap = `${unique_placeholder_k}${(count++).toString()}`;\n+            const re = new RegExp(\n+              regexp_k.begin + self.escapeRegExp(value) + regexp_k.end,\n+              'gi'\n+            );\n+            const replaced = body.replace(re, `%${swap}%`); // Replace occurance with placeholder\n+            if (body !== replaced) {\n+              body = replaced;\n+              replacer_dict[swap] = replace;\n+            }\n+          }\n+        );\n+      }\n+    };\n+    const processMarkdown = function (elementTag, replaceText) {\n+      if (elementTag && replaceText && featureEnabled(elementTag)) {\n+        toProcess = preprocess[elementTag] || {};\n+        $(elementTag, $html).each(function (index, value) {\n+          let text = ($(this).text() || '').trim();\n+          if (text && text.length > min_text_length_k) {\n+            let replace = self.replacer(replaceText, { text: text });\n+            toProcess[text.toLowerCase()] = replace; // Intentionally overwrites duplicates\n+          }\n+        });\n+        sortAndPlaceholderize(toProcess);\n+      }\n+    };\n+    /**\n+     * Repeat replace for max attempts or when done, whatever comes first\n+     */\n+    const repeatReplace = function (body, inRegexp, replaceWith) {\n+      let replace1 = '';\n+      for (let iter = max_replace_attempts_k; iter > 0; iter--) {\n+        replace1 = body.replace(inRegexp, replaceWith);\n+        if (body === replace1) {\n+          iter = 0; // All done\n+        } else {\n+          body = replace1;\n+        }\n+      }\n+      return body;\n+    };\n+\n+    // bullet lists:\n+    // ul li -> \" * \"\n+    processMarkdown('ul li', '<p />* %text%<p />');\n+\n+    // numeric lists:\n+    // ol li -> \" 1. \"\n+    processMarkdown('ol li', '<p />1. %text%<p />');\n+\n+    // headers:\n+    // H1 -> #\n+    // H2 -> ##\n+    // H3 -> ###\n+    // H4 -> ####\n+    // H5 -> #####\n+    // H6 -> ######\n+    if (featureEnabled('h')) {\n+      toProcess = preprocess['h'] || {};\n+      $(':header', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let nodeName = $(this).prop('nodeName') || '0';\n+        if (nodeName && text && text.length > min_text_length_k) {\n+          let x = nodeName.substr(-1);\n+          toProcess[text.toLowerCase()] = `\\n${'#'.repeat(x)} ${text}\\n`; // Intentionally overwrites duplicates\n+        }\n+      });\n+      sortAndPlaceholderize(toProcess);\n+    }\n+\n+    replaced = this.replacer(body, replacer_dict); // Replace initial batch of <div> like placeholders\n+    body = replaced;\n+    replacer_dict = {}; // Reset\n+    count = 0; // Reset\n+\n+    // bold: b -> **text**\n+    processMarkdown('b', ' **%text%** ');\n+\n+    // italics: i -> _text_\n+    processMarkdown('i', ' _%text%_ ');\n+\n+    // links:\n+    // a -> [text](html)\n+    if (featureEnabled('a')) {\n+      toProcess = preprocess['a'] || {};\n+      $('a', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let href = ($(this).prop('href') || '').trim(); // Was attr\n+        /*\n+              var uri_display = self.uriForDisplay(href);\n+              var comment = ' \"' + text + ' via ' + uri_display + '\"';\n+              var re = new RegExp(self.escapeRegExp(text), \"i\");\n+              if (uri.match(re)) {\n+                  comment = ' \"Open ' + uri_display + '\"';\n+              }\n+              */\n+        if (href && text && text.length >= min_text_length_k) {\n+          toProcess[text.toLowerCase()] = self.anchorMarkdownify(text, href); // Comment seemed like too much extra text // Intentionally overwrites duplicates\n+        }\n+      });\n+      sortAndPlaceholderize(toProcess);\n+    }\n+\n+    /* DISABLED (Ace, 16-Jan-2017): Images kinda make a mess, until requested lets not markdownify them:\n+      // images:\n+      // img -> ![alt_text](html)\n+      if (featureEnabled('img')) {\n+          $('img', $html).each(function(index, value) {\n+              var text = ($(this).prop(\"alt\") || \"\").trim(); // Was attr\n+              var href = ($(this).prop(\"src\") || \"\").trim(); // Was attr\n+              // var uri_display = self.uriForDisplay(href);\n+              if (href && text && text.length >= min_text_length_k) {\n+                  toProcess[text.toLowerCase()] = self.anchorMarkdownify(text, href); // Comment seemed like too much extra text // Intentionally overwrites duplicates\n+              }\n+          });\n+          sortAndPlaceholderize(toProcess);\n+      }\n+      */\n+\n+    replaced = this.replacer(body, replacer_dict); // Replace second batch of <span> like placeholders\n+    body = replaced;\n+\n+    // Replace bullets following a CRLF:\n+    replaced = body.replace(/\\s*[\\n\\r]+\\s*[·-]+\\s*/g, '<p />* '); // = [\\u00B7\\u2022]\n+    body = replaced;\n+\n+    // Replace remaining bullets with asterisks:\n+    replaced = body.replace(/[·]/g, '*');\n+    body = replaced;\n+\n+    // ORDER MATTERS FOR THIS NEXT SET:\n+    // (1) Replace <space>CRLF<space> with just CR:\n+    replaced = body.replace(/\\s*[\\n\\r]+\\s*/g, '\\n');\n+    body = replaced;\n+\n+    // (2) Replace 2 or more spaces with just one:\n+    replaced = repeatReplace(body, new RegExp('\\\\s{2,}', 'g'), ' ');\n+    body = replaced;\n+\n+    // (3) Replace paragraph markers with CR+CR:\n+    replaced = body.replace(/\\s*<p \\/>\\s*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // (4) Replace 3 or more CRs with just two:\n+    replaced = repeatReplace(body, new RegExp('\\\\n{3,}', 'g'), '\\n\\n');\n+    body = replaced;\n+\n+    // (5) Trim excess at beginning and end:\n+    replaced = body.trim();\n+    body = replaced;\n+\n+    return body;\n+  }\n+\n+  /**\n+   * Determine luminance of a color so we can augment with darker/lighter background\n+   */\n+  luminance(color) {\n+    let bkColorLight = 'lightGray'; // or white\n+    let bkColorDark = 'darkGray'; // 'gray' is even darker\n+    let bkColorReturn = bkColorLight;\n+\n+    let re = new RegExp('rgb\\\\D+(\\\\d+)\\\\D+(\\\\d+)\\\\D+(\\\\d+)');\n+    let matched = color.match(re, 'i');\n+    if (matched && matched.length > 2) {\n+      // 0 is total string:\n+      let r = matched[1];\n+      let g = matched[2];\n+      let b = matched[3];\n+      // var 1 = matched[4]; // if alpha is provided\n+\n+      let luma = 0.2126 * r + 0.7152 * g + 0.0722 * b; // per ITU-R BT.709\n+\n+      if (luma < 40) {\n+        bkColorReturn = bkColorDark;\n+      } else {\n+        bkColorReturn = bkColorLight;\n+      }\n+    } else {\n+      bkColorReturn = bkColorLight; // RegExp failed, assume dark color\n+    }\n+\n+    return 'inherit'; // Use: bkColorReturn if you want to adjust background based on text perceived brightness\n+  }\n+\n+  /**\n+   * HTML bookend a string\n+   */\n+  bookend(bookend, text, style) {\n+    return (\n+      '<' +\n+      bookend +\n+      (style ? ' style=\"' + style + '\"' : '') +\n+      '>' +\n+      (text || '') +\n+      '</' +\n+      bookend +\n+      '>'\n+    );\n+  }\n+\n+  /**\n+   * Get selected text\n+   * http://stackoverflow.com/questions/5379120/get-the-highlighted-selected-text\n+   */\n+  getSelectedText() {\n+    let text = '';\n+    let activeEl = document.activeElement;\n+    let activeElTagName = activeEl ? activeEl.tagName.toLowerCase() : null;\n+    if (\n+      (activeElTagName == 'textarea' || activeElTagName == 'input') &&\n+      /^(?:text|search|password|tel|url)$/i.test(activeEl.type) &&\n+      typeof activeEl.selectionStart == 'number'\n+    ) {\n+      text = activeEl.value\n+        .slice(activeEl.selectionStart, activeEl.selectionEnd)\n+        .trim();\n+    } else if (document.selection) {\n+      text = document.selection.createRange().text.trim();\n+    } else if (document.getSelection) {\n+      text = document.getSelection().toString().trim();\n+    } else if (window.getSelection) {\n+      text = window.getSelection().toString().trim();\n+    }\n+    return text;\n+  }\n+\n+  /**\n+   * Truncate a string\n+   */\n+  truncate(text, max, add) {\n+    let retn = text || '';\n+    const add_k = this.decodeEntities(add || '');\n+    const max_k = max - add_k.length;\n+\n+    if (text && text.length > max_k) {\n+      retn = text.slice(0, max_k) + add_k;\n+    }\n+    return retn;\n+  }\n+\n+  /***\n+   * Middle-truncate a string\n+   */\n+  midTruncate(text, max, add) {\n+    let retn = text || '';\n+    const add_k = this.decodeEntities(add || '');\n+    const max_k = Math.abs((max || 0) - add_k.length);\n+    const mid_k = (max_k + 0.01) / 2;\n+\n+    if (text && text.length > max_k) {\n+      retn = text.slice(0, mid_k + 1) + add_k + text.slice(-mid_k);\n+    }\n+    return retn;\n+  }\n+\n+  /**\n+   * Load settings\n+   */\n+  loadSettings(popup) {\n+    const self = this;\n+    const setID = self.CHROME_SETTINGS_ID;\n+    chrome.storage.sync.get(setID, function (response) {\n+      if (response?.[setID]) {\n+        // NOTE (Ace, 7-Feb-2017): Might need to store these off the app object:\n+        try {\n+          self.popupView.data.settings = JSON.parse(response[setID]);\n+        } catch (err) {\n+          g2t_log(\n+            'loadSettings: JSON parse failed! Error: ' + JSON.stringify(err)\n+          );\n+        }\n+      }\n+      if (popup) {\n+        popup.init_popup();\n+        self.updateData();\n+      }\n+    });\n+  }\n+\n+  /**\n+   * Save settings\n+   */\n+  saveSettings() {\n+    const self = this;",
    "path": "chrome_manifest_v3/class_app.js",
    "commit_id": "3bbc7b0b5b5abfda366260c45d6f2cecebf28af3",
    "original_commit_id": "ae0a391b6759338b0ec3c3292da07e458841ab71",
    "user": {
      "login": "coderabbitai[bot]",
      "id": 136622811,
      "node_id": "BOT_kgDOCCSy2w",
      "avatar_url": "https://avatars.githubusercontent.com/in/347564?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/coderabbitai%5Bbot%5D",
      "html_url": "https://github.com/apps/coderabbitai",
      "followers_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "_🛠️ Refactor suggestion_\n\n**Remove self. Not needed.**\n\n\n```diff\n   saveSettings() {\n-    const self = this;\n-    const setID = self.CHROME_SETTINGS_ID;\n-    let settings = Object.assign({}, self.popupView.data.settings);\n+    const setID = this.CHROME_SETTINGS_ID;\n+    let settings = Object.assign({}, this.popupView.data.settings);\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>📝 Committable suggestion</summary>\n\n> ‼️ **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n    saveSettings() {\n        const setID = this.CHROME_SETTINGS_ID;\n        let settings = Object.assign({}, this.popupView.data.settings);\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>🧰 Tools</summary>\n\n<details>\n<summary>🪛 Biome (1.9.4)</summary>\n\n[error] 729-729: This aliasing of this is unnecessary.\n\nArrow functions inherits `this` from their enclosing scope.\nSafe fix: Use this instead of an alias.\n\n\n(lint/complexity/noUselessThisAlias)\n\n</details>\n\n</details>\n\n<details>\n<summary>🤖 Prompt for AI Agents</summary>\n\n```\nIn chrome_manifest_v3/class_app.js at line 729, the declaration of the variable\n'self' is unnecessary. Remove the line 'const self = this;' to clean up the code\nsince 'self' is not used elsewhere.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:lion -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->\n\n✅ Addressed in commits 8198420 to 909c137",
    "created_at": "2025-07-13T21:43:20Z",
    "updated_at": "2025-07-14T04:13:17Z",
    "html_url": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203532572",
    "pull_request_url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532572"
      },
      "html": {
        "href": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203532572"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203532572/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 729,
    "side": "RIGHT",
    "original_position": 729,
    "position": null,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203704186",
    "pull_request_review_id": 3014554580,
    "id": 2203704186,
    "node_id": "PRRC_kwDOD1hYKM6DWdt6",
    "diff_hunk": "@@ -0,0 +1,852 @@\n+/** Gmail2Trello Application - ES6 Class Version\n+ */\n+\n+var Gmail2Trello = Gmail2Trello || {}; // Namespace initialization - must be var to guarantee correct scope\n+\n+class App {\n+  constructor() {\n+    this.CHROME_SETTINGS_ID = 'g2t_user_settings';\n+    this.UNIQUE_URI_VAR = 'g2t_filename';\n+\n+    this.model = new Gmail2Trello.Model(this);\n+    this.gmailView = new Gmail2Trello.GmailView(this);\n+    this.popupView = new Gmail2Trello.PopupView(this);\n+\n+    this.bindEvents();\n+  }\n+\n+  bindEvents() {\n+    /*** Data's events binding ***/\n+    this.model.event.addListener('onBeforeAuthorize', this.handleBeforeAuthorize.bind(this));\n+    this.model.event.addListener('onAuthorizeFail', this.handleAuthorizeFail.bind(this));\n+    this.model.event.addListener('onAuthorized', this.handleAuthorized.bind(this));\n+    this.model.event.addListener('onBeforeLoadTrello', this.handleBeforeLoadTrello.bind(this));\n+    this.model.event.addListener('onTrelloDataReady', this.handleTrelloDataReady.bind(this));\n+    this.model.event.addListener('onLoadTrelloListSuccess', this.handleLoadTrelloListSuccess.bind(this));\n+    this.model.event.addListener('onLoadTrelloCardsSuccess', this.handleLoadTrelloCardsSuccess.bind(this));\n+    this.model.event.addListener('onLoadTrelloLabelsSuccess', this.handleLoadTrelloLabelsSuccess.bind(this));\n+    this.model.event.addListener('onLoadTrelloMembersSuccess', this.handleLoadTrelloMembersSuccess.bind(this));\n+    this.model.event.addListener('onCardSubmitComplete', this.handleCardSubmitComplete.bind(this));\n+    this.model.event.addListener('onAPIFailure', this.handleAPIFailure.bind(this));\n+\n+    /*** PopupView's events binding ***/\n+    this.popupView.event.addListener('onPopupVisible', this.handlePopupVisible.bind(this));\n+    this.popupView.event.addListener('periodicChecks', this.handlePeriodicChecks.bind(this));\n+    this.popupView.event.addListener('onBoardChanged', this.handleBoardChanged.bind(this));\n+    this.popupView.event.addListener('onListChanged', this.handleListChanged.bind(this));\n+    this.popupView.event.addListener('onSubmit', this.handleSubmit.bind(this));\n+    this.popupView.event.addListener('checkTrelloAuthorized', this.handleCheckTrelloAuthorized.bind(this));\n+    this.popupView.event.addListener('onRequestDeauthorizeTrello', this.handleRequestDeauthorizeTrello.bind(this));\n+    this.popupView.event.addListener('detectButton', this.handleDetectButton.bind(this));\n+\n+    // GMailView's events:\n+    this.gmailView.event.addListener('onDetected', this.handleGmailDetected.bind(this));\n+    this.gmailView.event.addListener('detectButton', this.handleDetectButton.bind(this));\n+\n+    chrome.runtime.onMessage.addListener(this.handleRuntimeMessage.bind(this));\n+  }\n+\n+  // Event handler methods\n+  handleBeforeAuthorize() {\n+    this.popupView.bindData(''); // Intentionally blank\n+    this.popupView.showMessage(this, 'Authorizing...');\n+  }\n+\n+  handleAuthorizeFail() {\n+    this.popupView.showMessage(\n+      this,\n+      'Trello authorization failed <button id=\"showsignout\">Sign out and try again</button>'\n+    );\n+  }\n+\n+  handleAuthorized() {\n+    this.popupView.$popupContent.show();\n+    this.popupView.hideMessage();\n+  }\n+\n+  handleBeforeLoadTrello() {\n+    this.popupView.showMessage(this, 'Loading Trello data...');\n+  }\n+\n+  handleTrelloDataReady() {\n+    this.popupView.$popupContent.show();\n+    this.popupView.hideMessage();\n+    this.popupView.bindData(this.model);\n+  }\n+\n+  handleLoadTrelloListSuccess() {\n+    this.popupView.updateLists();\n+    this.popupView.validateData();\n+  }\n+\n+  handleLoadTrelloCardsSuccess() {\n+    this.popupView.updateCards();\n+    this.popupView.validateData();\n+  }\n+\n+  handleLoadTrelloLabelsSuccess() {\n+    this.popupView.updateLabels();\n+    this.popupView.validateData();\n+  }\n+\n+  handleLoadTrelloMembersSuccess() {\n+    this.popupView.updateMembers();\n+    this.popupView.validateData();\n+  }\n+\n+  handleCardSubmitComplete(target, params) {\n+    this.popupView.displaySubmitCompleteForm();\n+    // If card lists or labels have been updated, reload:\n+    const data_k = params?.data || {};\n+    const emailId = data_k?.emailId || 0;\n+    const boardId_k = data_k?.data?.board?.id || 0;\n+    const listId_k = data_k?.data?.list?.id || 0;\n+    const cardId_k = data_k?.data?.card?.id || 0;\n+    const idBoard_k = data_k?.idBoard || 0;\n+    const idList_k = data_k?.idList || 0;\n+    const idCard_k = data_k?.idCard || 0;\n+    const boardId = boardId_k || idBoard_k || 0;\n+    const listId = listId_k || idList_k || 0;\n+    const cardId = cardId_k || idCard_k || 0;\n+    // NOTE (acoven@2020-05-23): Users expect when creating a brand new card,\n+    // we'll remember that new card ID and then keep defaulting to it for\n+    // subsequent updates to that email. That means we'll have to get the return\n+    // value/url from Trello and dissect that, potentially doing this update\n+    // in that routine:\n+    this.model.emailBoardListCardMapUpdate({\n+      emailId,\n+      boardId,\n+      listId,\n+      cardId,\n+    });\n+\n+    if (boardId) {\n+      this.model.loadTrelloLabels(boardId);\n+      this.model.loadTrelloMembers(boardId);\n+    }\n+    if (listId) {\n+      this.model.loadTrelloCards(listId);\n+    }\n+  }\n+\n+  handleAPIFailure(target, params) {\n+    this.popupView.displayAPIFailedForm(params);\n+  }\n+\n+  handlePopupVisible() {\n+    if (!this.model.isInitialized) {\n+      this.popupView.showMessage(this, 'Initializing...');\n+      this.popupView.$popupContent.hide();\n+      this.model.init();\n+    } else {\n+      this.popupView.reset();\n+    }\n+\n+    const trelloUser_k = this?.model?.trello?.user || {};\n+    const fullName = trelloUser_k?.fullName || '';\n+\n+    this.gmailView.parsingData = false;\n+    this.model.gmail = this.gmailView.parseData({ fullName });\n+    this.popupView.bindGmailData(this.model.gmail);\n+    this.popupView.event.fire('periodicChecks');\n+  }\n+\n+  handlePeriodicChecks() {\n+    setTimeout(() => {\n+      this.popupView.periodicChecks();\n+    }, 3000);\n+  }\n+\n+  handleBoardChanged(target, params) {\n+    let boardId = params.boardId;",
    "path": "chrome_manifest_v3/class_app.js",
    "commit_id": "3bbc7b0b5b5abfda366260c45d6f2cecebf28af3",
    "original_commit_id": "f609e1322b9a0f1b03b7094863f0c64a967e9df2",
    "user": {
      "login": "coderabbitai[bot]",
      "id": 136622811,
      "node_id": "BOT_kgDOCCSy2w",
      "avatar_url": "https://avatars.githubusercontent.com/in/347564?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/coderabbitai%5Bbot%5D",
      "html_url": "https://github.com/apps/coderabbitai",
      "followers_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "_🧹 Nitpick (assertive)_\n\n**Use const. Not reassigned.**\n\n```diff\n-    let boardId = params.boardId;\n+    const boardId = params.boardId;\n```\n\n```diff\n-    let listId = params.listId;\n+    const listId = params.listId;\n```\n\nNow whut?\n\n\n\nAlso applies to: 170-170\n\n<details>\n<summary>🧰 Tools</summary>\n\n<details>\n<summary>🪛 Biome (1.9.4)</summary>\n\n[error] 161-161: This let declares a variable that is only assigned once.\n\n'boardId' is never reassigned.\n\nSafe fix: Use const instead.\n\n\n(lint/style/useConst)\n\n</details>\n\n</details>\n\n<details>\n<summary>🤖 Prompt for AI Agents</summary>\n\n```\nIn chrome_manifest_v3/class_app.js at lines 161 and 170, the variable boardId is\ndeclared with let but never reassigned. Change let to const for both instances\nto follow best practices for immutable variables.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:lion -->\n\n<!-- This is an auto-generated reply by CodeRabbit -->\n\n✅ Addressed in commit fa36711\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "created_at": "2025-07-14T01:54:39Z",
    "updated_at": "2025-07-14T06:31:22Z",
    "html_url": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203704186",
    "pull_request_url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203704186"
      },
      "html": {
        "href": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203704186"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203704186/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 161,
    "side": "RIGHT",
    "original_position": 161,
    "position": null,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203704188",
    "pull_request_review_id": 3014554580,
    "id": 2203704188,
    "node_id": "PRRC_kwDOD1hYKM6DWdt8",
    "diff_hunk": "@@ -0,0 +1,852 @@\n+/** Gmail2Trello Application - ES6 Class Version\n+ */\n+\n+var Gmail2Trello = Gmail2Trello || {}; // Namespace initialization - must be var to guarantee correct scope\n+\n+class App {\n+  constructor() {\n+    this.CHROME_SETTINGS_ID = 'g2t_user_settings';\n+    this.UNIQUE_URI_VAR = 'g2t_filename';\n+\n+    this.model = new Gmail2Trello.Model(this);\n+    this.gmailView = new Gmail2Trello.GmailView(this);\n+    this.popupView = new Gmail2Trello.PopupView(this);\n+\n+    this.bindEvents();\n+  }\n+\n+  bindEvents() {\n+    /*** Data's events binding ***/\n+    this.model.event.addListener('onBeforeAuthorize', this.handleBeforeAuthorize.bind(this));\n+    this.model.event.addListener('onAuthorizeFail', this.handleAuthorizeFail.bind(this));\n+    this.model.event.addListener('onAuthorized', this.handleAuthorized.bind(this));\n+    this.model.event.addListener('onBeforeLoadTrello', this.handleBeforeLoadTrello.bind(this));\n+    this.model.event.addListener('onTrelloDataReady', this.handleTrelloDataReady.bind(this));\n+    this.model.event.addListener('onLoadTrelloListSuccess', this.handleLoadTrelloListSuccess.bind(this));\n+    this.model.event.addListener('onLoadTrelloCardsSuccess', this.handleLoadTrelloCardsSuccess.bind(this));\n+    this.model.event.addListener('onLoadTrelloLabelsSuccess', this.handleLoadTrelloLabelsSuccess.bind(this));\n+    this.model.event.addListener('onLoadTrelloMembersSuccess', this.handleLoadTrelloMembersSuccess.bind(this));\n+    this.model.event.addListener('onCardSubmitComplete', this.handleCardSubmitComplete.bind(this));\n+    this.model.event.addListener('onAPIFailure', this.handleAPIFailure.bind(this));\n+\n+    /*** PopupView's events binding ***/\n+    this.popupView.event.addListener('onPopupVisible', this.handlePopupVisible.bind(this));\n+    this.popupView.event.addListener('periodicChecks', this.handlePeriodicChecks.bind(this));\n+    this.popupView.event.addListener('onBoardChanged', this.handleBoardChanged.bind(this));\n+    this.popupView.event.addListener('onListChanged', this.handleListChanged.bind(this));\n+    this.popupView.event.addListener('onSubmit', this.handleSubmit.bind(this));\n+    this.popupView.event.addListener('checkTrelloAuthorized', this.handleCheckTrelloAuthorized.bind(this));\n+    this.popupView.event.addListener('onRequestDeauthorizeTrello', this.handleRequestDeauthorizeTrello.bind(this));\n+    this.popupView.event.addListener('detectButton', this.handleDetectButton.bind(this));\n+\n+    // GMailView's events:\n+    this.gmailView.event.addListener('onDetected', this.handleGmailDetected.bind(this));\n+    this.gmailView.event.addListener('detectButton', this.handleDetectButton.bind(this));\n+\n+    chrome.runtime.onMessage.addListener(this.handleRuntimeMessage.bind(this));\n+  }\n+\n+  // Event handler methods\n+  handleBeforeAuthorize() {\n+    this.popupView.bindData(''); // Intentionally blank\n+    this.popupView.showMessage(this, 'Authorizing...');\n+  }\n+\n+  handleAuthorizeFail() {\n+    this.popupView.showMessage(\n+      this,\n+      'Trello authorization failed <button id=\"showsignout\">Sign out and try again</button>'\n+    );\n+  }\n+\n+  handleAuthorized() {\n+    this.popupView.$popupContent.show();\n+    this.popupView.hideMessage();\n+  }\n+\n+  handleBeforeLoadTrello() {\n+    this.popupView.showMessage(this, 'Loading Trello data...');\n+  }\n+\n+  handleTrelloDataReady() {\n+    this.popupView.$popupContent.show();\n+    this.popupView.hideMessage();\n+    this.popupView.bindData(this.model);\n+  }\n+\n+  handleLoadTrelloListSuccess() {\n+    this.popupView.updateLists();\n+    this.popupView.validateData();\n+  }\n+\n+  handleLoadTrelloCardsSuccess() {\n+    this.popupView.updateCards();\n+    this.popupView.validateData();\n+  }\n+\n+  handleLoadTrelloLabelsSuccess() {\n+    this.popupView.updateLabels();\n+    this.popupView.validateData();\n+  }\n+\n+  handleLoadTrelloMembersSuccess() {\n+    this.popupView.updateMembers();\n+    this.popupView.validateData();\n+  }\n+\n+  handleCardSubmitComplete(target, params) {\n+    this.popupView.displaySubmitCompleteForm();\n+    // If card lists or labels have been updated, reload:\n+    const data_k = params?.data || {};\n+    const emailId = data_k?.emailId || 0;\n+    const boardId_k = data_k?.data?.board?.id || 0;\n+    const listId_k = data_k?.data?.list?.id || 0;\n+    const cardId_k = data_k?.data?.card?.id || 0;\n+    const idBoard_k = data_k?.idBoard || 0;\n+    const idList_k = data_k?.idList || 0;\n+    const idCard_k = data_k?.idCard || 0;\n+    const boardId = boardId_k || idBoard_k || 0;\n+    const listId = listId_k || idList_k || 0;\n+    const cardId = cardId_k || idCard_k || 0;\n+    // NOTE (acoven@2020-05-23): Users expect when creating a brand new card,\n+    // we'll remember that new card ID and then keep defaulting to it for\n+    // subsequent updates to that email. That means we'll have to get the return\n+    // value/url from Trello and dissect that, potentially doing this update\n+    // in that routine:\n+    this.model.emailBoardListCardMapUpdate({\n+      emailId,\n+      boardId,\n+      listId,\n+      cardId,\n+    });\n+\n+    if (boardId) {\n+      this.model.loadTrelloLabels(boardId);\n+      this.model.loadTrelloMembers(boardId);\n+    }\n+    if (listId) {\n+      this.model.loadTrelloCards(listId);\n+    }\n+  }\n+\n+  handleAPIFailure(target, params) {\n+    this.popupView.displayAPIFailedForm(params);\n+  }\n+\n+  handlePopupVisible() {\n+    if (!this.model.isInitialized) {\n+      this.popupView.showMessage(this, 'Initializing...');\n+      this.popupView.$popupContent.hide();\n+      this.model.init();\n+    } else {\n+      this.popupView.reset();\n+    }\n+\n+    const trelloUser_k = this?.model?.trello?.user || {};\n+    const fullName = trelloUser_k?.fullName || '';\n+\n+    this.gmailView.parsingData = false;\n+    this.model.gmail = this.gmailView.parseData({ fullName });\n+    this.popupView.bindGmailData(this.model.gmail);\n+    this.popupView.event.fire('periodicChecks');\n+  }\n+\n+  handlePeriodicChecks() {\n+    setTimeout(() => {\n+      this.popupView.periodicChecks();\n+    }, 3000);\n+  }\n+\n+  handleBoardChanged(target, params) {\n+    let boardId = params.boardId;\n+    if (boardId !== '_' && boardId !== '' && boardId !== null) {\n+      this.model.loadTrelloLists(boardId);\n+      this.model.loadTrelloLabels(boardId);\n+      this.model.loadTrelloMembers(boardId);\n+    }\n+  }\n+\n+  handleListChanged(target, params) {\n+    let listId = params.listId;\n+    this.model.loadTrelloCards(listId);\n+  }\n+\n+  handleSubmit() {\n+    this.model.submit();\n+  }\n+\n+  handleCheckTrelloAuthorized() {\n+    this.popupView.showMessage(this, 'Authorizing...');\n+    this.model.checkTrelloAuthorized();\n+  }\n+\n+  handleRequestDeauthorizeTrello() {\n+    g2t_log('onRequestDeauthorizeTrello');\n+    this.model.deauthorizeTrello();\n+    this.popupView.clearBoard();\n+  }\n+\n+  handleDetectButton() {\n+    if (this.gmailView.preDetect()) {\n+      this.popupView.$toolBar = this.gmailView.$toolBar;\n+      this.popupView.confirmPopup();\n+    }\n+  }\n+\n+  handleGmailDetected() {\n+    this.popupView.$toolBar = this.gmailView.$toolBar;\n+    this.popupView.init();\n+  }\n+\n+  handleRuntimeMessage(request, sender, sendResponse) {\n+    if (request?.message === 'g2t_keyboard_shortcut') {\n+      this.popupView.showPopup();\n+    }\n+  }\n+\n+  updateData() {\n+    const self = this;\n+\n+    const fullName = self?.model?.trello?.user?.fullName || '';\n+\n+    self.popupView.bindData(self.model);\n+\n+    self.gmailView.parsingData = false;\n+    self.model.gmail = self.gmailView.parseData({ fullName });\n+    self.popupView.bindGmailData(self.model.gmail);\n+  }\n+\n+  initialize() {\n+    const self = this;\n+\n+    this.model.isInitialized = false;\n+\n+    // g2t_log('App:initialize');\n+\n+    this.gmailView.detect();\n+\n+    service = analytics.getService('gmail-2-trello');\n+\n+    // Get a Tracker using your Google Analytics app Tracking ID.\n+    tracker = service.getTracker('G-0QPEDL7YDL'); // Was: UA-8469046-1 -> UA-42442437-4\n+\n+    // Record an \"appView\" each time the user launches your app or goes to a new\n+    // screen within the app.\n+    tracker.sendAppView('PopupView');\n+  }\n+\n+  /**\n+   * Correctly escape RegExp\n+   */\n+  escapeRegExp(str) {\n+    return str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n+  }\n+\n+  /**\n+   * Utility routine to replace variables\n+   */\n+  replacer(text, dict) {\n+    let self = this;\n+\n+    if (!text || text.length < 1) {\n+      // g2t_log('Require text!');\n+      return '';\n+    } else if (!dict || dict.length < 2) {\n+      g2t_log('replacer: Require dictionary!');\n+      return text;\n+    }\n+\n+    let re, new_text;\n+    const replacify = function () {\n+      g2t_each(dict, function (value, key) {\n+        re = new RegExp(`%${self.escapeRegExp(key)}%`, 'gi');\n+        new_text = text.replace(re, value);\n+        text = new_text;\n+      });\n+    };\n+\n+    let runaway_max = 3;\n+    while (text.indexOf('%') !== -1 && runaway_max-- > 0) {\n+      replacify();\n+    }\n+\n+    return text;\n+  }\n+\n+  /**\n+   * Make displayable URI\n+   */\n+  uriForDisplay(uri) {\n+    const uri_display_trigger_length_k = 20;\n+    const uri_length_max_k = 40;\n+    let uri_display = uri || '';\n+    if (uri_display.length > uri_display_trigger_length_k) {\n+      let re = RegExp('^\\\\w+://([\\\\w./_-]+).*?([\\\\w._-]*)$');\n+      let matched = uri_display.match(re);\n+      if (matched && matched.length > 1) {\n+        const filename_k =\n+          matched[2].length < uri_length_max_k\n+            ? matched[2]\n+            : matched[2].slice(-uri_length_max_k);\n+        let prelude = matched[1].substr(0, uri_length_max_k);\n+        if (matched[1].length > uri_length_max_k) {\n+          prelude += '...';\n+        } else if (filename_k.length > 0) {\n+          prelude += ':';\n+        }\n+\n+        uri_display = prelude + filename_k;\n+      }\n+    }\n+    return uri_display;\n+  }\n+\n+  /**\n+   * Make anchored backlink\n+   */\n+  anchorMarkdownify(text, href, comment) {\n+    let text1 = (text || '').trim();\n+    let text1lc = text1.toLowerCase();\n+    let href1 = (href || '').trim();\n+    let href1lc = href1.toLowerCase();\n+    let comment1 = (comment || '').trim();\n+\n+    let retn = '';\n+\n+    if (text1.length < 1 && href1.length < 1) {\n+      // Intetionally blank\n+    } else if (text1lc === href1lc) {\n+      retn = ` <${href1}> `; // This renders correctly in Trello as a sole URL\n+      // NOTE (Ace, 17-Feb-2017): Turns out Trello doesn't support markdown [] only, so we'll construct a nice displayable text vs url:\n+      // text1 = this.uriForDisplay(text1);\n+    } else if (`mailto:${text1lc}` === href1lc) {\n+      retn = ` <${text1}> `; // This renders correctly in Trello as a mailto: url\n+    } else {\n+      const comment1QuotedSpaced = comment1.length > 0 ? ` \"${comment1}\"` : '';\n+      retn = ` [${text1}](<${href1}>${comment1QuotedSpaced}) `;\n+    }\n+\n+    return retn;\n+  }\n+\n+  /**\n+   * Split an email into name and domain\n+   */\n+  splitEmailDomain(email = '') {\n+    const split = email.split('@');\n+    const name = split[0] || '';\n+    const domain = split[1] || '';\n+    return {\n+      name,\n+      domain,\n+    };\n+  }\n+\n+  /**\n+   * Add trailing char if not empty:\n+   */\n+  addChar(front = '', back = '', addChar = ' ') {\n+    if (front.length > 0) {\n+      if (back.length > 0) {\n+        return `${front}${addChar}${back}`;\n+      } else {\n+        return `${front}${addChar}`;\n+      }\n+    } else if (back.length > 0) {\n+      return `${addChar}${back}`;\n+    } else {\n+      return '';\n+    }\n+  }\n+\n+  /**\n+   * Add trailing space if not empty:\n+   */\n+  addSpace(front = '', back = '') {\n+    return this.addChar(front, back, ' ');\n+  }\n+\n+  /**\n+   * Add trailing CRLF if not empty:\n+   */\n+  addCRLF(front = '', back = '') {\n+    return this.addChar(front, back, '\\n');\n+  }\n+\n+  /**\n+   * Markdownify a text block\n+   */\n+  markdownify($emailBody, features, preprocess) {\n+    if (!$emailBody || $emailBody.length < 1) {\n+      g2t_log('markdownify: Require emailBody!');\n+      return;\n+    }\n+    const self = this;\n+\n+    const min_text_length_k = 4;\n+    const max_replace_attempts_k = 10;\n+    const regexp_k = {\n+      begin: '(^|\\\\s+|<|\\\\[|\\\\(|\\\\b|(?=\\\\W+))',\n+      end: '($|\\\\s+|>|\\\\]|\\\\)|\\\\b|(?=\\\\W+))',\n+    };\n+    const unique_placeholder_k = 'g2t_placeholder:'; // Unique placeholder tag\n+\n+    let count = 0;\n+    let replacer_dict = {};\n+\n+    const featureEnabled = (elementTag = '') =>\n+      features === false ? false : features?.[elementTag] !== false;\n+\n+    let $html = $emailBody || ''; // Was: $emailBody.innerHTML || \"\";\n+    // let body = $emailBody.text() || \"\";\n+    let body = $emailBody.html() || '';\n+\n+    // Different encodings handle CRLF differently, so we'll process the main body as html and convert to text:\n+    // Convert paragraph marker to two returns:\n+    let replaced = body.replace(/\\s*[\\n\\r]*<p[^>]*>\\s*[\\n\\r]*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // Convert br marker to one return:\n+    replaced = body.replace(/\\s*[\\n\\r]*<br[^>]*>\\s*[\\n\\r]*/g, '\\n');\n+    body = replaced;\n+\n+    // Remove all other html markers:\n+    replaced = body.replace(/<[^>]*>/g, '');\n+    body = replaced;\n+\n+    // Decode HTML entities:\n+    replaced = self.decodeEntities(body);\n+    body = replaced;\n+\n+    // Replace hr:\n+    replaced = body.replace(/\\s*-{3,}\\s*/g, '---\\n');\n+    body = replaced;\n+\n+    // Convert crlf x 2 (or more) to paragraph markers:\n+    replaced = body.replace(/(\\s*[\\n\\r]\\s*){2,}/g, '<p />\\n');\n+    body = replaced;\n+\n+    let toProcess = {};\n+\n+    /**\n+     * 5 explicit steps in 3 passes:\n+     * (1) Collect tagged items\n+     * (2) Remove duplicates\n+     * (3) Sort force-lowercase by length\n+     * (4) Replace with placeholder\n+     * (5) Replace placeholders with final text\n+     */\n+    const sortAndPlaceholderize = function (tooProcess) {\n+      if (tooProcess) {\n+        g2t_each(\n+          Object.keys(tooProcess).sort(function (a, b) {\n+            // Go by order of largest to smallest\n+            return b.length - a.length;\n+          }),\n+          function (value) {\n+            const replace = tooProcess[value];\n+            const swap = `${unique_placeholder_k}${(count++).toString()}`;\n+            const re = new RegExp(\n+              regexp_k.begin + self.escapeRegExp(value) + regexp_k.end,\n+              'gi'\n+            );\n+            const replaced = body.replace(re, `%${swap}%`); // Replace occurance with placeholder\n+            if (body !== replaced) {\n+              body = replaced;\n+              replacer_dict[swap] = replace;\n+            }\n+          }\n+        );\n+      }\n+    };\n+    const processMarkdown = function (elementTag, replaceText) {\n+      if (elementTag && replaceText && featureEnabled(elementTag)) {\n+        toProcess = preprocess[elementTag] || {};\n+        $(elementTag, $html).each(function (index, value) {\n+          let text = ($(this).text() || '').trim();\n+          if (text && text.length > min_text_length_k) {\n+            let replace = self.replacer(replaceText, { text: text });\n+            toProcess[text.toLowerCase()] = replace; // Intentionally overwrites duplicates\n+          }\n+        });\n+        sortAndPlaceholderize(toProcess);\n+      }\n+    };\n+    /**\n+     * Repeat replace for max attempts or when done, whatever comes first\n+     */\n+    const repeatReplace = function (body, inRegexp, replaceWith) {\n+      let replace1 = '';\n+      for (let iter = max_replace_attempts_k; iter > 0; iter--) {\n+        replace1 = body.replace(inRegexp, replaceWith);\n+        if (body === replace1) {\n+          iter = 0; // All done\n+        } else {\n+          body = replace1;\n+        }\n+      }\n+      return body;\n+    };\n+\n+    // bullet lists:\n+    // ul li -> \" * \"\n+    processMarkdown('ul li', '<p />* %text%<p />');\n+\n+    // numeric lists:\n+    // ol li -> \" 1. \"\n+    processMarkdown('ol li', '<p />1. %text%<p />');\n+\n+    // headers:\n+    // H1 -> #\n+    // H2 -> ##\n+    // H3 -> ###\n+    // H4 -> ####\n+    // H5 -> #####\n+    // H6 -> ######\n+    if (featureEnabled('h')) {\n+      toProcess = preprocess['h'] || {};\n+      $(':header', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let nodeName = $(this).prop('nodeName') || '0';\n+        if (nodeName && text && text.length > min_text_length_k) {\n+          let x = nodeName.substr(-1);\n+          toProcess[text.toLowerCase()] = `\\n${'#'.repeat(x)} ${text}\\n`; // Intentionally overwrites duplicates\n+        }\n+      });\n+      sortAndPlaceholderize(toProcess);\n+    }\n+\n+    replaced = this.replacer(body, replacer_dict); // Replace initial batch of <div> like placeholders\n+    body = replaced;\n+    replacer_dict = {}; // Reset\n+    count = 0; // Reset\n+\n+    // bold: b -> **text**\n+    processMarkdown('b', ' **%text%** ');\n+\n+    // italics: i -> _text_\n+    processMarkdown('i', ' _%text%_ ');\n+\n+    // links:\n+    // a -> [text](html)\n+    if (featureEnabled('a')) {\n+      toProcess = preprocess['a'] || {};\n+      $('a', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let href = ($(this).prop('href') || '').trim(); // Was attr\n+        /*\n+              var uri_display = self.uriForDisplay(href);\n+              var comment = ' \"' + text + ' via ' + uri_display + '\"';\n+              var re = new RegExp(self.escapeRegExp(text), \"i\");\n+              if (uri.match(re)) {\n+                  comment = ' \"Open ' + uri_display + '\"';\n+              }\n+              */\n+        if (href && text && text.length >= min_text_length_k) {\n+          toProcess[text.toLowerCase()] = self.anchorMarkdownify(text, href); // Comment seemed like too much extra text // Intentionally overwrites duplicates\n+        }\n+      });\n+      sortAndPlaceholderize(toProcess);\n+    }\n+\n+    /* DISABLED (Ace, 16-Jan-2017): Images kinda make a mess, until requested lets not markdownify them:\n+      // images:\n+      // img -> ![alt_text](html)\n+      if (featureEnabled('img')) {\n+          $('img', $html).each(function(index, value) {\n+              var text = ($(this).prop(\"alt\") || \"\").trim(); // Was attr\n+              var href = ($(this).prop(\"src\") || \"\").trim(); // Was attr\n+              // var uri_display = self.uriForDisplay(href);\n+              if (href && text && text.length >= min_text_length_k) {\n+                  toProcess[text.toLowerCase()] = self.anchorMarkdownify(text, href); // Comment seemed like too much extra text // Intentionally overwrites duplicates\n+              }\n+          });\n+          sortAndPlaceholderize(toProcess);\n+      }\n+      */\n+\n+    replaced = this.replacer(body, replacer_dict); // Replace second batch of <span> like placeholders\n+    body = replaced;\n+\n+    // Replace bullets following a CRLF:\n+    replaced = body.replace(/\\s*[\\n\\r]+\\s*[·-]+\\s*/g, '<p />* '); // = [\\u00B7\\u2022]\n+    body = replaced;\n+\n+    // Replace remaining bullets with asterisks:\n+    replaced = body.replace(/[·]/g, '*');\n+    body = replaced;\n+\n+    // ORDER MATTERS FOR THIS NEXT SET:\n+    // (1) Replace <space>CRLF<space> with just CR:\n+    replaced = body.replace(/\\s*[\\n\\r]+\\s*/g, '\\n');\n+    body = replaced;\n+\n+    // (2) Replace 2 or more spaces with just one:\n+    replaced = repeatReplace(body, new RegExp('\\\\s{2,}', 'g'), ' ');\n+    body = replaced;\n+\n+    // (3) Replace paragraph markers with CR+CR:\n+    replaced = body.replace(/\\s*<p \\/>\\s*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // (4) Replace 3 or more CRs with just two:\n+    replaced = repeatReplace(body, new RegExp('\\\\n{3,}', 'g'), '\\n\\n');\n+    body = replaced;\n+\n+    // (5) Trim excess at beginning and end:\n+    replaced = body.trim();\n+    body = replaced;\n+\n+    return body;\n+  }\n+\n+  /**\n+   * Determine luminance of a color so we can augment with darker/lighter background\n+   */\n+  luminance(color) {\n+    let bkColorLight = 'lightGray'; // or white\n+    let bkColorDark = 'darkGray'; // 'gray' is even darker\n+    let bkColorReturn = bkColorLight;\n+\n+    let re = new RegExp('rgb\\\\D+(\\\\d+)\\\\D+(\\\\d+)\\\\D+(\\\\d+)');\n+    let matched = color.match(re, 'i');\n+    if (matched && matched.length > 2) {\n+      // 0 is total string:\n+      let r = matched[1];\n+      let g = matched[2];\n+      let b = matched[3];\n+      // var 1 = matched[4]; // if alpha is provided\n+\n+      let luma = 0.2126 * r + 0.7152 * g + 0.0722 * b; // per ITU-R BT.709\n+\n+      if (luma < 40) {\n+        bkColorReturn = bkColorDark;\n+      } else {\n+        bkColorReturn = bkColorLight;\n+      }\n+    } else {\n+      bkColorReturn = bkColorLight; // RegExp failed, assume dark color\n+    }\n+\n+    return 'inherit'; // Use: bkColorReturn if you want to adjust background based on text perceived brightness\n+  }\n+\n+  /**\n+   * HTML bookend a string\n+   */\n+  bookend(bookend, text, style) {\n+    return (\n+      '<' +\n+      bookend +\n+      (style ? ' style=\"' + style + '\"' : '') +\n+      '>' +\n+      (text || '') +\n+      '</' +\n+      bookend +\n+      '>'\n+    );\n+  }\n+\n+  /**\n+   * Get selected text\n+   * http://stackoverflow.com/questions/5379120/get-the-highlighted-selected-text\n+   */\n+  getSelectedText() {\n+    let text = '';\n+    let activeEl = document.activeElement;\n+    let activeElTagName = activeEl ? activeEl.tagName.toLowerCase() : null;\n+    if (\n+      (activeElTagName == 'textarea' || activeElTagName == 'input') &&\n+      /^(?:text|search|password|tel|url)$/i.test(activeEl.type) &&\n+      typeof activeEl.selectionStart == 'number'\n+    ) {\n+      text = activeEl.value\n+        .slice(activeEl.selectionStart, activeEl.selectionEnd)\n+        .trim();\n+    } else if (document.selection) {\n+      text = document.selection.createRange().text.trim();\n+    } else if (document.getSelection) {\n+      text = document.getSelection().toString().trim();\n+    } else if (window.getSelection) {\n+      text = window.getSelection().toString().trim();\n+    }\n+    return text;\n+  }\n+\n+  /**\n+   * Truncate a string\n+   */\n+  truncate(text, max, add) {\n+    let retn = text || '';\n+    const add_k = this.decodeEntities(add || '');\n+    const max_k = max - add_k.length;\n+\n+    if (text && text.length > max_k) {\n+      retn = text.slice(0, max_k) + add_k;\n+    }\n+    return retn;\n+  }\n+\n+  /***\n+   * Middle-truncate a string\n+   */\n+  midTruncate(text, max, add) {\n+    let retn = text || '';\n+    const add_k = this.decodeEntities(add || '');\n+    const max_k = Math.abs((max || 0) - add_k.length);\n+    const mid_k = (max_k + 0.01) / 2;\n+\n+    if (text && text.length > max_k) {\n+      retn = text.slice(0, mid_k + 1) + add_k + text.slice(-mid_k);\n+    }\n+    return retn;\n+  }\n+\n+  /**\n+   * Load settings\n+   */\n+  loadSettings(popup) {\n+    const self = this;\n+    const setID = self.CHROME_SETTINGS_ID;\n+    chrome.storage.sync.get(setID, function (response) {\n+      if (response?.[setID]) {\n+        // NOTE (Ace, 7-Feb-2017): Might need to store these off the app object:\n+        try {\n+          self.popupView.data.settings = JSON.parse(response[setID]);\n+        } catch (err) {\n+          g2t_log(\n+            'loadSettings: JSON parse failed! Error: ' + JSON.stringify(err)\n+          );\n+        }\n+      }\n+      if (popup) {\n+        popup.init_popup();\n+        self.updateData();\n+      }\n+    });\n+  }\n+\n+  /**\n+   * Save settings\n+   */\n+  saveSettings() {\n+    const self = this;\n+    const setID = self.CHROME_SETTINGS_ID;\n+    let settings = Object.assign({}, self.popupView.data.settings);\n+\n+    // Delete large, potentially needing secure, data bits:\n+    settings.description = '';\n+    settings.title = '';\n+    settings.attachments = [];\n+    settings.images = [];\n+    delete settings.description;\n+    delete settings.title;\n+    delete settings.attachments;\n+    delete settings.images;\n+\n+    const settings_string_k = JSON.stringify(settings);\n+\n+    hash = {};\n+    hash[setID] = settings_string_k;\n+\n+    if (self.lastSettingsSave !== settings_string_k) {\n+      try {\n+        chrome.storage.sync.set(hash); // NOTE (Ace, 7-Feb-2017): Might need to store these off the app object\n+        self.lastSettingsSave = settings_string_k;\n+      } catch (error) {\n+        g2t_log(\n+          `saveSettings ERROR: extension context invalidated - failed \"chrome.storage.sync.set\"`\n+        );\n+        self?.popupView?.displayExtensionInvalidReload();\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Encode entities\n+   */\n+  encodeEntities(s) {\n+    let ta = document.createElement('textarea');",
    "path": "chrome_manifest_v3/class_app.js",
    "commit_id": "3bbc7b0b5b5abfda366260c45d6f2cecebf28af3",
    "original_commit_id": "f609e1322b9a0f1b03b7094863f0c64a967e9df2",
    "user": {
      "login": "coderabbitai[bot]",
      "id": 136622811,
      "node_id": "BOT_kgDOCCSy2w",
      "avatar_url": "https://avatars.githubusercontent.com/in/347564?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/coderabbitai%5Bbot%5D",
      "html_url": "https://github.com/apps/coderabbitai",
      "followers_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "_🧹 Nitpick (assertive)_\n\n**Both ta declarations. Use const.**\n\nLine 769:\n```diff\n-    let ta = document.createElement('textarea');\n+    const ta = document.createElement('textarea');\n```\n\nLine 794:\n```diff\n-    let ta = document.createElement('textarea');\n+    const ta = document.createElement('textarea');\n```\n\n\n\n\nAlso applies to: 794-794\n\n<details>\n<summary>🧰 Tools</summary>\n\n<details>\n<summary>🪛 Biome (1.9.4)</summary>\n\n[error] 769-769: This let declares a variable that is only assigned once.\n\n'ta' is never reassigned.\n\nSafe fix: Use const instead.\n\n\n(lint/style/useConst)\n\n</details>\n\n</details>\n\n<details>\n<summary>🤖 Prompt for AI Agents</summary>\n\n```\nIn chrome_manifest_v3/class_app.js at lines 769 and 794, the variable 'ta' is\ndeclared using 'let' but it is not reassigned later. Change both declarations of\n'ta' to use 'const' instead of 'let' to follow best practices for variables that\ndo not change.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:lion -->\n\n<!-- This is an auto-generated reply by CodeRabbit -->\n\n✅ Addressed in commits dfe3bc8 to 500c2a4\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "created_at": "2025-07-14T01:54:40Z",
    "updated_at": "2025-07-14T04:59:23Z",
    "html_url": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203704188",
    "pull_request_url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203704188"
      },
      "html": {
        "href": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203704188"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203704188/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 769,
    "side": "RIGHT",
    "original_position": 769,
    "position": null,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203704189",
    "pull_request_review_id": 3014554580,
    "id": 2203704189,
    "node_id": "PRRC_kwDOD1hYKM6DWdt9",
    "diff_hunk": "@@ -0,0 +1,852 @@\n+/** Gmail2Trello Application - ES6 Class Version\n+ */\n+\n+var Gmail2Trello = Gmail2Trello || {}; // Namespace initialization - must be var to guarantee correct scope\n+\n+class App {\n+  constructor() {\n+    this.CHROME_SETTINGS_ID = 'g2t_user_settings';\n+    this.UNIQUE_URI_VAR = 'g2t_filename';\n+\n+    this.model = new Gmail2Trello.Model(this);\n+    this.gmailView = new Gmail2Trello.GmailView(this);\n+    this.popupView = new Gmail2Trello.PopupView(this);\n+\n+    this.bindEvents();\n+  }\n+\n+  bindEvents() {\n+    /*** Data's events binding ***/\n+    this.model.event.addListener('onBeforeAuthorize', this.handleBeforeAuthorize.bind(this));\n+    this.model.event.addListener('onAuthorizeFail', this.handleAuthorizeFail.bind(this));\n+    this.model.event.addListener('onAuthorized', this.handleAuthorized.bind(this));\n+    this.model.event.addListener('onBeforeLoadTrello', this.handleBeforeLoadTrello.bind(this));\n+    this.model.event.addListener('onTrelloDataReady', this.handleTrelloDataReady.bind(this));\n+    this.model.event.addListener('onLoadTrelloListSuccess', this.handleLoadTrelloListSuccess.bind(this));\n+    this.model.event.addListener('onLoadTrelloCardsSuccess', this.handleLoadTrelloCardsSuccess.bind(this));\n+    this.model.event.addListener('onLoadTrelloLabelsSuccess', this.handleLoadTrelloLabelsSuccess.bind(this));\n+    this.model.event.addListener('onLoadTrelloMembersSuccess', this.handleLoadTrelloMembersSuccess.bind(this));\n+    this.model.event.addListener('onCardSubmitComplete', this.handleCardSubmitComplete.bind(this));\n+    this.model.event.addListener('onAPIFailure', this.handleAPIFailure.bind(this));\n+\n+    /*** PopupView's events binding ***/\n+    this.popupView.event.addListener('onPopupVisible', this.handlePopupVisible.bind(this));\n+    this.popupView.event.addListener('periodicChecks', this.handlePeriodicChecks.bind(this));\n+    this.popupView.event.addListener('onBoardChanged', this.handleBoardChanged.bind(this));\n+    this.popupView.event.addListener('onListChanged', this.handleListChanged.bind(this));\n+    this.popupView.event.addListener('onSubmit', this.handleSubmit.bind(this));\n+    this.popupView.event.addListener('checkTrelloAuthorized', this.handleCheckTrelloAuthorized.bind(this));\n+    this.popupView.event.addListener('onRequestDeauthorizeTrello', this.handleRequestDeauthorizeTrello.bind(this));\n+    this.popupView.event.addListener('detectButton', this.handleDetectButton.bind(this));\n+\n+    // GMailView's events:\n+    this.gmailView.event.addListener('onDetected', this.handleGmailDetected.bind(this));\n+    this.gmailView.event.addListener('detectButton', this.handleDetectButton.bind(this));\n+\n+    chrome.runtime.onMessage.addListener(this.handleRuntimeMessage.bind(this));\n+  }\n+\n+  // Event handler methods\n+  handleBeforeAuthorize() {\n+    this.popupView.bindData(''); // Intentionally blank\n+    this.popupView.showMessage(this, 'Authorizing...');\n+  }\n+\n+  handleAuthorizeFail() {\n+    this.popupView.showMessage(\n+      this,\n+      'Trello authorization failed <button id=\"showsignout\">Sign out and try again</button>'\n+    );\n+  }\n+\n+  handleAuthorized() {\n+    this.popupView.$popupContent.show();\n+    this.popupView.hideMessage();\n+  }\n+\n+  handleBeforeLoadTrello() {\n+    this.popupView.showMessage(this, 'Loading Trello data...');\n+  }\n+\n+  handleTrelloDataReady() {\n+    this.popupView.$popupContent.show();\n+    this.popupView.hideMessage();\n+    this.popupView.bindData(this.model);\n+  }\n+\n+  handleLoadTrelloListSuccess() {\n+    this.popupView.updateLists();\n+    this.popupView.validateData();\n+  }\n+\n+  handleLoadTrelloCardsSuccess() {\n+    this.popupView.updateCards();\n+    this.popupView.validateData();\n+  }\n+\n+  handleLoadTrelloLabelsSuccess() {\n+    this.popupView.updateLabels();\n+    this.popupView.validateData();\n+  }\n+\n+  handleLoadTrelloMembersSuccess() {\n+    this.popupView.updateMembers();\n+    this.popupView.validateData();\n+  }\n+\n+  handleCardSubmitComplete(target, params) {\n+    this.popupView.displaySubmitCompleteForm();\n+    // If card lists or labels have been updated, reload:\n+    const data_k = params?.data || {};\n+    const emailId = data_k?.emailId || 0;\n+    const boardId_k = data_k?.data?.board?.id || 0;\n+    const listId_k = data_k?.data?.list?.id || 0;\n+    const cardId_k = data_k?.data?.card?.id || 0;\n+    const idBoard_k = data_k?.idBoard || 0;\n+    const idList_k = data_k?.idList || 0;\n+    const idCard_k = data_k?.idCard || 0;\n+    const boardId = boardId_k || idBoard_k || 0;\n+    const listId = listId_k || idList_k || 0;\n+    const cardId = cardId_k || idCard_k || 0;\n+    // NOTE (acoven@2020-05-23): Users expect when creating a brand new card,\n+    // we'll remember that new card ID and then keep defaulting to it for\n+    // subsequent updates to that email. That means we'll have to get the return\n+    // value/url from Trello and dissect that, potentially doing this update\n+    // in that routine:\n+    this.model.emailBoardListCardMapUpdate({\n+      emailId,\n+      boardId,\n+      listId,\n+      cardId,\n+    });\n+\n+    if (boardId) {\n+      this.model.loadTrelloLabels(boardId);\n+      this.model.loadTrelloMembers(boardId);\n+    }\n+    if (listId) {\n+      this.model.loadTrelloCards(listId);\n+    }\n+  }\n+\n+  handleAPIFailure(target, params) {\n+    this.popupView.displayAPIFailedForm(params);\n+  }\n+\n+  handlePopupVisible() {\n+    if (!this.model.isInitialized) {\n+      this.popupView.showMessage(this, 'Initializing...');\n+      this.popupView.$popupContent.hide();\n+      this.model.init();\n+    } else {\n+      this.popupView.reset();\n+    }\n+\n+    const trelloUser_k = this?.model?.trello?.user || {};\n+    const fullName = trelloUser_k?.fullName || '';\n+\n+    this.gmailView.parsingData = false;\n+    this.model.gmail = this.gmailView.parseData({ fullName });\n+    this.popupView.bindGmailData(this.model.gmail);\n+    this.popupView.event.fire('periodicChecks');\n+  }\n+\n+  handlePeriodicChecks() {\n+    setTimeout(() => {\n+      this.popupView.periodicChecks();\n+    }, 3000);\n+  }\n+\n+  handleBoardChanged(target, params) {\n+    let boardId = params.boardId;\n+    if (boardId !== '_' && boardId !== '' && boardId !== null) {\n+      this.model.loadTrelloLists(boardId);\n+      this.model.loadTrelloLabels(boardId);\n+      this.model.loadTrelloMembers(boardId);\n+    }\n+  }\n+\n+  handleListChanged(target, params) {\n+    let listId = params.listId;\n+    this.model.loadTrelloCards(listId);\n+  }\n+\n+  handleSubmit() {\n+    this.model.submit();\n+  }\n+\n+  handleCheckTrelloAuthorized() {\n+    this.popupView.showMessage(this, 'Authorizing...');\n+    this.model.checkTrelloAuthorized();\n+  }\n+\n+  handleRequestDeauthorizeTrello() {\n+    g2t_log('onRequestDeauthorizeTrello');\n+    this.model.deauthorizeTrello();\n+    this.popupView.clearBoard();\n+  }\n+\n+  handleDetectButton() {\n+    if (this.gmailView.preDetect()) {\n+      this.popupView.$toolBar = this.gmailView.$toolBar;\n+      this.popupView.confirmPopup();\n+    }\n+  }\n+\n+  handleGmailDetected() {\n+    this.popupView.$toolBar = this.gmailView.$toolBar;\n+    this.popupView.init();\n+  }\n+\n+  handleRuntimeMessage(request, sender, sendResponse) {\n+    if (request?.message === 'g2t_keyboard_shortcut') {\n+      this.popupView.showPopup();\n+    }\n+  }\n+\n+  updateData() {\n+    const self = this;\n+\n+    const fullName = self?.model?.trello?.user?.fullName || '';\n+\n+    self.popupView.bindData(self.model);\n+\n+    self.gmailView.parsingData = false;\n+    self.model.gmail = self.gmailView.parseData({ fullName });\n+    self.popupView.bindGmailData(self.model.gmail);\n+  }\n+\n+  initialize() {\n+    const self = this;\n+\n+    this.model.isInitialized = false;\n+\n+    // g2t_log('App:initialize');\n+\n+    this.gmailView.detect();\n+\n+    service = analytics.getService('gmail-2-trello');\n+\n+    // Get a Tracker using your Google Analytics app Tracking ID.\n+    tracker = service.getTracker('G-0QPEDL7YDL'); // Was: UA-8469046-1 -> UA-42442437-4\n+\n+    // Record an \"appView\" each time the user launches your app or goes to a new\n+    // screen within the app.\n+    tracker.sendAppView('PopupView');\n+  }\n+\n+  /**\n+   * Correctly escape RegExp\n+   */\n+  escapeRegExp(str) {\n+    return str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n+  }\n+\n+  /**\n+   * Utility routine to replace variables\n+   */\n+  replacer(text, dict) {\n+    let self = this;\n+\n+    if (!text || text.length < 1) {\n+      // g2t_log('Require text!');\n+      return '';\n+    } else if (!dict || dict.length < 2) {\n+      g2t_log('replacer: Require dictionary!');\n+      return text;\n+    }\n+\n+    let re, new_text;\n+    const replacify = function () {\n+      g2t_each(dict, function (value, key) {\n+        re = new RegExp(`%${self.escapeRegExp(key)}%`, 'gi');\n+        new_text = text.replace(re, value);\n+        text = new_text;\n+      });\n+    };\n+\n+    let runaway_max = 3;\n+    while (text.indexOf('%') !== -1 && runaway_max-- > 0) {\n+      replacify();\n+    }\n+\n+    return text;\n+  }\n+\n+  /**\n+   * Make displayable URI\n+   */\n+  uriForDisplay(uri) {\n+    const uri_display_trigger_length_k = 20;\n+    const uri_length_max_k = 40;\n+    let uri_display = uri || '';\n+    if (uri_display.length > uri_display_trigger_length_k) {\n+      let re = RegExp('^\\\\w+://([\\\\w./_-]+).*?([\\\\w._-]*)$');\n+      let matched = uri_display.match(re);\n+      if (matched && matched.length > 1) {\n+        const filename_k =\n+          matched[2].length < uri_length_max_k\n+            ? matched[2]\n+            : matched[2].slice(-uri_length_max_k);\n+        let prelude = matched[1].substr(0, uri_length_max_k);\n+        if (matched[1].length > uri_length_max_k) {\n+          prelude += '...';\n+        } else if (filename_k.length > 0) {\n+          prelude += ':';\n+        }\n+\n+        uri_display = prelude + filename_k;\n+      }\n+    }\n+    return uri_display;\n+  }\n+\n+  /**\n+   * Make anchored backlink\n+   */\n+  anchorMarkdownify(text, href, comment) {\n+    let text1 = (text || '').trim();\n+    let text1lc = text1.toLowerCase();\n+    let href1 = (href || '').trim();\n+    let href1lc = href1.toLowerCase();\n+    let comment1 = (comment || '').trim();\n+\n+    let retn = '';\n+\n+    if (text1.length < 1 && href1.length < 1) {\n+      // Intetionally blank\n+    } else if (text1lc === href1lc) {\n+      retn = ` <${href1}> `; // This renders correctly in Trello as a sole URL\n+      // NOTE (Ace, 17-Feb-2017): Turns out Trello doesn't support markdown [] only, so we'll construct a nice displayable text vs url:\n+      // text1 = this.uriForDisplay(text1);\n+    } else if (`mailto:${text1lc}` === href1lc) {\n+      retn = ` <${text1}> `; // This renders correctly in Trello as a mailto: url\n+    } else {\n+      const comment1QuotedSpaced = comment1.length > 0 ? ` \"${comment1}\"` : '';\n+      retn = ` [${text1}](<${href1}>${comment1QuotedSpaced}) `;\n+    }\n+\n+    return retn;\n+  }\n+\n+  /**\n+   * Split an email into name and domain\n+   */\n+  splitEmailDomain(email = '') {\n+    const split = email.split('@');\n+    const name = split[0] || '';\n+    const domain = split[1] || '';\n+    return {\n+      name,\n+      domain,\n+    };\n+  }\n+\n+  /**\n+   * Add trailing char if not empty:\n+   */\n+  addChar(front = '', back = '', addChar = ' ') {\n+    if (front.length > 0) {\n+      if (back.length > 0) {\n+        return `${front}${addChar}${back}`;\n+      } else {\n+        return `${front}${addChar}`;\n+      }\n+    } else if (back.length > 0) {\n+      return `${addChar}${back}`;\n+    } else {\n+      return '';\n+    }\n+  }\n+\n+  /**\n+   * Add trailing space if not empty:\n+   */\n+  addSpace(front = '', back = '') {\n+    return this.addChar(front, back, ' ');\n+  }\n+\n+  /**\n+   * Add trailing CRLF if not empty:\n+   */\n+  addCRLF(front = '', back = '') {\n+    return this.addChar(front, back, '\\n');\n+  }\n+\n+  /**\n+   * Markdownify a text block\n+   */\n+  markdownify($emailBody, features, preprocess) {\n+    if (!$emailBody || $emailBody.length < 1) {\n+      g2t_log('markdownify: Require emailBody!');\n+      return;\n+    }\n+    const self = this;\n+\n+    const min_text_length_k = 4;\n+    const max_replace_attempts_k = 10;\n+    const regexp_k = {\n+      begin: '(^|\\\\s+|<|\\\\[|\\\\(|\\\\b|(?=\\\\W+))',\n+      end: '($|\\\\s+|>|\\\\]|\\\\)|\\\\b|(?=\\\\W+))',\n+    };\n+    const unique_placeholder_k = 'g2t_placeholder:'; // Unique placeholder tag\n+\n+    let count = 0;\n+    let replacer_dict = {};\n+\n+    const featureEnabled = (elementTag = '') =>\n+      features === false ? false : features?.[elementTag] !== false;\n+\n+    let $html = $emailBody || ''; // Was: $emailBody.innerHTML || \"\";",
    "path": "chrome_manifest_v3/class_app.js",
    "commit_id": "3bbc7b0b5b5abfda366260c45d6f2cecebf28af3",
    "original_commit_id": "f609e1322b9a0f1b03b7094863f0c64a967e9df2",
    "user": {
      "login": "coderabbitai[bot]",
      "id": 136622811,
      "node_id": "BOT_kgDOCCSy2w",
      "avatar_url": "https://avatars.githubusercontent.com/in/347564?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/coderabbitai%5Bbot%5D",
      "html_url": "https://github.com/apps/coderabbitai",
      "followers_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "_🧹 Nitpick (assertive)_\n\n**Use const.**\n\n```diff\n-    let $html = $emailBody || ''; // Was: $emailBody.innerHTML || \"\";\n+    const $html = $emailBody || ''; // Was: $emailBody.innerHTML || \"\";\n```\n\nNext?\n\n<!-- suggestion_start -->\n\n<details>\n<summary>📝 Committable suggestion</summary>\n\n> ‼️ **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n    const $html = $emailBody || ''; // Was: $emailBody.innerHTML || \"\";\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>🧰 Tools</summary>\n\n<details>\n<summary>🪛 Biome (1.9.4)</summary>\n\n[error] 400-400: This let declares a variable that is only assigned once.\n\n'$html' is never reassigned.\n\nSafe fix: Use const instead.\n\n\n(lint/style/useConst)\n\n</details>\n\n</details>\n\n<details>\n<summary>🤖 Prompt for AI Agents</summary>\n\n```\nIn chrome_manifest_v3/class_app.js at line 400, the variable $html is declared\nwith let but it is not reassigned later. Change the declaration from let to\nconst to follow best practices for immutable variables.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:lion -->\n\n<!-- This is an auto-generated reply by CodeRabbit -->",
    "created_at": "2025-07-14T01:54:40Z",
    "updated_at": "2025-07-14T04:51:10Z",
    "html_url": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203704189",
    "pull_request_url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203704189"
      },
      "html": {
        "href": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203704189"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203704189/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 400,
    "side": "RIGHT",
    "original_position": 400,
    "position": null,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203704190",
    "pull_request_review_id": 3014554580,
    "id": 2203704190,
    "node_id": "PRRC_kwDOD1hYKM6DWdt-",
    "diff_hunk": "@@ -0,0 +1,852 @@\n+/** Gmail2Trello Application - ES6 Class Version\n+ */\n+\n+var Gmail2Trello = Gmail2Trello || {}; // Namespace initialization - must be var to guarantee correct scope\n+\n+class App {\n+  constructor() {\n+    this.CHROME_SETTINGS_ID = 'g2t_user_settings';\n+    this.UNIQUE_URI_VAR = 'g2t_filename';\n+\n+    this.model = new Gmail2Trello.Model(this);\n+    this.gmailView = new Gmail2Trello.GmailView(this);\n+    this.popupView = new Gmail2Trello.PopupView(this);\n+\n+    this.bindEvents();\n+  }\n+\n+  bindEvents() {\n+    /*** Data's events binding ***/\n+    this.model.event.addListener('onBeforeAuthorize', this.handleBeforeAuthorize.bind(this));\n+    this.model.event.addListener('onAuthorizeFail', this.handleAuthorizeFail.bind(this));\n+    this.model.event.addListener('onAuthorized', this.handleAuthorized.bind(this));\n+    this.model.event.addListener('onBeforeLoadTrello', this.handleBeforeLoadTrello.bind(this));\n+    this.model.event.addListener('onTrelloDataReady', this.handleTrelloDataReady.bind(this));\n+    this.model.event.addListener('onLoadTrelloListSuccess', this.handleLoadTrelloListSuccess.bind(this));\n+    this.model.event.addListener('onLoadTrelloCardsSuccess', this.handleLoadTrelloCardsSuccess.bind(this));\n+    this.model.event.addListener('onLoadTrelloLabelsSuccess', this.handleLoadTrelloLabelsSuccess.bind(this));\n+    this.model.event.addListener('onLoadTrelloMembersSuccess', this.handleLoadTrelloMembersSuccess.bind(this));\n+    this.model.event.addListener('onCardSubmitComplete', this.handleCardSubmitComplete.bind(this));\n+    this.model.event.addListener('onAPIFailure', this.handleAPIFailure.bind(this));\n+\n+    /*** PopupView's events binding ***/\n+    this.popupView.event.addListener('onPopupVisible', this.handlePopupVisible.bind(this));\n+    this.popupView.event.addListener('periodicChecks', this.handlePeriodicChecks.bind(this));\n+    this.popupView.event.addListener('onBoardChanged', this.handleBoardChanged.bind(this));\n+    this.popupView.event.addListener('onListChanged', this.handleListChanged.bind(this));\n+    this.popupView.event.addListener('onSubmit', this.handleSubmit.bind(this));\n+    this.popupView.event.addListener('checkTrelloAuthorized', this.handleCheckTrelloAuthorized.bind(this));\n+    this.popupView.event.addListener('onRequestDeauthorizeTrello', this.handleRequestDeauthorizeTrello.bind(this));\n+    this.popupView.event.addListener('detectButton', this.handleDetectButton.bind(this));\n+\n+    // GMailView's events:\n+    this.gmailView.event.addListener('onDetected', this.handleGmailDetected.bind(this));\n+    this.gmailView.event.addListener('detectButton', this.handleDetectButton.bind(this));\n+\n+    chrome.runtime.onMessage.addListener(this.handleRuntimeMessage.bind(this));\n+  }\n+\n+  // Event handler methods\n+  handleBeforeAuthorize() {\n+    this.popupView.bindData(''); // Intentionally blank\n+    this.popupView.showMessage(this, 'Authorizing...');\n+  }\n+\n+  handleAuthorizeFail() {\n+    this.popupView.showMessage(\n+      this,\n+      'Trello authorization failed <button id=\"showsignout\">Sign out and try again</button>'\n+    );\n+  }\n+\n+  handleAuthorized() {\n+    this.popupView.$popupContent.show();\n+    this.popupView.hideMessage();\n+  }\n+\n+  handleBeforeLoadTrello() {\n+    this.popupView.showMessage(this, 'Loading Trello data...');\n+  }\n+\n+  handleTrelloDataReady() {\n+    this.popupView.$popupContent.show();\n+    this.popupView.hideMessage();\n+    this.popupView.bindData(this.model);\n+  }\n+\n+  handleLoadTrelloListSuccess() {\n+    this.popupView.updateLists();\n+    this.popupView.validateData();\n+  }\n+\n+  handleLoadTrelloCardsSuccess() {\n+    this.popupView.updateCards();\n+    this.popupView.validateData();\n+  }\n+\n+  handleLoadTrelloLabelsSuccess() {\n+    this.popupView.updateLabels();\n+    this.popupView.validateData();\n+  }\n+\n+  handleLoadTrelloMembersSuccess() {\n+    this.popupView.updateMembers();\n+    this.popupView.validateData();\n+  }\n+\n+  handleCardSubmitComplete(target, params) {\n+    this.popupView.displaySubmitCompleteForm();\n+    // If card lists or labels have been updated, reload:\n+    const data_k = params?.data || {};\n+    const emailId = data_k?.emailId || 0;\n+    const boardId_k = data_k?.data?.board?.id || 0;\n+    const listId_k = data_k?.data?.list?.id || 0;\n+    const cardId_k = data_k?.data?.card?.id || 0;\n+    const idBoard_k = data_k?.idBoard || 0;\n+    const idList_k = data_k?.idList || 0;\n+    const idCard_k = data_k?.idCard || 0;\n+    const boardId = boardId_k || idBoard_k || 0;\n+    const listId = listId_k || idList_k || 0;\n+    const cardId = cardId_k || idCard_k || 0;\n+    // NOTE (acoven@2020-05-23): Users expect when creating a brand new card,\n+    // we'll remember that new card ID and then keep defaulting to it for\n+    // subsequent updates to that email. That means we'll have to get the return\n+    // value/url from Trello and dissect that, potentially doing this update\n+    // in that routine:\n+    this.model.emailBoardListCardMapUpdate({\n+      emailId,\n+      boardId,\n+      listId,\n+      cardId,\n+    });\n+\n+    if (boardId) {\n+      this.model.loadTrelloLabels(boardId);\n+      this.model.loadTrelloMembers(boardId);\n+    }\n+    if (listId) {\n+      this.model.loadTrelloCards(listId);\n+    }\n+  }\n+\n+  handleAPIFailure(target, params) {\n+    this.popupView.displayAPIFailedForm(params);\n+  }\n+\n+  handlePopupVisible() {\n+    if (!this.model.isInitialized) {\n+      this.popupView.showMessage(this, 'Initializing...');\n+      this.popupView.$popupContent.hide();\n+      this.model.init();\n+    } else {\n+      this.popupView.reset();\n+    }\n+\n+    const trelloUser_k = this?.model?.trello?.user || {};\n+    const fullName = trelloUser_k?.fullName || '';\n+\n+    this.gmailView.parsingData = false;\n+    this.model.gmail = this.gmailView.parseData({ fullName });\n+    this.popupView.bindGmailData(this.model.gmail);\n+    this.popupView.event.fire('periodicChecks');\n+  }\n+\n+  handlePeriodicChecks() {\n+    setTimeout(() => {\n+      this.popupView.periodicChecks();\n+    }, 3000);\n+  }\n+\n+  handleBoardChanged(target, params) {\n+    let boardId = params.boardId;\n+    if (boardId !== '_' && boardId !== '' && boardId !== null) {\n+      this.model.loadTrelloLists(boardId);\n+      this.model.loadTrelloLabels(boardId);\n+      this.model.loadTrelloMembers(boardId);\n+    }\n+  }\n+\n+  handleListChanged(target, params) {\n+    let listId = params.listId;\n+    this.model.loadTrelloCards(listId);\n+  }\n+\n+  handleSubmit() {\n+    this.model.submit();\n+  }\n+\n+  handleCheckTrelloAuthorized() {\n+    this.popupView.showMessage(this, 'Authorizing...');\n+    this.model.checkTrelloAuthorized();\n+  }\n+\n+  handleRequestDeauthorizeTrello() {\n+    g2t_log('onRequestDeauthorizeTrello');\n+    this.model.deauthorizeTrello();\n+    this.popupView.clearBoard();\n+  }\n+\n+  handleDetectButton() {\n+    if (this.gmailView.preDetect()) {\n+      this.popupView.$toolBar = this.gmailView.$toolBar;\n+      this.popupView.confirmPopup();\n+    }\n+  }\n+\n+  handleGmailDetected() {\n+    this.popupView.$toolBar = this.gmailView.$toolBar;\n+    this.popupView.init();\n+  }\n+\n+  handleRuntimeMessage(request, sender, sendResponse) {\n+    if (request?.message === 'g2t_keyboard_shortcut') {\n+      this.popupView.showPopup();\n+    }\n+  }\n+\n+  updateData() {\n+    const self = this;\n+\n+    const fullName = self?.model?.trello?.user?.fullName || '';\n+\n+    self.popupView.bindData(self.model);\n+\n+    self.gmailView.parsingData = false;\n+    self.model.gmail = self.gmailView.parseData({ fullName });\n+    self.popupView.bindGmailData(self.model.gmail);\n+  }\n+\n+  initialize() {\n+    const self = this;\n+\n+    this.model.isInitialized = false;\n+\n+    // g2t_log('App:initialize');\n+\n+    this.gmailView.detect();\n+\n+    service = analytics.getService('gmail-2-trello');\n+\n+    // Get a Tracker using your Google Analytics app Tracking ID.\n+    tracker = service.getTracker('G-0QPEDL7YDL'); // Was: UA-8469046-1 -> UA-42442437-4\n+\n+    // Record an \"appView\" each time the user launches your app or goes to a new\n+    // screen within the app.\n+    tracker.sendAppView('PopupView');\n+  }\n+\n+  /**\n+   * Correctly escape RegExp\n+   */\n+  escapeRegExp(str) {\n+    return str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n+  }\n+\n+  /**\n+   * Utility routine to replace variables\n+   */\n+  replacer(text, dict) {\n+    let self = this;\n+\n+    if (!text || text.length < 1) {\n+      // g2t_log('Require text!');\n+      return '';\n+    } else if (!dict || dict.length < 2) {\n+      g2t_log('replacer: Require dictionary!');\n+      return text;\n+    }\n+\n+    let re, new_text;\n+    const replacify = function () {\n+      g2t_each(dict, function (value, key) {\n+        re = new RegExp(`%${self.escapeRegExp(key)}%`, 'gi');\n+        new_text = text.replace(re, value);\n+        text = new_text;\n+      });\n+    };\n+\n+    let runaway_max = 3;\n+    while (text.indexOf('%') !== -1 && runaway_max-- > 0) {\n+      replacify();\n+    }\n+\n+    return text;\n+  }\n+\n+  /**\n+   * Make displayable URI\n+   */\n+  uriForDisplay(uri) {\n+    const uri_display_trigger_length_k = 20;\n+    const uri_length_max_k = 40;\n+    let uri_display = uri || '';\n+    if (uri_display.length > uri_display_trigger_length_k) {\n+      let re = RegExp('^\\\\w+://([\\\\w./_-]+).*?([\\\\w._-]*)$');\n+      let matched = uri_display.match(re);\n+      if (matched && matched.length > 1) {\n+        const filename_k =\n+          matched[2].length < uri_length_max_k\n+            ? matched[2]\n+            : matched[2].slice(-uri_length_max_k);\n+        let prelude = matched[1].substr(0, uri_length_max_k);\n+        if (matched[1].length > uri_length_max_k) {\n+          prelude += '...';\n+        } else if (filename_k.length > 0) {\n+          prelude += ':';\n+        }\n+\n+        uri_display = prelude + filename_k;\n+      }\n+    }\n+    return uri_display;\n+  }\n+\n+  /**\n+   * Make anchored backlink\n+   */\n+  anchorMarkdownify(text, href, comment) {\n+    let text1 = (text || '').trim();\n+    let text1lc = text1.toLowerCase();\n+    let href1 = (href || '').trim();\n+    let href1lc = href1.toLowerCase();\n+    let comment1 = (comment || '').trim();\n+\n+    let retn = '';\n+\n+    if (text1.length < 1 && href1.length < 1) {\n+      // Intetionally blank\n+    } else if (text1lc === href1lc) {\n+      retn = ` <${href1}> `; // This renders correctly in Trello as a sole URL\n+      // NOTE (Ace, 17-Feb-2017): Turns out Trello doesn't support markdown [] only, so we'll construct a nice displayable text vs url:\n+      // text1 = this.uriForDisplay(text1);\n+    } else if (`mailto:${text1lc}` === href1lc) {\n+      retn = ` <${text1}> `; // This renders correctly in Trello as a mailto: url\n+    } else {\n+      const comment1QuotedSpaced = comment1.length > 0 ? ` \"${comment1}\"` : '';\n+      retn = ` [${text1}](<${href1}>${comment1QuotedSpaced}) `;\n+    }\n+\n+    return retn;\n+  }\n+\n+  /**\n+   * Split an email into name and domain\n+   */\n+  splitEmailDomain(email = '') {\n+    const split = email.split('@');\n+    const name = split[0] || '';\n+    const domain = split[1] || '';\n+    return {\n+      name,\n+      domain,\n+    };\n+  }\n+\n+  /**\n+   * Add trailing char if not empty:\n+   */\n+  addChar(front = '', back = '', addChar = ' ') {\n+    if (front.length > 0) {\n+      if (back.length > 0) {\n+        return `${front}${addChar}${back}`;\n+      } else {\n+        return `${front}${addChar}`;\n+      }\n+    } else if (back.length > 0) {\n+      return `${addChar}${back}`;\n+    } else {\n+      return '';\n+    }\n+  }\n+\n+  /**\n+   * Add trailing space if not empty:\n+   */\n+  addSpace(front = '', back = '') {\n+    return this.addChar(front, back, ' ');\n+  }\n+\n+  /**\n+   * Add trailing CRLF if not empty:\n+   */\n+  addCRLF(front = '', back = '') {\n+    return this.addChar(front, back, '\\n');\n+  }\n+\n+  /**\n+   * Markdownify a text block\n+   */\n+  markdownify($emailBody, features, preprocess) {\n+    if (!$emailBody || $emailBody.length < 1) {\n+      g2t_log('markdownify: Require emailBody!');\n+      return;\n+    }\n+    const self = this;\n+\n+    const min_text_length_k = 4;\n+    const max_replace_attempts_k = 10;\n+    const regexp_k = {\n+      begin: '(^|\\\\s+|<|\\\\[|\\\\(|\\\\b|(?=\\\\W+))',\n+      end: '($|\\\\s+|>|\\\\]|\\\\)|\\\\b|(?=\\\\W+))',\n+    };\n+    const unique_placeholder_k = 'g2t_placeholder:'; // Unique placeholder tag\n+\n+    let count = 0;\n+    let replacer_dict = {};\n+\n+    const featureEnabled = (elementTag = '') =>\n+      features === false ? false : features?.[elementTag] !== false;\n+\n+    let $html = $emailBody || ''; // Was: $emailBody.innerHTML || \"\";\n+    // let body = $emailBody.text() || \"\";\n+    let body = $emailBody.html() || '';\n+\n+    // Different encodings handle CRLF differently, so we'll process the main body as html and convert to text:\n+    // Convert paragraph marker to two returns:\n+    let replaced = body.replace(/\\s*[\\n\\r]*<p[^>]*>\\s*[\\n\\r]*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // Convert br marker to one return:\n+    replaced = body.replace(/\\s*[\\n\\r]*<br[^>]*>\\s*[\\n\\r]*/g, '\\n');\n+    body = replaced;\n+\n+    // Remove all other html markers:\n+    replaced = body.replace(/<[^>]*>/g, '');\n+    body = replaced;\n+\n+    // Decode HTML entities:\n+    replaced = self.decodeEntities(body);\n+    body = replaced;\n+\n+    // Replace hr:\n+    replaced = body.replace(/\\s*-{3,}\\s*/g, '---\\n');\n+    body = replaced;\n+\n+    // Convert crlf x 2 (or more) to paragraph markers:\n+    replaced = body.replace(/(\\s*[\\n\\r]\\s*){2,}/g, '<p />\\n');\n+    body = replaced;\n+\n+    let toProcess = {};\n+\n+    /**\n+     * 5 explicit steps in 3 passes:\n+     * (1) Collect tagged items\n+     * (2) Remove duplicates\n+     * (3) Sort force-lowercase by length\n+     * (4) Replace with placeholder\n+     * (5) Replace placeholders with final text\n+     */\n+    const sortAndPlaceholderize = function (tooProcess) {\n+      if (tooProcess) {\n+        g2t_each(\n+          Object.keys(tooProcess).sort(function (a, b) {\n+            // Go by order of largest to smallest\n+            return b.length - a.length;\n+          }),\n+          function (value) {\n+            const replace = tooProcess[value];\n+            const swap = `${unique_placeholder_k}${(count++).toString()}`;\n+            const re = new RegExp(\n+              regexp_k.begin + self.escapeRegExp(value) + regexp_k.end,\n+              'gi'\n+            );\n+            const replaced = body.replace(re, `%${swap}%`); // Replace occurance with placeholder\n+            if (body !== replaced) {\n+              body = replaced;\n+              replacer_dict[swap] = replace;\n+            }\n+          }\n+        );\n+      }\n+    };\n+    const processMarkdown = function (elementTag, replaceText) {\n+      if (elementTag && replaceText && featureEnabled(elementTag)) {\n+        toProcess = preprocess[elementTag] || {};\n+        $(elementTag, $html).each(function (index, value) {\n+          let text = ($(this).text() || '').trim();\n+          if (text && text.length > min_text_length_k) {\n+            let replace = self.replacer(replaceText, { text: text });\n+            toProcess[text.toLowerCase()] = replace; // Intentionally overwrites duplicates\n+          }\n+        });\n+        sortAndPlaceholderize(toProcess);\n+      }\n+    };\n+    /**\n+     * Repeat replace for max attempts or when done, whatever comes first\n+     */\n+    const repeatReplace = function (body, inRegexp, replaceWith) {\n+      let replace1 = '';\n+      for (let iter = max_replace_attempts_k; iter > 0; iter--) {\n+        replace1 = body.replace(inRegexp, replaceWith);\n+        if (body === replace1) {\n+          iter = 0; // All done\n+        } else {\n+          body = replace1;\n+        }\n+      }\n+      return body;\n+    };\n+\n+    // bullet lists:\n+    // ul li -> \" * \"\n+    processMarkdown('ul li', '<p />* %text%<p />');\n+\n+    // numeric lists:\n+    // ol li -> \" 1. \"\n+    processMarkdown('ol li', '<p />1. %text%<p />');\n+\n+    // headers:\n+    // H1 -> #\n+    // H2 -> ##\n+    // H3 -> ###\n+    // H4 -> ####\n+    // H5 -> #####\n+    // H6 -> ######\n+    if (featureEnabled('h')) {\n+      toProcess = preprocess['h'] || {};\n+      $(':header', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let nodeName = $(this).prop('nodeName') || '0';\n+        if (nodeName && text && text.length > min_text_length_k) {\n+          let x = nodeName.substr(-1);\n+          toProcess[text.toLowerCase()] = `\\n${'#'.repeat(x)} ${text}\\n`; // Intentionally overwrites duplicates\n+        }\n+      });\n+      sortAndPlaceholderize(toProcess);\n+    }\n+\n+    replaced = this.replacer(body, replacer_dict); // Replace initial batch of <div> like placeholders\n+    body = replaced;\n+    replacer_dict = {}; // Reset\n+    count = 0; // Reset\n+\n+    // bold: b -> **text**\n+    processMarkdown('b', ' **%text%** ');\n+\n+    // italics: i -> _text_\n+    processMarkdown('i', ' _%text%_ ');\n+\n+    // links:\n+    // a -> [text](html)\n+    if (featureEnabled('a')) {\n+      toProcess = preprocess['a'] || {};\n+      $('a', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let href = ($(this).prop('href') || '').trim(); // Was attr\n+        /*\n+              var uri_display = self.uriForDisplay(href);\n+              var comment = ' \"' + text + ' via ' + uri_display + '\"';\n+              var re = new RegExp(self.escapeRegExp(text), \"i\");\n+              if (uri.match(re)) {\n+                  comment = ' \"Open ' + uri_display + '\"';\n+              }\n+              */\n+        if (href && text && text.length >= min_text_length_k) {\n+          toProcess[text.toLowerCase()] = self.anchorMarkdownify(text, href); // Comment seemed like too much extra text // Intentionally overwrites duplicates\n+        }\n+      });\n+      sortAndPlaceholderize(toProcess);\n+    }\n+\n+    /* DISABLED (Ace, 16-Jan-2017): Images kinda make a mess, until requested lets not markdownify them:\n+      // images:\n+      // img -> ![alt_text](html)\n+      if (featureEnabled('img')) {\n+          $('img', $html).each(function(index, value) {\n+              var text = ($(this).prop(\"alt\") || \"\").trim(); // Was attr\n+              var href = ($(this).prop(\"src\") || \"\").trim(); // Was attr\n+              // var uri_display = self.uriForDisplay(href);\n+              if (href && text && text.length >= min_text_length_k) {\n+                  toProcess[text.toLowerCase()] = self.anchorMarkdownify(text, href); // Comment seemed like too much extra text // Intentionally overwrites duplicates\n+              }\n+          });\n+          sortAndPlaceholderize(toProcess);\n+      }\n+      */\n+\n+    replaced = this.replacer(body, replacer_dict); // Replace second batch of <span> like placeholders\n+    body = replaced;\n+\n+    // Replace bullets following a CRLF:\n+    replaced = body.replace(/\\s*[\\n\\r]+\\s*[·-]+\\s*/g, '<p />* '); // = [\\u00B7\\u2022]\n+    body = replaced;\n+\n+    // Replace remaining bullets with asterisks:\n+    replaced = body.replace(/[·]/g, '*');\n+    body = replaced;\n+\n+    // ORDER MATTERS FOR THIS NEXT SET:\n+    // (1) Replace <space>CRLF<space> with just CR:\n+    replaced = body.replace(/\\s*[\\n\\r]+\\s*/g, '\\n');\n+    body = replaced;\n+\n+    // (2) Replace 2 or more spaces with just one:\n+    replaced = repeatReplace(body, new RegExp('\\\\s{2,}', 'g'), ' ');\n+    body = replaced;\n+\n+    // (3) Replace paragraph markers with CR+CR:\n+    replaced = body.replace(/\\s*<p \\/>\\s*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // (4) Replace 3 or more CRs with just two:\n+    replaced = repeatReplace(body, new RegExp('\\\\n{3,}', 'g'), '\\n\\n');\n+    body = replaced;\n+\n+    // (5) Trim excess at beginning and end:\n+    replaced = body.trim();\n+    body = replaced;\n+\n+    return body;\n+  }\n+\n+  /**\n+   * Determine luminance of a color so we can augment with darker/lighter background\n+   */\n+  luminance(color) {\n+    let bkColorLight = 'lightGray'; // or white\n+    let bkColorDark = 'darkGray'; // 'gray' is even darker\n+    let bkColorReturn = bkColorLight;\n+\n+    let re = new RegExp('rgb\\\\D+(\\\\d+)\\\\D+(\\\\d+)\\\\D+(\\\\d+)');\n+    let matched = color.match(re, 'i');\n+    if (matched && matched.length > 2) {\n+      // 0 is total string:\n+      let r = matched[1];\n+      let g = matched[2];\n+      let b = matched[3];\n+      // var 1 = matched[4]; // if alpha is provided\n+\n+      let luma = 0.2126 * r + 0.7152 * g + 0.0722 * b; // per ITU-R BT.709\n+\n+      if (luma < 40) {\n+        bkColorReturn = bkColorDark;\n+      } else {\n+        bkColorReturn = bkColorLight;\n+      }\n+    } else {\n+      bkColorReturn = bkColorLight; // RegExp failed, assume dark color\n+    }\n+\n+    return 'inherit'; // Use: bkColorReturn if you want to adjust background based on text perceived brightness\n+  }\n+\n+  /**\n+   * HTML bookend a string\n+   */\n+  bookend(bookend, text, style) {\n+    return (\n+      '<' +\n+      bookend +\n+      (style ? ' style=\"' + style + '\"' : '') +\n+      '>' +\n+      (text || '') +\n+      '</' +\n+      bookend +\n+      '>'\n+    );\n+  }\n+\n+  /**\n+   * Get selected text\n+   * http://stackoverflow.com/questions/5379120/get-the-highlighted-selected-text\n+   */\n+  getSelectedText() {\n+    let text = '';\n+    let activeEl = document.activeElement;\n+    let activeElTagName = activeEl ? activeEl.tagName.toLowerCase() : null;",
    "path": "chrome_manifest_v3/class_app.js",
    "commit_id": "3bbc7b0b5b5abfda366260c45d6f2cecebf28af3",
    "original_commit_id": "f609e1322b9a0f1b03b7094863f0c64a967e9df2",
    "user": {
      "login": "coderabbitai[bot]",
      "id": 136622811,
      "node_id": "BOT_kgDOCCSy2w",
      "avatar_url": "https://avatars.githubusercontent.com/in/347564?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/coderabbitai%5Bbot%5D",
      "html_url": "https://github.com/apps/coderabbitai",
      "followers_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "_🧹 Nitpick (assertive)_\n\n**Never reassigned. Const.**\n\n```diff\n-    let activeEl = document.activeElement;\n-    let activeElTagName = activeEl ? activeEl.tagName.toLowerCase() : null;\n+    const activeEl = document.activeElement;\n+    const activeElTagName = activeEl ? activeEl.tagName.toLowerCase() : null;\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>📝 Committable suggestion</summary>\n\n> ‼️ **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n    const activeEl = document.activeElement;\n    const activeElTagName = activeEl ? activeEl.tagName.toLowerCase() : null;\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>🧰 Tools</summary>\n\n<details>\n<summary>🪛 Biome (1.9.4)</summary>\n\n[error] 656-656: This let declares a variable that is only assigned once.\n\n'activeEl' is never reassigned.\n\nSafe fix: Use const instead.\n\n\n(lint/style/useConst)\n\n---\n\n[error] 657-657: This let declares a variable that is only assigned once.\n\n'activeElTagName' is never reassigned.\n\nSafe fix: Use const instead.\n\n\n(lint/style/useConst)\n\n</details>\n\n</details>\n\n<details>\n<summary>🤖 Prompt for AI Agents</summary>\n\n```\nIn chrome_manifest_v3/class_app.js at lines 656 to 657, the variables activeEl\nand activeElTagName are never reassigned after initialization. Change their\ndeclarations from let to const to reflect their immutability and improve code\nclarity.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:lion -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->\n\n✅ Addressed in commits 53300ea to e74e240",
    "created_at": "2025-07-14T01:54:40Z",
    "updated_at": "2025-07-14T04:43:31Z",
    "html_url": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203704190",
    "pull_request_url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203704190"
      },
      "html": {
        "href": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203704190"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203704190/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 656,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 657,
    "side": "RIGHT",
    "original_position": 657,
    "position": null,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203704191",
    "pull_request_review_id": 3014554580,
    "id": 2203704191,
    "node_id": "PRRC_kwDOD1hYKM6DWdt_",
    "diff_hunk": "@@ -0,0 +1,852 @@\n+/** Gmail2Trello Application - ES6 Class Version\n+ */\n+\n+var Gmail2Trello = Gmail2Trello || {}; // Namespace initialization - must be var to guarantee correct scope\n+\n+class App {\n+  constructor() {\n+    this.CHROME_SETTINGS_ID = 'g2t_user_settings';\n+    this.UNIQUE_URI_VAR = 'g2t_filename';\n+\n+    this.model = new Gmail2Trello.Model(this);\n+    this.gmailView = new Gmail2Trello.GmailView(this);\n+    this.popupView = new Gmail2Trello.PopupView(this);\n+\n+    this.bindEvents();\n+  }\n+\n+  bindEvents() {\n+    /*** Data's events binding ***/\n+    this.model.event.addListener('onBeforeAuthorize', this.handleBeforeAuthorize.bind(this));\n+    this.model.event.addListener('onAuthorizeFail', this.handleAuthorizeFail.bind(this));\n+    this.model.event.addListener('onAuthorized', this.handleAuthorized.bind(this));\n+    this.model.event.addListener('onBeforeLoadTrello', this.handleBeforeLoadTrello.bind(this));\n+    this.model.event.addListener('onTrelloDataReady', this.handleTrelloDataReady.bind(this));\n+    this.model.event.addListener('onLoadTrelloListSuccess', this.handleLoadTrelloListSuccess.bind(this));\n+    this.model.event.addListener('onLoadTrelloCardsSuccess', this.handleLoadTrelloCardsSuccess.bind(this));\n+    this.model.event.addListener('onLoadTrelloLabelsSuccess', this.handleLoadTrelloLabelsSuccess.bind(this));\n+    this.model.event.addListener('onLoadTrelloMembersSuccess', this.handleLoadTrelloMembersSuccess.bind(this));\n+    this.model.event.addListener('onCardSubmitComplete', this.handleCardSubmitComplete.bind(this));\n+    this.model.event.addListener('onAPIFailure', this.handleAPIFailure.bind(this));\n+\n+    /*** PopupView's events binding ***/\n+    this.popupView.event.addListener('onPopupVisible', this.handlePopupVisible.bind(this));\n+    this.popupView.event.addListener('periodicChecks', this.handlePeriodicChecks.bind(this));\n+    this.popupView.event.addListener('onBoardChanged', this.handleBoardChanged.bind(this));\n+    this.popupView.event.addListener('onListChanged', this.handleListChanged.bind(this));\n+    this.popupView.event.addListener('onSubmit', this.handleSubmit.bind(this));\n+    this.popupView.event.addListener('checkTrelloAuthorized', this.handleCheckTrelloAuthorized.bind(this));\n+    this.popupView.event.addListener('onRequestDeauthorizeTrello', this.handleRequestDeauthorizeTrello.bind(this));\n+    this.popupView.event.addListener('detectButton', this.handleDetectButton.bind(this));\n+\n+    // GMailView's events:\n+    this.gmailView.event.addListener('onDetected', this.handleGmailDetected.bind(this));\n+    this.gmailView.event.addListener('detectButton', this.handleDetectButton.bind(this));\n+\n+    chrome.runtime.onMessage.addListener(this.handleRuntimeMessage.bind(this));\n+  }\n+\n+  // Event handler methods\n+  handleBeforeAuthorize() {\n+    this.popupView.bindData(''); // Intentionally blank\n+    this.popupView.showMessage(this, 'Authorizing...');\n+  }\n+\n+  handleAuthorizeFail() {\n+    this.popupView.showMessage(\n+      this,\n+      'Trello authorization failed <button id=\"showsignout\">Sign out and try again</button>'\n+    );\n+  }\n+\n+  handleAuthorized() {\n+    this.popupView.$popupContent.show();\n+    this.popupView.hideMessage();\n+  }\n+\n+  handleBeforeLoadTrello() {\n+    this.popupView.showMessage(this, 'Loading Trello data...');\n+  }\n+\n+  handleTrelloDataReady() {\n+    this.popupView.$popupContent.show();\n+    this.popupView.hideMessage();\n+    this.popupView.bindData(this.model);\n+  }\n+\n+  handleLoadTrelloListSuccess() {\n+    this.popupView.updateLists();\n+    this.popupView.validateData();\n+  }\n+\n+  handleLoadTrelloCardsSuccess() {\n+    this.popupView.updateCards();\n+    this.popupView.validateData();\n+  }\n+\n+  handleLoadTrelloLabelsSuccess() {\n+    this.popupView.updateLabels();\n+    this.popupView.validateData();\n+  }\n+\n+  handleLoadTrelloMembersSuccess() {\n+    this.popupView.updateMembers();\n+    this.popupView.validateData();\n+  }\n+\n+  handleCardSubmitComplete(target, params) {\n+    this.popupView.displaySubmitCompleteForm();\n+    // If card lists or labels have been updated, reload:\n+    const data_k = params?.data || {};\n+    const emailId = data_k?.emailId || 0;\n+    const boardId_k = data_k?.data?.board?.id || 0;\n+    const listId_k = data_k?.data?.list?.id || 0;\n+    const cardId_k = data_k?.data?.card?.id || 0;\n+    const idBoard_k = data_k?.idBoard || 0;\n+    const idList_k = data_k?.idList || 0;\n+    const idCard_k = data_k?.idCard || 0;\n+    const boardId = boardId_k || idBoard_k || 0;\n+    const listId = listId_k || idList_k || 0;\n+    const cardId = cardId_k || idCard_k || 0;\n+    // NOTE (acoven@2020-05-23): Users expect when creating a brand new card,\n+    // we'll remember that new card ID and then keep defaulting to it for\n+    // subsequent updates to that email. That means we'll have to get the return\n+    // value/url from Trello and dissect that, potentially doing this update\n+    // in that routine:\n+    this.model.emailBoardListCardMapUpdate({\n+      emailId,\n+      boardId,\n+      listId,\n+      cardId,\n+    });\n+\n+    if (boardId) {\n+      this.model.loadTrelloLabels(boardId);\n+      this.model.loadTrelloMembers(boardId);\n+    }\n+    if (listId) {\n+      this.model.loadTrelloCards(listId);\n+    }\n+  }\n+\n+  handleAPIFailure(target, params) {\n+    this.popupView.displayAPIFailedForm(params);\n+  }\n+\n+  handlePopupVisible() {\n+    if (!this.model.isInitialized) {\n+      this.popupView.showMessage(this, 'Initializing...');\n+      this.popupView.$popupContent.hide();\n+      this.model.init();\n+    } else {\n+      this.popupView.reset();\n+    }\n+\n+    const trelloUser_k = this?.model?.trello?.user || {};\n+    const fullName = trelloUser_k?.fullName || '';\n+\n+    this.gmailView.parsingData = false;\n+    this.model.gmail = this.gmailView.parseData({ fullName });\n+    this.popupView.bindGmailData(this.model.gmail);\n+    this.popupView.event.fire('periodicChecks');\n+  }\n+\n+  handlePeriodicChecks() {\n+    setTimeout(() => {\n+      this.popupView.periodicChecks();\n+    }, 3000);\n+  }\n+\n+  handleBoardChanged(target, params) {\n+    let boardId = params.boardId;\n+    if (boardId !== '_' && boardId !== '' && boardId !== null) {\n+      this.model.loadTrelloLists(boardId);\n+      this.model.loadTrelloLabels(boardId);\n+      this.model.loadTrelloMembers(boardId);\n+    }\n+  }\n+\n+  handleListChanged(target, params) {\n+    let listId = params.listId;\n+    this.model.loadTrelloCards(listId);\n+  }\n+\n+  handleSubmit() {\n+    this.model.submit();\n+  }\n+\n+  handleCheckTrelloAuthorized() {\n+    this.popupView.showMessage(this, 'Authorizing...');\n+    this.model.checkTrelloAuthorized();\n+  }\n+\n+  handleRequestDeauthorizeTrello() {\n+    g2t_log('onRequestDeauthorizeTrello');\n+    this.model.deauthorizeTrello();\n+    this.popupView.clearBoard();\n+  }\n+\n+  handleDetectButton() {\n+    if (this.gmailView.preDetect()) {\n+      this.popupView.$toolBar = this.gmailView.$toolBar;\n+      this.popupView.confirmPopup();\n+    }\n+  }\n+\n+  handleGmailDetected() {\n+    this.popupView.$toolBar = this.gmailView.$toolBar;\n+    this.popupView.init();\n+  }\n+\n+  handleRuntimeMessage(request, sender, sendResponse) {\n+    if (request?.message === 'g2t_keyboard_shortcut') {\n+      this.popupView.showPopup();\n+    }\n+  }\n+\n+  updateData() {\n+    const self = this;\n+\n+    const fullName = self?.model?.trello?.user?.fullName || '';\n+\n+    self.popupView.bindData(self.model);\n+\n+    self.gmailView.parsingData = false;\n+    self.model.gmail = self.gmailView.parseData({ fullName });\n+    self.popupView.bindGmailData(self.model.gmail);\n+  }\n+\n+  initialize() {\n+    const self = this;\n+\n+    this.model.isInitialized = false;\n+\n+    // g2t_log('App:initialize');\n+\n+    this.gmailView.detect();\n+\n+    service = analytics.getService('gmail-2-trello');\n+\n+    // Get a Tracker using your Google Analytics app Tracking ID.\n+    tracker = service.getTracker('G-0QPEDL7YDL'); // Was: UA-8469046-1 -> UA-42442437-4\n+\n+    // Record an \"appView\" each time the user launches your app or goes to a new\n+    // screen within the app.\n+    tracker.sendAppView('PopupView');\n+  }\n+\n+  /**\n+   * Correctly escape RegExp\n+   */\n+  escapeRegExp(str) {\n+    return str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n+  }\n+\n+  /**\n+   * Utility routine to replace variables\n+   */\n+  replacer(text, dict) {\n+    let self = this;\n+\n+    if (!text || text.length < 1) {\n+      // g2t_log('Require text!');\n+      return '';\n+    } else if (!dict || dict.length < 2) {\n+      g2t_log('replacer: Require dictionary!');\n+      return text;\n+    }\n+\n+    let re, new_text;\n+    const replacify = function () {\n+      g2t_each(dict, function (value, key) {\n+        re = new RegExp(`%${self.escapeRegExp(key)}%`, 'gi');\n+        new_text = text.replace(re, value);\n+        text = new_text;\n+      });\n+    };\n+\n+    let runaway_max = 3;\n+    while (text.indexOf('%') !== -1 && runaway_max-- > 0) {\n+      replacify();\n+    }\n+\n+    return text;\n+  }\n+\n+  /**\n+   * Make displayable URI\n+   */\n+  uriForDisplay(uri) {\n+    const uri_display_trigger_length_k = 20;\n+    const uri_length_max_k = 40;\n+    let uri_display = uri || '';\n+    if (uri_display.length > uri_display_trigger_length_k) {\n+      let re = RegExp('^\\\\w+://([\\\\w./_-]+).*?([\\\\w._-]*)$');\n+      let matched = uri_display.match(re);\n+      if (matched && matched.length > 1) {\n+        const filename_k =\n+          matched[2].length < uri_length_max_k\n+            ? matched[2]\n+            : matched[2].slice(-uri_length_max_k);\n+        let prelude = matched[1].substr(0, uri_length_max_k);\n+        if (matched[1].length > uri_length_max_k) {\n+          prelude += '...';\n+        } else if (filename_k.length > 0) {\n+          prelude += ':';\n+        }\n+\n+        uri_display = prelude + filename_k;\n+      }\n+    }\n+    return uri_display;\n+  }\n+\n+  /**\n+   * Make anchored backlink\n+   */\n+  anchorMarkdownify(text, href, comment) {\n+    let text1 = (text || '').trim();\n+    let text1lc = text1.toLowerCase();\n+    let href1 = (href || '').trim();\n+    let href1lc = href1.toLowerCase();\n+    let comment1 = (comment || '').trim();\n+\n+    let retn = '';\n+\n+    if (text1.length < 1 && href1.length < 1) {\n+      // Intetionally blank\n+    } else if (text1lc === href1lc) {\n+      retn = ` <${href1}> `; // This renders correctly in Trello as a sole URL\n+      // NOTE (Ace, 17-Feb-2017): Turns out Trello doesn't support markdown [] only, so we'll construct a nice displayable text vs url:\n+      // text1 = this.uriForDisplay(text1);\n+    } else if (`mailto:${text1lc}` === href1lc) {\n+      retn = ` <${text1}> `; // This renders correctly in Trello as a mailto: url\n+    } else {\n+      const comment1QuotedSpaced = comment1.length > 0 ? ` \"${comment1}\"` : '';\n+      retn = ` [${text1}](<${href1}>${comment1QuotedSpaced}) `;\n+    }\n+\n+    return retn;\n+  }\n+\n+  /**\n+   * Split an email into name and domain\n+   */\n+  splitEmailDomain(email = '') {\n+    const split = email.split('@');\n+    const name = split[0] || '';\n+    const domain = split[1] || '';\n+    return {\n+      name,\n+      domain,\n+    };\n+  }\n+\n+  /**\n+   * Add trailing char if not empty:\n+   */\n+  addChar(front = '', back = '', addChar = ' ') {\n+    if (front.length > 0) {\n+      if (back.length > 0) {\n+        return `${front}${addChar}${back}`;\n+      } else {\n+        return `${front}${addChar}`;\n+      }\n+    } else if (back.length > 0) {\n+      return `${addChar}${back}`;\n+    } else {\n+      return '';\n+    }\n+  }\n+\n+  /**\n+   * Add trailing space if not empty:\n+   */\n+  addSpace(front = '', back = '') {\n+    return this.addChar(front, back, ' ');\n+  }\n+\n+  /**\n+   * Add trailing CRLF if not empty:\n+   */\n+  addCRLF(front = '', back = '') {\n+    return this.addChar(front, back, '\\n');\n+  }\n+\n+  /**\n+   * Markdownify a text block\n+   */\n+  markdownify($emailBody, features, preprocess) {\n+    if (!$emailBody || $emailBody.length < 1) {\n+      g2t_log('markdownify: Require emailBody!');\n+      return;\n+    }\n+    const self = this;\n+\n+    const min_text_length_k = 4;\n+    const max_replace_attempts_k = 10;\n+    const regexp_k = {\n+      begin: '(^|\\\\s+|<|\\\\[|\\\\(|\\\\b|(?=\\\\W+))',\n+      end: '($|\\\\s+|>|\\\\]|\\\\)|\\\\b|(?=\\\\W+))',\n+    };\n+    const unique_placeholder_k = 'g2t_placeholder:'; // Unique placeholder tag\n+\n+    let count = 0;\n+    let replacer_dict = {};\n+\n+    const featureEnabled = (elementTag = '') =>\n+      features === false ? false : features?.[elementTag] !== false;\n+\n+    let $html = $emailBody || ''; // Was: $emailBody.innerHTML || \"\";\n+    // let body = $emailBody.text() || \"\";\n+    let body = $emailBody.html() || '';\n+\n+    // Different encodings handle CRLF differently, so we'll process the main body as html and convert to text:\n+    // Convert paragraph marker to two returns:\n+    let replaced = body.replace(/\\s*[\\n\\r]*<p[^>]*>\\s*[\\n\\r]*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // Convert br marker to one return:\n+    replaced = body.replace(/\\s*[\\n\\r]*<br[^>]*>\\s*[\\n\\r]*/g, '\\n');\n+    body = replaced;\n+\n+    // Remove all other html markers:\n+    replaced = body.replace(/<[^>]*>/g, '');\n+    body = replaced;\n+\n+    // Decode HTML entities:\n+    replaced = self.decodeEntities(body);\n+    body = replaced;\n+\n+    // Replace hr:\n+    replaced = body.replace(/\\s*-{3,}\\s*/g, '---\\n');\n+    body = replaced;\n+\n+    // Convert crlf x 2 (or more) to paragraph markers:\n+    replaced = body.replace(/(\\s*[\\n\\r]\\s*){2,}/g, '<p />\\n');\n+    body = replaced;\n+\n+    let toProcess = {};\n+\n+    /**\n+     * 5 explicit steps in 3 passes:\n+     * (1) Collect tagged items\n+     * (2) Remove duplicates\n+     * (3) Sort force-lowercase by length\n+     * (4) Replace with placeholder\n+     * (5) Replace placeholders with final text\n+     */\n+    const sortAndPlaceholderize = function (tooProcess) {\n+      if (tooProcess) {\n+        g2t_each(\n+          Object.keys(tooProcess).sort(function (a, b) {\n+            // Go by order of largest to smallest\n+            return b.length - a.length;\n+          }),\n+          function (value) {\n+            const replace = tooProcess[value];\n+            const swap = `${unique_placeholder_k}${(count++).toString()}`;\n+            const re = new RegExp(\n+              regexp_k.begin + self.escapeRegExp(value) + regexp_k.end,\n+              'gi'\n+            );\n+            const replaced = body.replace(re, `%${swap}%`); // Replace occurance with placeholder\n+            if (body !== replaced) {\n+              body = replaced;\n+              replacer_dict[swap] = replace;\n+            }\n+          }\n+        );\n+      }\n+    };\n+    const processMarkdown = function (elementTag, replaceText) {\n+      if (elementTag && replaceText && featureEnabled(elementTag)) {\n+        toProcess = preprocess[elementTag] || {};\n+        $(elementTag, $html).each(function (index, value) {\n+          let text = ($(this).text() || '').trim();\n+          if (text && text.length > min_text_length_k) {\n+            let replace = self.replacer(replaceText, { text: text });\n+            toProcess[text.toLowerCase()] = replace; // Intentionally overwrites duplicates\n+          }\n+        });\n+        sortAndPlaceholderize(toProcess);\n+      }\n+    };\n+    /**\n+     * Repeat replace for max attempts or when done, whatever comes first\n+     */\n+    const repeatReplace = function (body, inRegexp, replaceWith) {\n+      let replace1 = '';\n+      for (let iter = max_replace_attempts_k; iter > 0; iter--) {\n+        replace1 = body.replace(inRegexp, replaceWith);\n+        if (body === replace1) {\n+          iter = 0; // All done\n+        } else {\n+          body = replace1;\n+        }\n+      }\n+      return body;\n+    };\n+\n+    // bullet lists:\n+    // ul li -> \" * \"\n+    processMarkdown('ul li', '<p />* %text%<p />');\n+\n+    // numeric lists:\n+    // ol li -> \" 1. \"\n+    processMarkdown('ol li', '<p />1. %text%<p />');\n+\n+    // headers:\n+    // H1 -> #\n+    // H2 -> ##\n+    // H3 -> ###\n+    // H4 -> ####\n+    // H5 -> #####\n+    // H6 -> ######\n+    if (featureEnabled('h')) {\n+      toProcess = preprocess['h'] || {};\n+      $(':header', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let nodeName = $(this).prop('nodeName') || '0';\n+        if (nodeName && text && text.length > min_text_length_k) {\n+          let x = nodeName.substr(-1);\n+          toProcess[text.toLowerCase()] = `\\n${'#'.repeat(x)} ${text}\\n`; // Intentionally overwrites duplicates\n+        }\n+      });\n+      sortAndPlaceholderize(toProcess);\n+    }\n+\n+    replaced = this.replacer(body, replacer_dict); // Replace initial batch of <div> like placeholders\n+    body = replaced;\n+    replacer_dict = {}; // Reset\n+    count = 0; // Reset\n+\n+    // bold: b -> **text**\n+    processMarkdown('b', ' **%text%** ');\n+\n+    // italics: i -> _text_\n+    processMarkdown('i', ' _%text%_ ');\n+\n+    // links:\n+    // a -> [text](html)\n+    if (featureEnabled('a')) {\n+      toProcess = preprocess['a'] || {};\n+      $('a', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let href = ($(this).prop('href') || '').trim(); // Was attr",
    "path": "chrome_manifest_v3/class_app.js",
    "commit_id": "3bbc7b0b5b5abfda366260c45d6f2cecebf28af3",
    "original_commit_id": "f609e1322b9a0f1b03b7094863f0c64a967e9df2",
    "user": {
      "login": "coderabbitai[bot]",
      "id": 136622811,
      "node_id": "BOT_kgDOCCSy2w",
      "avatar_url": "https://avatars.githubusercontent.com/in/347564?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/coderabbitai%5Bbot%5D",
      "html_url": "https://github.com/apps/coderabbitai",
      "followers_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "_🧹 Nitpick (assertive)_\n\n**Const for both.**\n\n```diff\n-        let text = ($(this).text() || '').trim();\n-        let href = ($(this).prop('href') || '').trim(); // Was attr\n+        const text = ($(this).text() || '').trim();\n+        const href = ($(this).prop('href') || '').trim(); // Was attr\n```\n\nNow whut?\n\n<!-- suggestion_start -->\n\n<details>\n<summary>📝 Committable suggestion</summary>\n\n> ‼️ **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n        const text = ($(this).text() || '').trim();\n        const href = ($(this).prop('href') || '').trim(); // Was attr\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>🧰 Tools</summary>\n\n<details>\n<summary>🪛 Biome (1.9.4)</summary>\n\n[error] 535-535: This let declares a variable that is only assigned once.\n\n'text' is never reassigned.\n\nSafe fix: Use const instead.\n\n\n(lint/style/useConst)\n\n---\n\n[error] 536-536: This let declares a variable that is only assigned once.\n\n'href' is never reassigned.\n\nSafe fix: Use const instead.\n\n\n(lint/style/useConst)\n\n</details>\n\n</details>\n\n<details>\n<summary>🤖 Prompt for AI Agents</summary>\n\n```\nIn chrome_manifest_v3/class_app.js at lines 535 to 536, change the declarations\nof variables 'text' and 'href' from 'let' to 'const' since their values are not\nreassigned. Replace 'let' with 'const' for both variables to follow best\npractices for immutability.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:lion -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "created_at": "2025-07-14T01:54:40Z",
    "updated_at": "2025-07-14T01:54:41Z",
    "html_url": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203704191",
    "pull_request_url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203704191"
      },
      "html": {
        "href": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203704191"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203704191/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 535,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 536,
    "side": "RIGHT",
    "original_position": 536,
    "position": null,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203704193",
    "pull_request_review_id": 3014554580,
    "id": 2203704193,
    "node_id": "PRRC_kwDOD1hYKM6DWduB",
    "diff_hunk": "@@ -0,0 +1,852 @@\n+/** Gmail2Trello Application - ES6 Class Version\n+ */\n+\n+var Gmail2Trello = Gmail2Trello || {}; // Namespace initialization - must be var to guarantee correct scope\n+\n+class App {\n+  constructor() {\n+    this.CHROME_SETTINGS_ID = 'g2t_user_settings';\n+    this.UNIQUE_URI_VAR = 'g2t_filename';\n+\n+    this.model = new Gmail2Trello.Model(this);\n+    this.gmailView = new Gmail2Trello.GmailView(this);\n+    this.popupView = new Gmail2Trello.PopupView(this);\n+\n+    this.bindEvents();\n+  }\n+\n+  bindEvents() {\n+    /*** Data's events binding ***/\n+    this.model.event.addListener('onBeforeAuthorize', this.handleBeforeAuthorize.bind(this));\n+    this.model.event.addListener('onAuthorizeFail', this.handleAuthorizeFail.bind(this));\n+    this.model.event.addListener('onAuthorized', this.handleAuthorized.bind(this));\n+    this.model.event.addListener('onBeforeLoadTrello', this.handleBeforeLoadTrello.bind(this));\n+    this.model.event.addListener('onTrelloDataReady', this.handleTrelloDataReady.bind(this));\n+    this.model.event.addListener('onLoadTrelloListSuccess', this.handleLoadTrelloListSuccess.bind(this));\n+    this.model.event.addListener('onLoadTrelloCardsSuccess', this.handleLoadTrelloCardsSuccess.bind(this));\n+    this.model.event.addListener('onLoadTrelloLabelsSuccess', this.handleLoadTrelloLabelsSuccess.bind(this));\n+    this.model.event.addListener('onLoadTrelloMembersSuccess', this.handleLoadTrelloMembersSuccess.bind(this));\n+    this.model.event.addListener('onCardSubmitComplete', this.handleCardSubmitComplete.bind(this));\n+    this.model.event.addListener('onAPIFailure', this.handleAPIFailure.bind(this));\n+\n+    /*** PopupView's events binding ***/\n+    this.popupView.event.addListener('onPopupVisible', this.handlePopupVisible.bind(this));\n+    this.popupView.event.addListener('periodicChecks', this.handlePeriodicChecks.bind(this));\n+    this.popupView.event.addListener('onBoardChanged', this.handleBoardChanged.bind(this));\n+    this.popupView.event.addListener('onListChanged', this.handleListChanged.bind(this));\n+    this.popupView.event.addListener('onSubmit', this.handleSubmit.bind(this));\n+    this.popupView.event.addListener('checkTrelloAuthorized', this.handleCheckTrelloAuthorized.bind(this));\n+    this.popupView.event.addListener('onRequestDeauthorizeTrello', this.handleRequestDeauthorizeTrello.bind(this));\n+    this.popupView.event.addListener('detectButton', this.handleDetectButton.bind(this));\n+\n+    // GMailView's events:\n+    this.gmailView.event.addListener('onDetected', this.handleGmailDetected.bind(this));\n+    this.gmailView.event.addListener('detectButton', this.handleDetectButton.bind(this));\n+\n+    chrome.runtime.onMessage.addListener(this.handleRuntimeMessage.bind(this));\n+  }\n+\n+  // Event handler methods\n+  handleBeforeAuthorize() {\n+    this.popupView.bindData(''); // Intentionally blank\n+    this.popupView.showMessage(this, 'Authorizing...');\n+  }\n+\n+  handleAuthorizeFail() {\n+    this.popupView.showMessage(\n+      this,\n+      'Trello authorization failed <button id=\"showsignout\">Sign out and try again</button>'\n+    );\n+  }\n+\n+  handleAuthorized() {\n+    this.popupView.$popupContent.show();\n+    this.popupView.hideMessage();\n+  }\n+\n+  handleBeforeLoadTrello() {\n+    this.popupView.showMessage(this, 'Loading Trello data...');\n+  }\n+\n+  handleTrelloDataReady() {\n+    this.popupView.$popupContent.show();\n+    this.popupView.hideMessage();\n+    this.popupView.bindData(this.model);\n+  }\n+\n+  handleLoadTrelloListSuccess() {\n+    this.popupView.updateLists();\n+    this.popupView.validateData();\n+  }\n+\n+  handleLoadTrelloCardsSuccess() {\n+    this.popupView.updateCards();\n+    this.popupView.validateData();\n+  }\n+\n+  handleLoadTrelloLabelsSuccess() {\n+    this.popupView.updateLabels();\n+    this.popupView.validateData();\n+  }\n+\n+  handleLoadTrelloMembersSuccess() {\n+    this.popupView.updateMembers();\n+    this.popupView.validateData();\n+  }\n+\n+  handleCardSubmitComplete(target, params) {\n+    this.popupView.displaySubmitCompleteForm();\n+    // If card lists or labels have been updated, reload:\n+    const data_k = params?.data || {};\n+    const emailId = data_k?.emailId || 0;\n+    const boardId_k = data_k?.data?.board?.id || 0;\n+    const listId_k = data_k?.data?.list?.id || 0;\n+    const cardId_k = data_k?.data?.card?.id || 0;\n+    const idBoard_k = data_k?.idBoard || 0;\n+    const idList_k = data_k?.idList || 0;\n+    const idCard_k = data_k?.idCard || 0;\n+    const boardId = boardId_k || idBoard_k || 0;\n+    const listId = listId_k || idList_k || 0;\n+    const cardId = cardId_k || idCard_k || 0;\n+    // NOTE (acoven@2020-05-23): Users expect when creating a brand new card,\n+    // we'll remember that new card ID and then keep defaulting to it for\n+    // subsequent updates to that email. That means we'll have to get the return\n+    // value/url from Trello and dissect that, potentially doing this update\n+    // in that routine:\n+    this.model.emailBoardListCardMapUpdate({\n+      emailId,\n+      boardId,\n+      listId,\n+      cardId,\n+    });\n+\n+    if (boardId) {\n+      this.model.loadTrelloLabels(boardId);\n+      this.model.loadTrelloMembers(boardId);\n+    }\n+    if (listId) {\n+      this.model.loadTrelloCards(listId);\n+    }\n+  }\n+\n+  handleAPIFailure(target, params) {\n+    this.popupView.displayAPIFailedForm(params);\n+  }\n+\n+  handlePopupVisible() {\n+    if (!this.model.isInitialized) {\n+      this.popupView.showMessage(this, 'Initializing...');\n+      this.popupView.$popupContent.hide();\n+      this.model.init();\n+    } else {\n+      this.popupView.reset();\n+    }\n+\n+    const trelloUser_k = this?.model?.trello?.user || {};\n+    const fullName = trelloUser_k?.fullName || '';\n+\n+    this.gmailView.parsingData = false;\n+    this.model.gmail = this.gmailView.parseData({ fullName });\n+    this.popupView.bindGmailData(this.model.gmail);\n+    this.popupView.event.fire('periodicChecks');\n+  }\n+\n+  handlePeriodicChecks() {\n+    setTimeout(() => {\n+      this.popupView.periodicChecks();\n+    }, 3000);\n+  }\n+\n+  handleBoardChanged(target, params) {\n+    let boardId = params.boardId;\n+    if (boardId !== '_' && boardId !== '' && boardId !== null) {\n+      this.model.loadTrelloLists(boardId);\n+      this.model.loadTrelloLabels(boardId);\n+      this.model.loadTrelloMembers(boardId);\n+    }\n+  }\n+\n+  handleListChanged(target, params) {\n+    let listId = params.listId;\n+    this.model.loadTrelloCards(listId);\n+  }\n+\n+  handleSubmit() {\n+    this.model.submit();\n+  }\n+\n+  handleCheckTrelloAuthorized() {\n+    this.popupView.showMessage(this, 'Authorizing...');\n+    this.model.checkTrelloAuthorized();\n+  }\n+\n+  handleRequestDeauthorizeTrello() {\n+    g2t_log('onRequestDeauthorizeTrello');\n+    this.model.deauthorizeTrello();\n+    this.popupView.clearBoard();\n+  }\n+\n+  handleDetectButton() {\n+    if (this.gmailView.preDetect()) {\n+      this.popupView.$toolBar = this.gmailView.$toolBar;\n+      this.popupView.confirmPopup();\n+    }\n+  }\n+\n+  handleGmailDetected() {\n+    this.popupView.$toolBar = this.gmailView.$toolBar;\n+    this.popupView.init();\n+  }\n+\n+  handleRuntimeMessage(request, sender, sendResponse) {\n+    if (request?.message === 'g2t_keyboard_shortcut') {\n+      this.popupView.showPopup();\n+    }\n+  }\n+\n+  updateData() {\n+    const self = this;\n+\n+    const fullName = self?.model?.trello?.user?.fullName || '';\n+\n+    self.popupView.bindData(self.model);\n+\n+    self.gmailView.parsingData = false;\n+    self.model.gmail = self.gmailView.parseData({ fullName });\n+    self.popupView.bindGmailData(self.model.gmail);\n+  }\n+\n+  initialize() {\n+    const self = this;\n+\n+    this.model.isInitialized = false;\n+\n+    // g2t_log('App:initialize');\n+\n+    this.gmailView.detect();\n+\n+    service = analytics.getService('gmail-2-trello');\n+\n+    // Get a Tracker using your Google Analytics app Tracking ID.\n+    tracker = service.getTracker('G-0QPEDL7YDL'); // Was: UA-8469046-1 -> UA-42442437-4\n+\n+    // Record an \"appView\" each time the user launches your app or goes to a new\n+    // screen within the app.\n+    tracker.sendAppView('PopupView');\n+  }\n+\n+  /**\n+   * Correctly escape RegExp\n+   */\n+  escapeRegExp(str) {\n+    return str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n+  }\n+\n+  /**\n+   * Utility routine to replace variables\n+   */\n+  replacer(text, dict) {\n+    let self = this;\n+\n+    if (!text || text.length < 1) {\n+      // g2t_log('Require text!');\n+      return '';\n+    } else if (!dict || dict.length < 2) {\n+      g2t_log('replacer: Require dictionary!');\n+      return text;\n+    }\n+\n+    let re, new_text;\n+    const replacify = function () {\n+      g2t_each(dict, function (value, key) {\n+        re = new RegExp(`%${self.escapeRegExp(key)}%`, 'gi');\n+        new_text = text.replace(re, value);\n+        text = new_text;\n+      });\n+    };\n+\n+    let runaway_max = 3;\n+    while (text.indexOf('%') !== -1 && runaway_max-- > 0) {\n+      replacify();\n+    }\n+\n+    return text;\n+  }\n+\n+  /**\n+   * Make displayable URI\n+   */\n+  uriForDisplay(uri) {\n+    const uri_display_trigger_length_k = 20;\n+    const uri_length_max_k = 40;\n+    let uri_display = uri || '';\n+    if (uri_display.length > uri_display_trigger_length_k) {\n+      let re = RegExp('^\\\\w+://([\\\\w./_-]+).*?([\\\\w._-]*)$');\n+      let matched = uri_display.match(re);\n+      if (matched && matched.length > 1) {\n+        const filename_k =\n+          matched[2].length < uri_length_max_k\n+            ? matched[2]\n+            : matched[2].slice(-uri_length_max_k);\n+        let prelude = matched[1].substr(0, uri_length_max_k);\n+        if (matched[1].length > uri_length_max_k) {\n+          prelude += '...';\n+        } else if (filename_k.length > 0) {\n+          prelude += ':';\n+        }\n+\n+        uri_display = prelude + filename_k;\n+      }\n+    }\n+    return uri_display;\n+  }\n+\n+  /**\n+   * Make anchored backlink\n+   */\n+  anchorMarkdownify(text, href, comment) {\n+    let text1 = (text || '').trim();\n+    let text1lc = text1.toLowerCase();\n+    let href1 = (href || '').trim();\n+    let href1lc = href1.toLowerCase();\n+    let comment1 = (comment || '').trim();\n+\n+    let retn = '';\n+\n+    if (text1.length < 1 && href1.length < 1) {\n+      // Intetionally blank\n+    } else if (text1lc === href1lc) {\n+      retn = ` <${href1}> `; // This renders correctly in Trello as a sole URL\n+      // NOTE (Ace, 17-Feb-2017): Turns out Trello doesn't support markdown [] only, so we'll construct a nice displayable text vs url:\n+      // text1 = this.uriForDisplay(text1);\n+    } else if (`mailto:${text1lc}` === href1lc) {\n+      retn = ` <${text1}> `; // This renders correctly in Trello as a mailto: url\n+    } else {\n+      const comment1QuotedSpaced = comment1.length > 0 ? ` \"${comment1}\"` : '';\n+      retn = ` [${text1}](<${href1}>${comment1QuotedSpaced}) `;\n+    }\n+\n+    return retn;\n+  }\n+\n+  /**\n+   * Split an email into name and domain\n+   */\n+  splitEmailDomain(email = '') {\n+    const split = email.split('@');\n+    const name = split[0] || '';\n+    const domain = split[1] || '';\n+    return {\n+      name,\n+      domain,\n+    };\n+  }\n+\n+  /**\n+   * Add trailing char if not empty:\n+   */\n+  addChar(front = '', back = '', addChar = ' ') {\n+    if (front.length > 0) {\n+      if (back.length > 0) {\n+        return `${front}${addChar}${back}`;\n+      } else {\n+        return `${front}${addChar}`;\n+      }\n+    } else if (back.length > 0) {\n+      return `${addChar}${back}`;\n+    } else {\n+      return '';\n+    }\n+  }\n+\n+  /**\n+   * Add trailing space if not empty:\n+   */\n+  addSpace(front = '', back = '') {\n+    return this.addChar(front, back, ' ');\n+  }\n+\n+  /**\n+   * Add trailing CRLF if not empty:\n+   */\n+  addCRLF(front = '', back = '') {\n+    return this.addChar(front, back, '\\n');\n+  }\n+\n+  /**\n+   * Markdownify a text block\n+   */\n+  markdownify($emailBody, features, preprocess) {\n+    if (!$emailBody || $emailBody.length < 1) {\n+      g2t_log('markdownify: Require emailBody!');\n+      return;\n+    }\n+    const self = this;\n+\n+    const min_text_length_k = 4;\n+    const max_replace_attempts_k = 10;\n+    const regexp_k = {\n+      begin: '(^|\\\\s+|<|\\\\[|\\\\(|\\\\b|(?=\\\\W+))',\n+      end: '($|\\\\s+|>|\\\\]|\\\\)|\\\\b|(?=\\\\W+))',\n+    };\n+    const unique_placeholder_k = 'g2t_placeholder:'; // Unique placeholder tag\n+\n+    let count = 0;\n+    let replacer_dict = {};\n+\n+    const featureEnabled = (elementTag = '') =>\n+      features === false ? false : features?.[elementTag] !== false;\n+\n+    let $html = $emailBody || ''; // Was: $emailBody.innerHTML || \"\";\n+    // let body = $emailBody.text() || \"\";\n+    let body = $emailBody.html() || '';\n+\n+    // Different encodings handle CRLF differently, so we'll process the main body as html and convert to text:\n+    // Convert paragraph marker to two returns:\n+    let replaced = body.replace(/\\s*[\\n\\r]*<p[^>]*>\\s*[\\n\\r]*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // Convert br marker to one return:\n+    replaced = body.replace(/\\s*[\\n\\r]*<br[^>]*>\\s*[\\n\\r]*/g, '\\n');\n+    body = replaced;\n+\n+    // Remove all other html markers:\n+    replaced = body.replace(/<[^>]*>/g, '');\n+    body = replaced;\n+\n+    // Decode HTML entities:\n+    replaced = self.decodeEntities(body);\n+    body = replaced;\n+\n+    // Replace hr:\n+    replaced = body.replace(/\\s*-{3,}\\s*/g, '---\\n');\n+    body = replaced;\n+\n+    // Convert crlf x 2 (or more) to paragraph markers:\n+    replaced = body.replace(/(\\s*[\\n\\r]\\s*){2,}/g, '<p />\\n');\n+    body = replaced;\n+\n+    let toProcess = {};\n+\n+    /**\n+     * 5 explicit steps in 3 passes:\n+     * (1) Collect tagged items\n+     * (2) Remove duplicates\n+     * (3) Sort force-lowercase by length\n+     * (4) Replace with placeholder\n+     * (5) Replace placeholders with final text\n+     */\n+    const sortAndPlaceholderize = function (tooProcess) {\n+      if (tooProcess) {\n+        g2t_each(\n+          Object.keys(tooProcess).sort(function (a, b) {\n+            // Go by order of largest to smallest\n+            return b.length - a.length;\n+          }),\n+          function (value) {\n+            const replace = tooProcess[value];\n+            const swap = `${unique_placeholder_k}${(count++).toString()}`;\n+            const re = new RegExp(\n+              regexp_k.begin + self.escapeRegExp(value) + regexp_k.end,\n+              'gi'\n+            );\n+            const replaced = body.replace(re, `%${swap}%`); // Replace occurance with placeholder\n+            if (body !== replaced) {\n+              body = replaced;\n+              replacer_dict[swap] = replace;\n+            }\n+          }\n+        );\n+      }\n+    };\n+    const processMarkdown = function (elementTag, replaceText) {\n+      if (elementTag && replaceText && featureEnabled(elementTag)) {\n+        toProcess = preprocess[elementTag] || {};\n+        $(elementTag, $html).each(function (index, value) {\n+          let text = ($(this).text() || '').trim();\n+          if (text && text.length > min_text_length_k) {\n+            let replace = self.replacer(replaceText, { text: text });",
    "path": "chrome_manifest_v3/class_app.js",
    "commit_id": "3bbc7b0b5b5abfda366260c45d6f2cecebf28af3",
    "original_commit_id": "f609e1322b9a0f1b03b7094863f0c64a967e9df2",
    "user": {
      "login": "coderabbitai[bot]",
      "id": 136622811,
      "node_id": "BOT_kgDOCCSy2w",
      "avatar_url": "https://avatars.githubusercontent.com/in/347564?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/coderabbitai%5Bbot%5D",
      "html_url": "https://github.com/apps/coderabbitai",
      "followers_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "_🧹 Nitpick (assertive)_\n\n**Variables never reassigned. Use const.**\n\n```diff\n-          let text = ($(this).text() || '').trim();\n+          const text = ($(this).text() || '').trim();\n           if (text && text.length > min_text_length_k) {\n-            let replace = self.replacer(replaceText, { text: text });\n+            const replace = self.replacer(replaceText, { text: text });\n```\n\nI am the Batman.\n\n<!-- suggestion_start -->\n\n<details>\n<summary>📝 Committable suggestion</summary>\n\n> ‼️ **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n          const text = ($(this).text() || '').trim();\n          if (text && text.length > min_text_length_k) {\n            const replace = self.replacer(replaceText, { text: text });\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>🧰 Tools</summary>\n\n<details>\n<summary>🪛 Biome (1.9.4)</summary>\n\n[error] 466-466: This let declares a variable that is only assigned once.\n\n'text' is never reassigned.\n\nSafe fix: Use const instead.\n\n\n(lint/style/useConst)\n\n---\n\n[error] 468-468: This let declares a variable that is only assigned once.\n\n'replace' is never reassigned.\n\nSafe fix: Use const instead.\n\n\n(lint/style/useConst)\n\n</details>\n\n</details>\n\n<details>\n<summary>🤖 Prompt for AI Agents</summary>\n\n```\nIn chrome_manifest_v3/class_app.js around lines 466 to 468, the variables 'text'\nand 'replace' are declared with 'let' but never reassigned. Change their\ndeclarations from 'let' to 'const' to reflect their immutability and improve\ncode clarity.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:lion -->\n\n<!-- This is an auto-generated reply by CodeRabbit -->",
    "created_at": "2025-07-14T01:54:40Z",
    "updated_at": "2025-07-14T06:32:10Z",
    "html_url": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203704193",
    "pull_request_url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203704193"
      },
      "html": {
        "href": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203704193"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203704193/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 466,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 468,
    "side": "RIGHT",
    "original_position": 468,
    "position": null,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203704196",
    "pull_request_review_id": 3014554580,
    "id": 2203704196,
    "node_id": "PRRC_kwDOD1hYKM6DWduE",
    "diff_hunk": "@@ -0,0 +1,852 @@\n+/** Gmail2Trello Application - ES6 Class Version\n+ */\n+\n+var Gmail2Trello = Gmail2Trello || {}; // Namespace initialization - must be var to guarantee correct scope\n+\n+class App {\n+  constructor() {\n+    this.CHROME_SETTINGS_ID = 'g2t_user_settings';\n+    this.UNIQUE_URI_VAR = 'g2t_filename';\n+\n+    this.model = new Gmail2Trello.Model(this);\n+    this.gmailView = new Gmail2Trello.GmailView(this);\n+    this.popupView = new Gmail2Trello.PopupView(this);\n+\n+    this.bindEvents();\n+  }\n+\n+  bindEvents() {\n+    /*** Data's events binding ***/\n+    this.model.event.addListener('onBeforeAuthorize', this.handleBeforeAuthorize.bind(this));\n+    this.model.event.addListener('onAuthorizeFail', this.handleAuthorizeFail.bind(this));\n+    this.model.event.addListener('onAuthorized', this.handleAuthorized.bind(this));\n+    this.model.event.addListener('onBeforeLoadTrello', this.handleBeforeLoadTrello.bind(this));\n+    this.model.event.addListener('onTrelloDataReady', this.handleTrelloDataReady.bind(this));\n+    this.model.event.addListener('onLoadTrelloListSuccess', this.handleLoadTrelloListSuccess.bind(this));\n+    this.model.event.addListener('onLoadTrelloCardsSuccess', this.handleLoadTrelloCardsSuccess.bind(this));\n+    this.model.event.addListener('onLoadTrelloLabelsSuccess', this.handleLoadTrelloLabelsSuccess.bind(this));\n+    this.model.event.addListener('onLoadTrelloMembersSuccess', this.handleLoadTrelloMembersSuccess.bind(this));\n+    this.model.event.addListener('onCardSubmitComplete', this.handleCardSubmitComplete.bind(this));\n+    this.model.event.addListener('onAPIFailure', this.handleAPIFailure.bind(this));\n+\n+    /*** PopupView's events binding ***/\n+    this.popupView.event.addListener('onPopupVisible', this.handlePopupVisible.bind(this));\n+    this.popupView.event.addListener('periodicChecks', this.handlePeriodicChecks.bind(this));\n+    this.popupView.event.addListener('onBoardChanged', this.handleBoardChanged.bind(this));\n+    this.popupView.event.addListener('onListChanged', this.handleListChanged.bind(this));\n+    this.popupView.event.addListener('onSubmit', this.handleSubmit.bind(this));\n+    this.popupView.event.addListener('checkTrelloAuthorized', this.handleCheckTrelloAuthorized.bind(this));\n+    this.popupView.event.addListener('onRequestDeauthorizeTrello', this.handleRequestDeauthorizeTrello.bind(this));\n+    this.popupView.event.addListener('detectButton', this.handleDetectButton.bind(this));\n+\n+    // GMailView's events:\n+    this.gmailView.event.addListener('onDetected', this.handleGmailDetected.bind(this));\n+    this.gmailView.event.addListener('detectButton', this.handleDetectButton.bind(this));\n+\n+    chrome.runtime.onMessage.addListener(this.handleRuntimeMessage.bind(this));\n+  }\n+\n+  // Event handler methods\n+  handleBeforeAuthorize() {\n+    this.popupView.bindData(''); // Intentionally blank\n+    this.popupView.showMessage(this, 'Authorizing...');\n+  }\n+\n+  handleAuthorizeFail() {\n+    this.popupView.showMessage(\n+      this,\n+      'Trello authorization failed <button id=\"showsignout\">Sign out and try again</button>'\n+    );\n+  }\n+\n+  handleAuthorized() {\n+    this.popupView.$popupContent.show();\n+    this.popupView.hideMessage();\n+  }\n+\n+  handleBeforeLoadTrello() {\n+    this.popupView.showMessage(this, 'Loading Trello data...');\n+  }\n+\n+  handleTrelloDataReady() {\n+    this.popupView.$popupContent.show();\n+    this.popupView.hideMessage();\n+    this.popupView.bindData(this.model);\n+  }\n+\n+  handleLoadTrelloListSuccess() {\n+    this.popupView.updateLists();\n+    this.popupView.validateData();\n+  }\n+\n+  handleLoadTrelloCardsSuccess() {\n+    this.popupView.updateCards();\n+    this.popupView.validateData();\n+  }\n+\n+  handleLoadTrelloLabelsSuccess() {\n+    this.popupView.updateLabels();\n+    this.popupView.validateData();\n+  }\n+\n+  handleLoadTrelloMembersSuccess() {\n+    this.popupView.updateMembers();\n+    this.popupView.validateData();\n+  }\n+\n+  handleCardSubmitComplete(target, params) {\n+    this.popupView.displaySubmitCompleteForm();\n+    // If card lists or labels have been updated, reload:\n+    const data_k = params?.data || {};\n+    const emailId = data_k?.emailId || 0;\n+    const boardId_k = data_k?.data?.board?.id || 0;\n+    const listId_k = data_k?.data?.list?.id || 0;\n+    const cardId_k = data_k?.data?.card?.id || 0;\n+    const idBoard_k = data_k?.idBoard || 0;\n+    const idList_k = data_k?.idList || 0;\n+    const idCard_k = data_k?.idCard || 0;\n+    const boardId = boardId_k || idBoard_k || 0;\n+    const listId = listId_k || idList_k || 0;\n+    const cardId = cardId_k || idCard_k || 0;\n+    // NOTE (acoven@2020-05-23): Users expect when creating a brand new card,\n+    // we'll remember that new card ID and then keep defaulting to it for\n+    // subsequent updates to that email. That means we'll have to get the return\n+    // value/url from Trello and dissect that, potentially doing this update\n+    // in that routine:\n+    this.model.emailBoardListCardMapUpdate({\n+      emailId,\n+      boardId,\n+      listId,\n+      cardId,\n+    });\n+\n+    if (boardId) {\n+      this.model.loadTrelloLabels(boardId);\n+      this.model.loadTrelloMembers(boardId);\n+    }\n+    if (listId) {\n+      this.model.loadTrelloCards(listId);\n+    }\n+  }\n+\n+  handleAPIFailure(target, params) {\n+    this.popupView.displayAPIFailedForm(params);\n+  }\n+\n+  handlePopupVisible() {\n+    if (!this.model.isInitialized) {\n+      this.popupView.showMessage(this, 'Initializing...');\n+      this.popupView.$popupContent.hide();\n+      this.model.init();\n+    } else {\n+      this.popupView.reset();\n+    }\n+\n+    const trelloUser_k = this?.model?.trello?.user || {};\n+    const fullName = trelloUser_k?.fullName || '';\n+\n+    this.gmailView.parsingData = false;\n+    this.model.gmail = this.gmailView.parseData({ fullName });\n+    this.popupView.bindGmailData(this.model.gmail);\n+    this.popupView.event.fire('periodicChecks');\n+  }\n+\n+  handlePeriodicChecks() {\n+    setTimeout(() => {\n+      this.popupView.periodicChecks();\n+    }, 3000);\n+  }\n+\n+  handleBoardChanged(target, params) {\n+    let boardId = params.boardId;\n+    if (boardId !== '_' && boardId !== '' && boardId !== null) {\n+      this.model.loadTrelloLists(boardId);\n+      this.model.loadTrelloLabels(boardId);\n+      this.model.loadTrelloMembers(boardId);\n+    }\n+  }\n+\n+  handleListChanged(target, params) {\n+    let listId = params.listId;\n+    this.model.loadTrelloCards(listId);\n+  }\n+\n+  handleSubmit() {\n+    this.model.submit();\n+  }\n+\n+  handleCheckTrelloAuthorized() {\n+    this.popupView.showMessage(this, 'Authorizing...');\n+    this.model.checkTrelloAuthorized();\n+  }\n+\n+  handleRequestDeauthorizeTrello() {\n+    g2t_log('onRequestDeauthorizeTrello');\n+    this.model.deauthorizeTrello();\n+    this.popupView.clearBoard();\n+  }\n+\n+  handleDetectButton() {\n+    if (this.gmailView.preDetect()) {\n+      this.popupView.$toolBar = this.gmailView.$toolBar;\n+      this.popupView.confirmPopup();\n+    }\n+  }\n+\n+  handleGmailDetected() {\n+    this.popupView.$toolBar = this.gmailView.$toolBar;\n+    this.popupView.init();\n+  }\n+\n+  handleRuntimeMessage(request, sender, sendResponse) {\n+    if (request?.message === 'g2t_keyboard_shortcut') {\n+      this.popupView.showPopup();\n+    }\n+  }\n+\n+  updateData() {\n+    const self = this;\n+\n+    const fullName = self?.model?.trello?.user?.fullName || '';\n+\n+    self.popupView.bindData(self.model);\n+\n+    self.gmailView.parsingData = false;\n+    self.model.gmail = self.gmailView.parseData({ fullName });\n+    self.popupView.bindGmailData(self.model.gmail);\n+  }\n+\n+  initialize() {\n+    const self = this;\n+\n+    this.model.isInitialized = false;\n+\n+    // g2t_log('App:initialize');\n+\n+    this.gmailView.detect();\n+\n+    service = analytics.getService('gmail-2-trello');\n+\n+    // Get a Tracker using your Google Analytics app Tracking ID.\n+    tracker = service.getTracker('G-0QPEDL7YDL'); // Was: UA-8469046-1 -> UA-42442437-4\n+\n+    // Record an \"appView\" each time the user launches your app or goes to a new\n+    // screen within the app.\n+    tracker.sendAppView('PopupView');\n+  }\n+\n+  /**\n+   * Correctly escape RegExp\n+   */\n+  escapeRegExp(str) {\n+    return str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n+  }\n+\n+  /**\n+   * Utility routine to replace variables\n+   */\n+  replacer(text, dict) {\n+    let self = this;\n+\n+    if (!text || text.length < 1) {\n+      // g2t_log('Require text!');\n+      return '';\n+    } else if (!dict || dict.length < 2) {\n+      g2t_log('replacer: Require dictionary!');\n+      return text;\n+    }\n+\n+    let re, new_text;\n+    const replacify = function () {\n+      g2t_each(dict, function (value, key) {\n+        re = new RegExp(`%${self.escapeRegExp(key)}%`, 'gi');\n+        new_text = text.replace(re, value);\n+        text = new_text;\n+      });\n+    };\n+\n+    let runaway_max = 3;\n+    while (text.indexOf('%') !== -1 && runaway_max-- > 0) {\n+      replacify();\n+    }\n+\n+    return text;\n+  }\n+\n+  /**\n+   * Make displayable URI\n+   */\n+  uriForDisplay(uri) {\n+    const uri_display_trigger_length_k = 20;\n+    const uri_length_max_k = 40;\n+    let uri_display = uri || '';\n+    if (uri_display.length > uri_display_trigger_length_k) {\n+      let re = RegExp('^\\\\w+://([\\\\w./_-]+).*?([\\\\w._-]*)$');\n+      let matched = uri_display.match(re);\n+      if (matched && matched.length > 1) {\n+        const filename_k =\n+          matched[2].length < uri_length_max_k\n+            ? matched[2]\n+            : matched[2].slice(-uri_length_max_k);\n+        let prelude = matched[1].substr(0, uri_length_max_k);\n+        if (matched[1].length > uri_length_max_k) {\n+          prelude += '...';\n+        } else if (filename_k.length > 0) {\n+          prelude += ':';\n+        }\n+\n+        uri_display = prelude + filename_k;\n+      }\n+    }\n+    return uri_display;\n+  }\n+\n+  /**\n+   * Make anchored backlink\n+   */\n+  anchorMarkdownify(text, href, comment) {\n+    let text1 = (text || '').trim();\n+    let text1lc = text1.toLowerCase();\n+    let href1 = (href || '').trim();\n+    let href1lc = href1.toLowerCase();\n+    let comment1 = (comment || '').trim();\n+\n+    let retn = '';\n+\n+    if (text1.length < 1 && href1.length < 1) {\n+      // Intetionally blank\n+    } else if (text1lc === href1lc) {\n+      retn = ` <${href1}> `; // This renders correctly in Trello as a sole URL\n+      // NOTE (Ace, 17-Feb-2017): Turns out Trello doesn't support markdown [] only, so we'll construct a nice displayable text vs url:\n+      // text1 = this.uriForDisplay(text1);\n+    } else if (`mailto:${text1lc}` === href1lc) {\n+      retn = ` <${text1}> `; // This renders correctly in Trello as a mailto: url\n+    } else {\n+      const comment1QuotedSpaced = comment1.length > 0 ? ` \"${comment1}\"` : '';\n+      retn = ` [${text1}](<${href1}>${comment1QuotedSpaced}) `;\n+    }\n+\n+    return retn;\n+  }\n+\n+  /**\n+   * Split an email into name and domain\n+   */\n+  splitEmailDomain(email = '') {\n+    const split = email.split('@');\n+    const name = split[0] || '';\n+    const domain = split[1] || '';\n+    return {\n+      name,\n+      domain,\n+    };\n+  }\n+\n+  /**\n+   * Add trailing char if not empty:\n+   */\n+  addChar(front = '', back = '', addChar = ' ') {\n+    if (front.length > 0) {\n+      if (back.length > 0) {\n+        return `${front}${addChar}${back}`;\n+      } else {\n+        return `${front}${addChar}`;\n+      }\n+    } else if (back.length > 0) {\n+      return `${addChar}${back}`;\n+    } else {\n+      return '';\n+    }\n+  }\n+\n+  /**\n+   * Add trailing space if not empty:\n+   */\n+  addSpace(front = '', back = '') {\n+    return this.addChar(front, back, ' ');\n+  }\n+\n+  /**\n+   * Add trailing CRLF if not empty:\n+   */\n+  addCRLF(front = '', back = '') {\n+    return this.addChar(front, back, '\\n');\n+  }\n+\n+  /**\n+   * Markdownify a text block\n+   */\n+  markdownify($emailBody, features, preprocess) {\n+    if (!$emailBody || $emailBody.length < 1) {\n+      g2t_log('markdownify: Require emailBody!');\n+      return;\n+    }\n+    const self = this;\n+\n+    const min_text_length_k = 4;\n+    const max_replace_attempts_k = 10;\n+    const regexp_k = {\n+      begin: '(^|\\\\s+|<|\\\\[|\\\\(|\\\\b|(?=\\\\W+))',\n+      end: '($|\\\\s+|>|\\\\]|\\\\)|\\\\b|(?=\\\\W+))',\n+    };\n+    const unique_placeholder_k = 'g2t_placeholder:'; // Unique placeholder tag\n+\n+    let count = 0;\n+    let replacer_dict = {};\n+\n+    const featureEnabled = (elementTag = '') =>\n+      features === false ? false : features?.[elementTag] !== false;\n+\n+    let $html = $emailBody || ''; // Was: $emailBody.innerHTML || \"\";\n+    // let body = $emailBody.text() || \"\";\n+    let body = $emailBody.html() || '';\n+\n+    // Different encodings handle CRLF differently, so we'll process the main body as html and convert to text:\n+    // Convert paragraph marker to two returns:\n+    let replaced = body.replace(/\\s*[\\n\\r]*<p[^>]*>\\s*[\\n\\r]*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // Convert br marker to one return:\n+    replaced = body.replace(/\\s*[\\n\\r]*<br[^>]*>\\s*[\\n\\r]*/g, '\\n');\n+    body = replaced;\n+\n+    // Remove all other html markers:\n+    replaced = body.replace(/<[^>]*>/g, '');\n+    body = replaced;\n+\n+    // Decode HTML entities:\n+    replaced = self.decodeEntities(body);\n+    body = replaced;\n+\n+    // Replace hr:\n+    replaced = body.replace(/\\s*-{3,}\\s*/g, '---\\n');\n+    body = replaced;\n+\n+    // Convert crlf x 2 (or more) to paragraph markers:\n+    replaced = body.replace(/(\\s*[\\n\\r]\\s*){2,}/g, '<p />\\n');\n+    body = replaced;\n+\n+    let toProcess = {};\n+\n+    /**\n+     * 5 explicit steps in 3 passes:\n+     * (1) Collect tagged items\n+     * (2) Remove duplicates\n+     * (3) Sort force-lowercase by length\n+     * (4) Replace with placeholder\n+     * (5) Replace placeholders with final text\n+     */\n+    const sortAndPlaceholderize = function (tooProcess) {\n+      if (tooProcess) {\n+        g2t_each(\n+          Object.keys(tooProcess).sort(function (a, b) {\n+            // Go by order of largest to smallest\n+            return b.length - a.length;\n+          }),\n+          function (value) {\n+            const replace = tooProcess[value];\n+            const swap = `${unique_placeholder_k}${(count++).toString()}`;\n+            const re = new RegExp(\n+              regexp_k.begin + self.escapeRegExp(value) + regexp_k.end,\n+              'gi'\n+            );\n+            const replaced = body.replace(re, `%${swap}%`); // Replace occurance with placeholder\n+            if (body !== replaced) {\n+              body = replaced;\n+              replacer_dict[swap] = replace;\n+            }\n+          }\n+        );\n+      }\n+    };\n+    const processMarkdown = function (elementTag, replaceText) {\n+      if (elementTag && replaceText && featureEnabled(elementTag)) {\n+        toProcess = preprocess[elementTag] || {};\n+        $(elementTag, $html).each(function (index, value) {\n+          let text = ($(this).text() || '').trim();\n+          if (text && text.length > min_text_length_k) {\n+            let replace = self.replacer(replaceText, { text: text });\n+            toProcess[text.toLowerCase()] = replace; // Intentionally overwrites duplicates\n+          }\n+        });\n+        sortAndPlaceholderize(toProcess);\n+      }\n+    };\n+    /**\n+     * Repeat replace for max attempts or when done, whatever comes first\n+     */\n+    const repeatReplace = function (body, inRegexp, replaceWith) {\n+      let replace1 = '';\n+      for (let iter = max_replace_attempts_k; iter > 0; iter--) {\n+        replace1 = body.replace(inRegexp, replaceWith);\n+        if (body === replace1) {\n+          iter = 0; // All done\n+        } else {\n+          body = replace1;\n+        }\n+      }\n+      return body;\n+    };\n+\n+    // bullet lists:\n+    // ul li -> \" * \"\n+    processMarkdown('ul li', '<p />* %text%<p />');\n+\n+    // numeric lists:\n+    // ol li -> \" 1. \"\n+    processMarkdown('ol li', '<p />1. %text%<p />');\n+\n+    // headers:\n+    // H1 -> #\n+    // H2 -> ##\n+    // H3 -> ###\n+    // H4 -> ####\n+    // H5 -> #####\n+    // H6 -> ######\n+    if (featureEnabled('h')) {\n+      toProcess = preprocess['h'] || {};\n+      $(':header', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let nodeName = $(this).prop('nodeName') || '0';\n+        if (nodeName && text && text.length > min_text_length_k) {\n+          let x = nodeName.substr(-1);",
    "path": "chrome_manifest_v3/class_app.js",
    "commit_id": "3bbc7b0b5b5abfda366260c45d6f2cecebf28af3",
    "original_commit_id": "f609e1322b9a0f1b03b7094863f0c64a967e9df2",
    "user": {
      "login": "coderabbitai[bot]",
      "id": 136622811,
      "node_id": "BOT_kgDOCCSy2w",
      "avatar_url": "https://avatars.githubusercontent.com/in/347564?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/coderabbitai%5Bbot%5D",
      "html_url": "https://github.com/apps/coderabbitai",
      "followers_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "_🧹 Nitpick (assertive)_\n\n**All const. No reassignment.**\n\n```diff\n-        let text = ($(this).text() || '').trim();\n-        let nodeName = $(this).prop('nodeName') || '0';\n+        const text = ($(this).text() || '').trim();\n+        const nodeName = $(this).prop('nodeName') || '0';\n         if (nodeName && text && text.length > min_text_length_k) {\n-          let x = nodeName.substr(-1);\n+          const x = nodeName.substr(-1);\n```\n\nWhat now?\n\n<!-- suggestion_start -->\n\n<details>\n<summary>📝 Committable suggestion</summary>\n\n> ‼️ **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n        const text = ($(this).text() || '').trim();\n        const nodeName = $(this).prop('nodeName') || '0';\n        if (nodeName && text && text.length > min_text_length_k) {\n          const x = nodeName.substr(-1);\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>🧰 Tools</summary>\n\n<details>\n<summary>🪛 Biome (1.9.4)</summary>\n\n[error] 509-509: This let declares a variable that is only assigned once.\n\n'text' is never reassigned.\n\nSafe fix: Use const instead.\n\n\n(lint/style/useConst)\n\n---\n\n[error] 510-510: This let declares a variable that is only assigned once.\n\n'nodeName' is never reassigned.\n\nSafe fix: Use const instead.\n\n\n(lint/style/useConst)\n\n---\n\n[error] 512-512: This let declares a variable that is only assigned once.\n\n'x' is never reassigned.\n\nSafe fix: Use const instead.\n\n\n(lint/style/useConst)\n\n</details>\n\n</details>\n\n<details>\n<summary>🤖 Prompt for AI Agents</summary>\n\n```\nIn chrome_manifest_v3/class_app.js around lines 509 to 512, the variables text,\nnodeName, and x are declared with let but never reassigned. Change their\ndeclarations to const to follow best practices of using const for variables that\nare not reassigned.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:lion -->\n\n<!-- This is an auto-generated reply by CodeRabbit -->\n\n✅ Addressed in commit fa36711",
    "created_at": "2025-07-14T01:54:40Z",
    "updated_at": "2025-07-14T06:33:31Z",
    "html_url": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203704196",
    "pull_request_url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203704196"
      },
      "html": {
        "href": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203704196"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203704196/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 509,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 512,
    "side": "RIGHT",
    "original_position": 512,
    "position": null,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203833322",
    "pull_request_review_id": 3014751471,
    "id": 2203833322,
    "node_id": "PRRC_kwDOD1hYKM6DW9Pq",
    "diff_hunk": "@@ -0,0 +1,848 @@\n+/** Gmail2Trello Application - ES6 Class Version\n+ */\n+\n+var Gmail2Trello = Gmail2Trello || {}; // Namespace initialization - must be var to guarantee correct scope\n+\n+class App {\n+  constructor() {\n+    this.CHROME_SETTINGS_ID = 'g2t_user_settings';\n+    this.UNIQUE_URI_VAR = 'g2t_filename';\n+\n+    this.model = new Gmail2Trello.Model(this);\n+    this.gmailView = new Gmail2Trello.GmailView(this);\n+    this.popupView = new Gmail2Trello.PopupView(this);\n+\n+    this.bindEvents();\n+  }\n+\n+  bindEvents() {\n+    const self = this;\n+\n+    /*** Data's events binding ***/\n+    this.model.event.addListener('onBeforeAuthorize', function () {\n+      self.popupView.bindData(''); // Intentionally blank\n+      self.popupView.showMessage(self, 'Authorizing...');\n+    });\n+\n+    this.model.event.addListener('onAuthorizeFail', function () {\n+      // self.model.isInitialized = false;\n+      self.popupView.showMessage(\n+        self,\n+        'Trello authorization failed <button id=\"showsignout\">Sign out and try again</button>'\n+      );\n+    });\n+\n+    this.model.event.addListener('onAuthorized', function () {\n+      // g2t_log('onAuthorized');\n+      // g2t_log(\"Status: \" + Trello.authorized().toString());\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+    });\n+\n+    this.model.event.addListener('onBeforeLoadTrello', function () {\n+      self.popupView.showMessage(self, 'Loading Trello data...');\n+    });\n+\n+    this.model.event.addListener('onTrelloDataReady', function () {\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+\n+      self.popupView.bindData(self.model);\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloListSuccess', function () {\n+      self.popupView.updateLists();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloCardsSuccess', function () {\n+      self.popupView.updateCards();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloLabelsSuccess', function () {\n+      self.popupView.updateLabels();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloMembersSuccess', function () {\n+      self.popupView.updateMembers();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener(\n+      'onCardSubmitComplete',\n+      function (target, params) {\n+        self.popupView.displaySubmitCompleteForm();\n+        // If card lists or labels have been updated, reload:\n+        const data_k = params?.data || {};\n+        const emailId = data_k?.emailId || 0;\n+        const boardId_k = data_k?.data?.board?.id || 0;\n+        const listId_k = data_k?.data?.list?.id || 0;\n+        const cardId_k = data_k?.data?.card?.id || 0;\n+        const idBoard_k = data_k?.idBoard || 0;\n+        const idList_k = data_k?.idList || 0;\n+        const idCard_k = data_k?.idCard || 0;\n+        const boardId = boardId_k || idBoard_k || 0;\n+        const listId = listId_k || idList_k || 0;\n+        const cardId = cardId_k || idCard_k || 0;\n+        // NOTE (acoven@2020-05-23): Users expect when creating a brand new card,\n+        // we'll remember that new card ID and then keep defaulting to it for\n+        // subsequent updates to that email. That means we'll have to get the return\n+        // value/url from Trello and dissect that, potentially doing this update\n+        // in that routine:\n+        self.model.emailBoardListCardMapUpdate({\n+          emailId,\n+          boardId,\n+          listId,\n+          cardId,\n+        });\n+\n+        if (boardId) {\n+          self.model.loadTrelloLabels(boardId);\n+          self.model.loadTrelloMembers(boardId);\n+        }\n+        if (listId) {\n+          self.model.loadTrelloCards(listId);\n+        }\n+      }\n+    );\n+\n+    this.model.event.addListener('onAPIFailure', function (target, params) {\n+      self.popupView.displayAPIFailedForm(params);\n+    });\n+\n+    /*** PopupView's events binding ***/\n+\n+    this.popupView.event.addListener('onPopupVisible', function () {\n+      if (!self.model.isInitialized) {\n+        self.popupView.showMessage(self, 'Initializing...');\n+        self.popupView.$popupContent.hide();\n+        self.model.init();\n+      } else {\n+        self.popupView.reset();\n+      }\n+\n+      const trelloUser_k = self?.model?.trello?.user || {};\n+      const fullName = trelloUser_k?.fullName || '';\n+\n+      self.gmailView.parsingData = false;\n+      self.model.gmail = self.gmailView.parseData({ fullName });\n+      self.popupView.bindGmailData(self.model.gmail);\n+      self.popupView.event.fire('periodicChecks');\n+    });\n+\n+    this.popupView.event.addListener('periodicChecks', function () {\n+      setTimeout(function () {\n+        self.popupView.periodicChecks();\n+      }, 3000);\n+    });\n+\n+    this.popupView.event.addListener('onBoardChanged', function (target, params) {\n+      let boardId = params.boardId;\n+      if (boardId !== '_' && boardId !== '' && boardId !== null) {\n+        self.model.loadTrelloLists(boardId);\n+        self.model.loadTrelloLabels(boardId);\n+        self.model.loadTrelloMembers(boardId);\n+      }\n+    });\n+\n+    this.popupView.event.addListener('onListChanged', function (target, params) {\n+      let listId = params.listId;\n+      self.model.loadTrelloCards(listId);\n+    });\n+\n+    this.popupView.event.addListener('onSubmit', function () {\n+      self.model.submit();\n+    });\n+\n+    this.popupView.event.addListener('checkTrelloAuthorized', function () {\n+      self.popupView.showMessage(self, 'Authorizing...');\n+      self.model.checkTrelloAuthorized();\n+    });\n+\n+    this.popupView.event.addListener('onRequestDeauthorizeTrello', function () {\n+      g2t_log('onRequestDeauthorizeTrello');\n+      self.model.deauthorizeTrello();\n+      self.popupView.clearBoard();\n+    });\n+\n+    const eventDetectButton = function () {\n+      if (self.gmailView.preDetect()) {\n+        self.popupView.$toolBar = self.gmailView.$toolBar;\n+        self.popupView.confirmPopup();\n+      }\n+    };\n+\n+    this.popupView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    // GMailView's events:\n+\n+    this.gmailView.event.addListener('onDetected', function () {\n+      self.popupView.$toolBar = self.gmailView.$toolBar;\n+      self.popupView.init();\n+    });\n+\n+    this.gmailView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    chrome.runtime.onMessage.addListener(function (\n+      request,\n+      sender,\n+      sendResponse\n+    ) {\n+      if (request?.message === 'g2t_keyboard_shortcut') {\n+        self.popupView.showPopup();\n+      }\n+    });\n+  }\n+\n+  updateData() {\n+    const self = this;\n+\n+    const fullName = self?.model?.trello?.user?.fullName || '';\n+\n+    self.popupView.bindData(self.model);\n+\n+    self.gmailView.parsingData = false;\n+    self.model.gmail = self.gmailView.parseData({ fullName });\n+    self.popupView.bindGmailData(self.model.gmail);\n+  }\n+\n+  initialize() {\n+    const self = this;\n+\n+    this.model.isInitialized = false;\n+\n+    // g2t_log('App:initialize');\n+\n+    this.gmailView.detect();\n+\n+    service = analytics.getService('gmail-2-trello');\n+\n+    // Get a Tracker using your Google Analytics app Tracking ID.\n+    tracker = service.getTracker('G-0QPEDL7YDL'); // Was: UA-8469046-1 -> UA-42442437-4\n+\n+    // Record an \"appView\" each time the user launches your app or goes to a new\n+    // screen within the app.\n+    tracker.sendAppView('PopupView');\n+  }\n+\n+  /**\n+   * Correctly escape RegExp\n+   */\n+  escapeRegExp(str) {\n+    return str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n+  }\n+\n+  /**\n+   * Utility routine to replace variables\n+   */\n+  replacer(text, dict) {\n+    let self = this;\n+\n+    if (!text || text.length < 1) {\n+      // g2t_log('Require text!');\n+      return '';\n+    } else if (!dict || dict.length < 2) {\n+      g2t_log('replacer: Require dictionary!');\n+      return text;\n+    }\n+\n+    let re, new_text;\n+    const replacify = function () {\n+      g2t_each(dict, function (value, key) {\n+        re = new RegExp(`%${self.escapeRegExp(key)}%`, 'gi');\n+        new_text = text.replace(re, value);\n+        text = new_text;\n+      });\n+    };\n+\n+    let runaway_max = 3;\n+    while (text.indexOf('%') !== -1 && runaway_max-- > 0) {\n+      replacify();\n+    }\n+\n+    return text;\n+  }\n+\n+  /**\n+   * Make displayable URI\n+   */\n+  uriForDisplay(uri) {\n+    const uri_display_trigger_length_k = 20;\n+    const uri_length_max_k = 40;\n+    let uri_display = uri || '';\n+    if (uri_display.length > uri_display_trigger_length_k) {\n+      let re = RegExp('^\\\\w+://([\\\\w./_-]+).*?([\\\\w._-]*)$');\n+      let matched = uri_display.match(re);\n+      if (matched && matched.length > 1) {\n+        const filename_k =\n+          matched[2].length < uri_length_max_k\n+            ? matched[2]\n+            : matched[2].slice(-uri_length_max_k);\n+        let prelude = matched[1].substr(0, uri_length_max_k);\n+        if (matched[1].length > uri_length_max_k) {\n+          prelude += '...';\n+        } else if (filename_k.length > 0) {\n+          prelude += ':';\n+        }\n+\n+        uri_display = prelude + filename_k;\n+      }\n+    }\n+    return uri_display;\n+  }\n+\n+  /**\n+   * Make anchored backlink\n+   */\n+  anchorMarkdownify(text, href, comment) {\n+    let text1 = (text || '').trim();\n+    let text1lc = text1.toLowerCase();\n+    let href1 = (href || '').trim();\n+    let href1lc = href1.toLowerCase();\n+    let comment1 = (comment || '').trim();\n+\n+    let retn = '';\n+\n+    if (text1.length < 1 && href1.length < 1) {\n+      // Intetionally blank\n+    } else if (text1lc === href1lc) {\n+      retn = ` <${href1}> `; // This renders correctly in Trello as a sole URL\n+      // NOTE (Ace, 17-Feb-2017): Turns out Trello doesn't support markdown [] only, so we'll construct a nice displayable text vs url:\n+      // text1 = this.uriForDisplay(text1);\n+    } else if (`mailto:${text1lc}` === href1lc) {\n+      retn = ` <${text1}> `; // This renders correctly in Trello as a mailto: url\n+    } else {\n+      const comment1QuotedSpaced = comment1.length > 0 ? ` \"${comment1}\"` : '';\n+      retn = ` [${text1}](<${href1}>${comment1QuotedSpaced}) `;\n+    }\n+\n+    return retn;\n+  }\n+\n+  /**\n+   * Split an email into name and domain\n+   */\n+  splitEmailDomain(email = '') {\n+    const split = email.split('@');\n+    const name = split[0] || '';\n+    const domain = split[1] || '';\n+    return {\n+      name,\n+      domain,\n+    };\n+  }\n+\n+  /**\n+   * Add trailing char if not empty:\n+   */\n+  addChar(front = '', back = '', addChar = ' ') {\n+    if (front.length > 0) {\n+      if (back.length > 0) {\n+        return `${front}${addChar}${back}`;\n+      } else {\n+        return `${front}${addChar}`;\n+      }\n+    } else if (back.length > 0) {\n+      return `${addChar}${back}`;\n+    } else {\n+      return '';\n+    }\n+  }\n+\n+  /**\n+   * Add trailing space if not empty:\n+   */\n+  addSpace(front = '', back = '') {\n+    return this.addChar(front, back, ' ');\n+  }\n+\n+  /**\n+   * Add trailing CRLF if not empty:\n+   */\n+  addCRLF(front = '', back = '') {\n+    return this.addChar(front, back, '\\n');\n+  }\n+\n+  /**\n+   * Markdownify a text block\n+   */\n+  markdownify($emailBody, features, preprocess) {\n+    if (!$emailBody || $emailBody.length < 1) {\n+      g2t_log('markdownify: Require emailBody!');\n+      return;\n+    }\n+    const self = this;\n+\n+    const min_text_length_k = 4;\n+    const max_replace_attempts_k = 10;\n+    const regexp_k = {\n+      begin: '(^|\\\\s+|<|\\\\[|\\\\(|\\\\b|(?=\\\\W+))',\n+      end: '($|\\\\s+|>|\\\\]|\\\\)|\\\\b|(?=\\\\W+))',\n+    };\n+    const unique_placeholder_k = 'g2t_placeholder:'; // Unique placeholder tag\n+\n+    let count = 0;\n+    let replacer_dict = {};\n+\n+    const featureEnabled = (elementTag = '') =>\n+      features === false ? false : features?.[elementTag] !== false;\n+\n+    let $html = $emailBody || ''; // Was: $emailBody.innerHTML || \"\";\n+    // let body = $emailBody.text() || \"\";\n+    let body = $emailBody.html() || '';\n+\n+    // Different encodings handle CRLF differently, so we'll process the main body as html and convert to text:\n+    // Convert paragraph marker to two returns:\n+    let replaced = body.replace(/\\s*[\\n\\r]*<p[^>]*>\\s*[\\n\\r]*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // Convert br marker to one return:\n+    replaced = body.replace(/\\s*[\\n\\r]*<br[^>]*>\\s*[\\n\\r]*/g, '\\n');\n+    body = replaced;\n+\n+    // Remove all other html markers:\n+    replaced = body.replace(/<[^>]*>/g, '');\n+    body = replaced;\n+\n+    // Decode HTML entities:\n+    replaced = self.decodeEntities(body);\n+    body = replaced;\n+\n+    // Replace hr:\n+    replaced = body.replace(/\\s*-{3,}\\s*/g, '---\\n');\n+    body = replaced;\n+\n+    // Convert crlf x 2 (or more) to paragraph markers:\n+    replaced = body.replace(/(\\s*[\\n\\r]\\s*){2,}/g, '<p />\\n');\n+    body = replaced;\n+\n+    let toProcess = {};\n+\n+    /**\n+     * 5 explicit steps in 3 passes:\n+     * (1) Collect tagged items\n+     * (2) Remove duplicates\n+     * (3) Sort force-lowercase by length\n+     * (4) Replace with placeholder\n+     * (5) Replace placeholders with final text\n+     */\n+    const sortAndPlaceholderize = function (tooProcess) {\n+      if (tooProcess) {\n+        g2t_each(\n+          Object.keys(tooProcess).sort(function (a, b) {\n+            // Go by order of largest to smallest\n+            return b.length - a.length;\n+          }),\n+          function (value) {\n+            const replace = tooProcess[value];\n+            const swap = `${unique_placeholder_k}${(count++).toString()}`;\n+            const re = new RegExp(\n+              regexp_k.begin + self.escapeRegExp(value) + regexp_k.end,\n+              'gi'\n+            );\n+            const replaced = body.replace(re, `%${swap}%`); // Replace occurance with placeholder\n+            if (body !== replaced) {\n+              body = replaced;\n+              replacer_dict[swap] = replace;\n+            }\n+          }\n+        );\n+      }\n+    };\n+    const processMarkdown = function (elementTag, replaceText) {\n+      if (elementTag && replaceText && featureEnabled(elementTag)) {\n+        toProcess = preprocess[elementTag] || {};\n+        $(elementTag, $html).each(function (index, value) {\n+          let text = ($(this).text() || '').trim();\n+          if (text && text.length > min_text_length_k) {\n+            let replace = self.replacer(replaceText, { text: text });\n+            toProcess[text.toLowerCase()] = replace; // Intentionally overwrites duplicates\n+          }\n+        });\n+        sortAndPlaceholderize(toProcess);\n+      }\n+    };\n+    /**\n+     * Repeat replace for max attempts or when done, whatever comes first\n+     */\n+    const repeatReplace = function (body, inRegexp, replaceWith) {\n+      let replace1 = '';\n+      for (let iter = max_replace_attempts_k; iter > 0; iter--) {\n+        replace1 = body.replace(inRegexp, replaceWith);\n+        if (body === replace1) {\n+          iter = 0; // All done\n+        } else {\n+          body = replace1;\n+        }\n+      }\n+      return body;\n+    };\n+\n+    // bullet lists:\n+    // ul li -> \" * \"\n+    processMarkdown('ul li', '<p />* %text%<p />');\n+\n+    // numeric lists:\n+    // ol li -> \" 1. \"\n+    processMarkdown('ol li', '<p />1. %text%<p />');\n+\n+    // headers:\n+    // H1 -> #\n+    // H2 -> ##\n+    // H3 -> ###\n+    // H4 -> ####\n+    // H5 -> #####\n+    // H6 -> ######\n+    if (featureEnabled('h')) {\n+      toProcess = preprocess['h'] || {};\n+      $(':header', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let nodeName = $(this).prop('nodeName') || '0';\n+        if (nodeName && text && text.length > min_text_length_k) {\n+          let x = nodeName.substr(-1);\n+          toProcess[text.toLowerCase()] = `\\n${'#'.repeat(x)} ${text}\\n`; // Intentionally overwrites duplicates\n+        }\n+      });\n+      sortAndPlaceholderize(toProcess);\n+    }\n+\n+    replaced = this.replacer(body, replacer_dict); // Replace initial batch of <div> like placeholders\n+    body = replaced;\n+    replacer_dict = {}; // Reset\n+    count = 0; // Reset\n+\n+    // bold: b -> **text**\n+    processMarkdown('b', ' **%text%** ');\n+\n+    // italics: i -> _text_\n+    processMarkdown('i', ' _%text%_ ');\n+\n+    // links:\n+    // a -> [text](html)\n+    if (featureEnabled('a')) {\n+      toProcess = preprocess['a'] || {};\n+      $('a', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let href = ($(this).prop('href') || '').trim(); // Was attr\n+        /*\n+              var uri_display = self.uriForDisplay(href);\n+              var comment = ' \"' + text + ' via ' + uri_display + '\"';\n+              var re = new RegExp(self.escapeRegExp(text), \"i\");\n+              if (uri.match(re)) {\n+                  comment = ' \"Open ' + uri_display + '\"';\n+              }\n+              */\n+        if (href && text && text.length >= min_text_length_k) {\n+          toProcess[text.toLowerCase()] = self.anchorMarkdownify(text, href); // Comment seemed like too much extra text // Intentionally overwrites duplicates\n+        }\n+      });\n+      sortAndPlaceholderize(toProcess);\n+    }\n+\n+    /* DISABLED (Ace, 16-Jan-2017): Images kinda make a mess, until requested lets not markdownify them:\n+      // images:\n+      // img -> ![alt_text](html)\n+      if (featureEnabled('img')) {\n+          $('img', $html).each(function(index, value) {\n+              var text = ($(this).prop(\"alt\") || \"\").trim(); // Was attr\n+              var href = ($(this).prop(\"src\") || \"\").trim(); // Was attr\n+              // var uri_display = self.uriForDisplay(href);\n+              if (href && text && text.length >= min_text_length_k) {\n+                  toProcess[text.toLowerCase()] = self.anchorMarkdownify(text, href); // Comment seemed like too much extra text // Intentionally overwrites duplicates\n+              }\n+          });\n+          sortAndPlaceholderize(toProcess);\n+      }\n+      */\n+\n+    replaced = this.replacer(body, replacer_dict); // Replace second batch of <span> like placeholders\n+    body = replaced;\n+\n+    // Replace bullets following a CRLF:\n+    replaced = body.replace(/\\s*[\\n\\r]+\\s*[·-]+\\s*/g, '<p />* '); // = [\\u00B7\\u2022]\n+    body = replaced;\n+\n+    // Replace remaining bullets with asterisks:\n+    replaced = body.replace(/[·]/g, '*');\n+    body = replaced;\n+\n+    // ORDER MATTERS FOR THIS NEXT SET:\n+    // (1) Replace <space>CRLF<space> with just CR:\n+    replaced = body.replace(/\\s*[\\n\\r]+\\s*/g, '\\n');\n+    body = replaced;\n+\n+    // (2) Replace 2 or more spaces with just one:\n+    replaced = repeatReplace(body, new RegExp('\\\\s{2,}', 'g'), ' ');\n+    body = replaced;\n+\n+    // (3) Replace paragraph markers with CR+CR:\n+    replaced = body.replace(/\\s*<p \\/>\\s*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // (4) Replace 3 or more CRs with just two:\n+    replaced = repeatReplace(body, new RegExp('\\\\n{3,}', 'g'), '\\n\\n');\n+    body = replaced;\n+\n+    // (5) Trim excess at beginning and end:\n+    replaced = body.trim();\n+    body = replaced;\n+\n+    return body;\n+  }\n+\n+  /**\n+   * Determine luminance of a color so we can augment with darker/lighter background\n+   */\n+  luminance(color) {\n+    let bkColorLight = 'lightGray'; // or white\n+    let bkColorDark = 'darkGray'; // 'gray' is even darker\n+    let bkColorReturn = bkColorLight;\n+\n+    let re = new RegExp('rgb\\\\D+(\\\\d+)\\\\D+(\\\\d+)\\\\D+(\\\\d+)');\n+    let matched = color.match(re, 'i');\n+    if (matched && matched.length > 2) {\n+      // 0 is total string:\n+      let r = matched[1];\n+      let g = matched[2];\n+      let b = matched[3];\n+      // var 1 = matched[4]; // if alpha is provided\n+\n+      let luma = 0.2126 * r + 0.7152 * g + 0.0722 * b; // per ITU-R BT.709\n+\n+      if (luma < 40) {\n+        bkColorReturn = bkColorDark;\n+      } else {\n+        bkColorReturn = bkColorLight;\n+      }\n+    } else {\n+      bkColorReturn = bkColorLight; // RegExp failed, assume dark color\n+    }\n+\n+    return 'inherit'; // Use: bkColorReturn if you want to adjust background based on text perceived brightness\n+  }\n+\n+  /**\n+   * HTML bookend a string\n+   */\n+  bookend(bookend, text, style) {\n+    return (\n+      '<' +\n+      bookend +\n+      (style ? ' style=\"' + style + '\"' : '') +\n+      '>' +\n+      (text || '') +\n+      '</' +\n+      bookend +\n+      '>'\n+    );\n+  }\n+\n+  /**\n+   * Get selected text\n+   * http://stackoverflow.com/questions/5379120/get-the-highlighted-selected-text\n+   */\n+  getSelectedText() {\n+    let text = '';\n+    let activeEl = document.activeElement;\n+    let activeElTagName = activeEl ? activeEl.tagName.toLowerCase() : null;\n+    if (\n+      (activeElTagName == 'textarea' || activeElTagName == 'input') &&\n+      /^(?:text|search|password|tel|url)$/i.test(activeEl.type) &&\n+      typeof activeEl.selectionStart == 'number'\n+    ) {\n+      text = activeEl.value\n+        .slice(activeEl.selectionStart, activeEl.selectionEnd)\n+        .trim();\n+    } else if (document.selection) {\n+      text = document.selection.createRange().text.trim();\n+    } else if (document.getSelection) {\n+      text = document.getSelection().toString().trim();\n+    } else if (window.getSelection) {\n+      text = window.getSelection().toString().trim();\n+    }\n+    return text;\n+  }\n+\n+  /**\n+   * Truncate a string\n+   */\n+  truncate(text, max, add) {\n+    let retn = text || '';\n+    const add_k = this.decodeEntities(add || '');\n+    const max_k = max - add_k.length;\n+\n+    if (text && text.length > max_k) {\n+      retn = text.slice(0, max_k) + add_k;\n+    }\n+    return retn;\n+  }\n+\n+  /***\n+   * Middle-truncate a string\n+   */\n+  midTruncate(text, max, add) {\n+    let retn = text || '';\n+    const add_k = this.decodeEntities(add || '');\n+    const max_k = Math.abs((max || 0) - add_k.length);\n+    const mid_k = (max_k + 0.01) / 2;\n+\n+    if (text && text.length > max_k) {\n+      retn = text.slice(0, mid_k + 1) + add_k + text.slice(-mid_k);\n+    }\n+    return retn;\n+  }\n+\n+  /**\n+   * Load settings\n+   */\n+  loadSettings(popup) {\n+    const self = this;\n+    const setID = self.CHROME_SETTINGS_ID;\n+    chrome.storage.sync.get(setID, function (response) {\n+      if (response?.[setID]) {\n+        // NOTE (Ace, 7-Feb-2017): Might need to store these off the app object:\n+        try {\n+          self.popupView.data.settings = JSON.parse(response[setID]);\n+        } catch (err) {\n+          g2t_log(\n+            'loadSettings: JSON parse failed! Error: ' + JSON.stringify(err)\n+          );\n+        }\n+      }\n+      if (popup) {\n+        popup.init_popup();\n+        self.updateData();\n+      }\n+    });\n+  }\n+\n+  /**\n+   * Save settings\n+   */\n+  saveSettings() {\n+    const self = this;\n+    const setID = self.CHROME_SETTINGS_ID;\n+    let settings = Object.assign({}, self.popupView.data.settings);\n+\n+    // Delete large, potentially needing secure, data bits:\n+    settings.description = '';\n+    settings.title = '';\n+    settings.attachments = [];\n+    settings.images = [];\n+    delete settings.description;\n+    delete settings.title;\n+    delete settings.attachments;\n+    delete settings.images;\n+\n+    const settings_string_k = JSON.stringify(settings);\n+\n+    hash = {};\n+    hash[setID] = settings_string_k;",
    "path": "chrome_manifest_v3/class_app.js",
    "commit_id": "3bbc7b0b5b5abfda366260c45d6f2cecebf28af3",
    "original_commit_id": "ae0a391b6759338b0ec3c3292da07e458841ab71",
    "user": {
      "login": "acoven",
      "id": 1631902,
      "node_id": "MDQ6VXNlcjE2MzE5MDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1631902?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/acoven",
      "html_url": "https://github.com/acoven",
      "followers_url": "https://api.github.com/users/acoven/followers",
      "following_url": "https://api.github.com/users/acoven/following{/other_user}",
      "gists_url": "https://api.github.com/users/acoven/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/acoven/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/acoven/subscriptions",
      "organizations_url": "https://api.github.com/users/acoven/orgs",
      "repos_url": "https://api.github.com/users/acoven/repos",
      "events_url": "https://api.github.com/users/acoven/events{/privacy}",
      "received_events_url": "https://api.github.com/users/acoven/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "@coderabbitai Remember I don’t want const on object array hash refs if they change, it’s semantically confusing. Fix this to be “let”",
    "created_at": "2025-07-14T04:39:29Z",
    "updated_at": "2025-07-14T04:40:37Z",
    "html_url": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203833322",
    "pull_request_url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203833322"
      },
      "html": {
        "href": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203833322"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203833322/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 1
    },
    "start_line": null,
    "original_start_line": 745,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 746,
    "side": "RIGHT",
    "in_reply_to_id": 2203532553,
    "original_position": 746,
    "position": null,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203833807",
    "pull_request_review_id": 3014752001,
    "id": 2203833807,
    "node_id": "PRRC_kwDOD1hYKM6DW9XP",
    "diff_hunk": "@@ -0,0 +1,848 @@\n+/** Gmail2Trello Application - ES6 Class Version\n+ */\n+\n+var Gmail2Trello = Gmail2Trello || {}; // Namespace initialization - must be var to guarantee correct scope\n+\n+class App {\n+  constructor() {\n+    this.CHROME_SETTINGS_ID = 'g2t_user_settings';\n+    this.UNIQUE_URI_VAR = 'g2t_filename';\n+\n+    this.model = new Gmail2Trello.Model(this);\n+    this.gmailView = new Gmail2Trello.GmailView(this);\n+    this.popupView = new Gmail2Trello.PopupView(this);\n+\n+    this.bindEvents();\n+  }\n+\n+  bindEvents() {\n+    const self = this;\n+\n+    /*** Data's events binding ***/\n+    this.model.event.addListener('onBeforeAuthorize', function () {\n+      self.popupView.bindData(''); // Intentionally blank\n+      self.popupView.showMessage(self, 'Authorizing...');\n+    });\n+\n+    this.model.event.addListener('onAuthorizeFail', function () {\n+      // self.model.isInitialized = false;\n+      self.popupView.showMessage(\n+        self,\n+        'Trello authorization failed <button id=\"showsignout\">Sign out and try again</button>'\n+      );\n+    });\n+\n+    this.model.event.addListener('onAuthorized', function () {\n+      // g2t_log('onAuthorized');\n+      // g2t_log(\"Status: \" + Trello.authorized().toString());\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+    });\n+\n+    this.model.event.addListener('onBeforeLoadTrello', function () {\n+      self.popupView.showMessage(self, 'Loading Trello data...');\n+    });\n+\n+    this.model.event.addListener('onTrelloDataReady', function () {\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+\n+      self.popupView.bindData(self.model);\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloListSuccess', function () {\n+      self.popupView.updateLists();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloCardsSuccess', function () {\n+      self.popupView.updateCards();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloLabelsSuccess', function () {\n+      self.popupView.updateLabels();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloMembersSuccess', function () {\n+      self.popupView.updateMembers();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener(\n+      'onCardSubmitComplete',\n+      function (target, params) {\n+        self.popupView.displaySubmitCompleteForm();\n+        // If card lists or labels have been updated, reload:\n+        const data_k = params?.data || {};\n+        const emailId = data_k?.emailId || 0;\n+        const boardId_k = data_k?.data?.board?.id || 0;\n+        const listId_k = data_k?.data?.list?.id || 0;\n+        const cardId_k = data_k?.data?.card?.id || 0;\n+        const idBoard_k = data_k?.idBoard || 0;\n+        const idList_k = data_k?.idList || 0;\n+        const idCard_k = data_k?.idCard || 0;\n+        const boardId = boardId_k || idBoard_k || 0;\n+        const listId = listId_k || idList_k || 0;\n+        const cardId = cardId_k || idCard_k || 0;\n+        // NOTE (acoven@2020-05-23): Users expect when creating a brand new card,\n+        // we'll remember that new card ID and then keep defaulting to it for\n+        // subsequent updates to that email. That means we'll have to get the return\n+        // value/url from Trello and dissect that, potentially doing this update\n+        // in that routine:\n+        self.model.emailBoardListCardMapUpdate({\n+          emailId,\n+          boardId,\n+          listId,\n+          cardId,\n+        });\n+\n+        if (boardId) {\n+          self.model.loadTrelloLabels(boardId);\n+          self.model.loadTrelloMembers(boardId);\n+        }\n+        if (listId) {\n+          self.model.loadTrelloCards(listId);\n+        }\n+      }\n+    );\n+\n+    this.model.event.addListener('onAPIFailure', function (target, params) {\n+      self.popupView.displayAPIFailedForm(params);\n+    });\n+\n+    /*** PopupView's events binding ***/\n+\n+    this.popupView.event.addListener('onPopupVisible', function () {\n+      if (!self.model.isInitialized) {\n+        self.popupView.showMessage(self, 'Initializing...');\n+        self.popupView.$popupContent.hide();\n+        self.model.init();\n+      } else {\n+        self.popupView.reset();\n+      }\n+\n+      const trelloUser_k = self?.model?.trello?.user || {};\n+      const fullName = trelloUser_k?.fullName || '';\n+\n+      self.gmailView.parsingData = false;\n+      self.model.gmail = self.gmailView.parseData({ fullName });\n+      self.popupView.bindGmailData(self.model.gmail);\n+      self.popupView.event.fire('periodicChecks');\n+    });\n+\n+    this.popupView.event.addListener('periodicChecks', function () {\n+      setTimeout(function () {\n+        self.popupView.periodicChecks();\n+      }, 3000);\n+    });\n+\n+    this.popupView.event.addListener('onBoardChanged', function (target, params) {\n+      let boardId = params.boardId;\n+      if (boardId !== '_' && boardId !== '' && boardId !== null) {\n+        self.model.loadTrelloLists(boardId);\n+        self.model.loadTrelloLabels(boardId);\n+        self.model.loadTrelloMembers(boardId);\n+      }\n+    });\n+\n+    this.popupView.event.addListener('onListChanged', function (target, params) {\n+      let listId = params.listId;\n+      self.model.loadTrelloCards(listId);\n+    });\n+\n+    this.popupView.event.addListener('onSubmit', function () {\n+      self.model.submit();\n+    });\n+\n+    this.popupView.event.addListener('checkTrelloAuthorized', function () {\n+      self.popupView.showMessage(self, 'Authorizing...');\n+      self.model.checkTrelloAuthorized();\n+    });\n+\n+    this.popupView.event.addListener('onRequestDeauthorizeTrello', function () {\n+      g2t_log('onRequestDeauthorizeTrello');\n+      self.model.deauthorizeTrello();\n+      self.popupView.clearBoard();\n+    });\n+\n+    const eventDetectButton = function () {\n+      if (self.gmailView.preDetect()) {\n+        self.popupView.$toolBar = self.gmailView.$toolBar;\n+        self.popupView.confirmPopup();\n+      }\n+    };\n+\n+    this.popupView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    // GMailView's events:\n+\n+    this.gmailView.event.addListener('onDetected', function () {\n+      self.popupView.$toolBar = self.gmailView.$toolBar;\n+      self.popupView.init();\n+    });\n+\n+    this.gmailView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    chrome.runtime.onMessage.addListener(function (\n+      request,\n+      sender,\n+      sendResponse\n+    ) {\n+      if (request?.message === 'g2t_keyboard_shortcut') {\n+        self.popupView.showPopup();\n+      }\n+    });\n+  }\n+\n+  updateData() {\n+    const self = this;\n+\n+    const fullName = self?.model?.trello?.user?.fullName || '';\n+\n+    self.popupView.bindData(self.model);\n+\n+    self.gmailView.parsingData = false;\n+    self.model.gmail = self.gmailView.parseData({ fullName });\n+    self.popupView.bindGmailData(self.model.gmail);\n+  }\n+\n+  initialize() {\n+    const self = this;\n+\n+    this.model.isInitialized = false;\n+\n+    // g2t_log('App:initialize');\n+\n+    this.gmailView.detect();\n+\n+    service = analytics.getService('gmail-2-trello');\n+\n+    // Get a Tracker using your Google Analytics app Tracking ID.\n+    tracker = service.getTracker('G-0QPEDL7YDL'); // Was: UA-8469046-1 -> UA-42442437-4\n+\n+    // Record an \"appView\" each time the user launches your app or goes to a new\n+    // screen within the app.\n+    tracker.sendAppView('PopupView');\n+  }\n+\n+  /**\n+   * Correctly escape RegExp\n+   */\n+  escapeRegExp(str) {\n+    return str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n+  }\n+\n+  /**\n+   * Utility routine to replace variables\n+   */\n+  replacer(text, dict) {\n+    let self = this;\n+\n+    if (!text || text.length < 1) {\n+      // g2t_log('Require text!');\n+      return '';\n+    } else if (!dict || dict.length < 2) {\n+      g2t_log('replacer: Require dictionary!');\n+      return text;\n+    }\n+\n+    let re, new_text;\n+    const replacify = function () {\n+      g2t_each(dict, function (value, key) {\n+        re = new RegExp(`%${self.escapeRegExp(key)}%`, 'gi');\n+        new_text = text.replace(re, value);\n+        text = new_text;\n+      });\n+    };\n+\n+    let runaway_max = 3;\n+    while (text.indexOf('%') !== -1 && runaway_max-- > 0) {\n+      replacify();\n+    }\n+\n+    return text;\n+  }\n+\n+  /**\n+   * Make displayable URI\n+   */\n+  uriForDisplay(uri) {\n+    const uri_display_trigger_length_k = 20;\n+    const uri_length_max_k = 40;\n+    let uri_display = uri || '';\n+    if (uri_display.length > uri_display_trigger_length_k) {\n+      let re = RegExp('^\\\\w+://([\\\\w./_-]+).*?([\\\\w._-]*)$');\n+      let matched = uri_display.match(re);\n+      if (matched && matched.length > 1) {\n+        const filename_k =\n+          matched[2].length < uri_length_max_k\n+            ? matched[2]\n+            : matched[2].slice(-uri_length_max_k);\n+        let prelude = matched[1].substr(0, uri_length_max_k);\n+        if (matched[1].length > uri_length_max_k) {\n+          prelude += '...';\n+        } else if (filename_k.length > 0) {\n+          prelude += ':';\n+        }\n+\n+        uri_display = prelude + filename_k;\n+      }\n+    }\n+    return uri_display;\n+  }\n+\n+  /**\n+   * Make anchored backlink\n+   */\n+  anchorMarkdownify(text, href, comment) {\n+    let text1 = (text || '').trim();\n+    let text1lc = text1.toLowerCase();\n+    let href1 = (href || '').trim();\n+    let href1lc = href1.toLowerCase();\n+    let comment1 = (comment || '').trim();\n+\n+    let retn = '';\n+\n+    if (text1.length < 1 && href1.length < 1) {\n+      // Intetionally blank\n+    } else if (text1lc === href1lc) {\n+      retn = ` <${href1}> `; // This renders correctly in Trello as a sole URL\n+      // NOTE (Ace, 17-Feb-2017): Turns out Trello doesn't support markdown [] only, so we'll construct a nice displayable text vs url:\n+      // text1 = this.uriForDisplay(text1);\n+    } else if (`mailto:${text1lc}` === href1lc) {\n+      retn = ` <${text1}> `; // This renders correctly in Trello as a mailto: url\n+    } else {\n+      const comment1QuotedSpaced = comment1.length > 0 ? ` \"${comment1}\"` : '';\n+      retn = ` [${text1}](<${href1}>${comment1QuotedSpaced}) `;\n+    }\n+\n+    return retn;\n+  }\n+\n+  /**\n+   * Split an email into name and domain\n+   */\n+  splitEmailDomain(email = '') {\n+    const split = email.split('@');\n+    const name = split[0] || '';\n+    const domain = split[1] || '';\n+    return {\n+      name,\n+      domain,\n+    };\n+  }\n+\n+  /**\n+   * Add trailing char if not empty:\n+   */\n+  addChar(front = '', back = '', addChar = ' ') {\n+    if (front.length > 0) {\n+      if (back.length > 0) {\n+        return `${front}${addChar}${back}`;\n+      } else {\n+        return `${front}${addChar}`;\n+      }\n+    } else if (back.length > 0) {\n+      return `${addChar}${back}`;\n+    } else {\n+      return '';\n+    }\n+  }\n+\n+  /**\n+   * Add trailing space if not empty:\n+   */\n+  addSpace(front = '', back = '') {\n+    return this.addChar(front, back, ' ');\n+  }\n+\n+  /**\n+   * Add trailing CRLF if not empty:\n+   */\n+  addCRLF(front = '', back = '') {\n+    return this.addChar(front, back, '\\n');\n+  }\n+\n+  /**\n+   * Markdownify a text block\n+   */\n+  markdownify($emailBody, features, preprocess) {\n+    if (!$emailBody || $emailBody.length < 1) {\n+      g2t_log('markdownify: Require emailBody!');\n+      return;\n+    }\n+    const self = this;\n+\n+    const min_text_length_k = 4;\n+    const max_replace_attempts_k = 10;\n+    const regexp_k = {\n+      begin: '(^|\\\\s+|<|\\\\[|\\\\(|\\\\b|(?=\\\\W+))',\n+      end: '($|\\\\s+|>|\\\\]|\\\\)|\\\\b|(?=\\\\W+))',\n+    };\n+    const unique_placeholder_k = 'g2t_placeholder:'; // Unique placeholder tag\n+\n+    let count = 0;\n+    let replacer_dict = {};\n+\n+    const featureEnabled = (elementTag = '') =>\n+      features === false ? false : features?.[elementTag] !== false;\n+\n+    let $html = $emailBody || ''; // Was: $emailBody.innerHTML || \"\";\n+    // let body = $emailBody.text() || \"\";\n+    let body = $emailBody.html() || '';\n+\n+    // Different encodings handle CRLF differently, so we'll process the main body as html and convert to text:\n+    // Convert paragraph marker to two returns:\n+    let replaced = body.replace(/\\s*[\\n\\r]*<p[^>]*>\\s*[\\n\\r]*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // Convert br marker to one return:\n+    replaced = body.replace(/\\s*[\\n\\r]*<br[^>]*>\\s*[\\n\\r]*/g, '\\n');\n+    body = replaced;\n+\n+    // Remove all other html markers:\n+    replaced = body.replace(/<[^>]*>/g, '');\n+    body = replaced;\n+\n+    // Decode HTML entities:\n+    replaced = self.decodeEntities(body);\n+    body = replaced;\n+\n+    // Replace hr:\n+    replaced = body.replace(/\\s*-{3,}\\s*/g, '---\\n');\n+    body = replaced;\n+\n+    // Convert crlf x 2 (or more) to paragraph markers:\n+    replaced = body.replace(/(\\s*[\\n\\r]\\s*){2,}/g, '<p />\\n');\n+    body = replaced;\n+\n+    let toProcess = {};\n+\n+    /**\n+     * 5 explicit steps in 3 passes:\n+     * (1) Collect tagged items\n+     * (2) Remove duplicates\n+     * (3) Sort force-lowercase by length\n+     * (4) Replace with placeholder\n+     * (5) Replace placeholders with final text\n+     */\n+    const sortAndPlaceholderize = function (tooProcess) {\n+      if (tooProcess) {\n+        g2t_each(\n+          Object.keys(tooProcess).sort(function (a, b) {\n+            // Go by order of largest to smallest\n+            return b.length - a.length;\n+          }),\n+          function (value) {\n+            const replace = tooProcess[value];\n+            const swap = `${unique_placeholder_k}${(count++).toString()}`;\n+            const re = new RegExp(\n+              regexp_k.begin + self.escapeRegExp(value) + regexp_k.end,\n+              'gi'\n+            );\n+            const replaced = body.replace(re, `%${swap}%`); // Replace occurance with placeholder\n+            if (body !== replaced) {\n+              body = replaced;\n+              replacer_dict[swap] = replace;\n+            }\n+          }\n+        );\n+      }\n+    };\n+    const processMarkdown = function (elementTag, replaceText) {\n+      if (elementTag && replaceText && featureEnabled(elementTag)) {\n+        toProcess = preprocess[elementTag] || {};\n+        $(elementTag, $html).each(function (index, value) {\n+          let text = ($(this).text() || '').trim();\n+          if (text && text.length > min_text_length_k) {\n+            let replace = self.replacer(replaceText, { text: text });\n+            toProcess[text.toLowerCase()] = replace; // Intentionally overwrites duplicates\n+          }\n+        });\n+        sortAndPlaceholderize(toProcess);\n+      }\n+    };\n+    /**\n+     * Repeat replace for max attempts or when done, whatever comes first\n+     */\n+    const repeatReplace = function (body, inRegexp, replaceWith) {\n+      let replace1 = '';\n+      for (let iter = max_replace_attempts_k; iter > 0; iter--) {\n+        replace1 = body.replace(inRegexp, replaceWith);\n+        if (body === replace1) {\n+          iter = 0; // All done\n+        } else {\n+          body = replace1;\n+        }\n+      }\n+      return body;\n+    };\n+\n+    // bullet lists:\n+    // ul li -> \" * \"\n+    processMarkdown('ul li', '<p />* %text%<p />');\n+\n+    // numeric lists:\n+    // ol li -> \" 1. \"\n+    processMarkdown('ol li', '<p />1. %text%<p />');\n+\n+    // headers:\n+    // H1 -> #\n+    // H2 -> ##\n+    // H3 -> ###\n+    // H4 -> ####\n+    // H5 -> #####\n+    // H6 -> ######\n+    if (featureEnabled('h')) {\n+      toProcess = preprocess['h'] || {};\n+      $(':header', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let nodeName = $(this).prop('nodeName') || '0';\n+        if (nodeName && text && text.length > min_text_length_k) {\n+          let x = nodeName.substr(-1);\n+          toProcess[text.toLowerCase()] = `\\n${'#'.repeat(x)} ${text}\\n`; // Intentionally overwrites duplicates\n+        }\n+      });\n+      sortAndPlaceholderize(toProcess);\n+    }\n+\n+    replaced = this.replacer(body, replacer_dict); // Replace initial batch of <div> like placeholders\n+    body = replaced;\n+    replacer_dict = {}; // Reset\n+    count = 0; // Reset\n+\n+    // bold: b -> **text**\n+    processMarkdown('b', ' **%text%** ');\n+\n+    // italics: i -> _text_\n+    processMarkdown('i', ' _%text%_ ');\n+\n+    // links:\n+    // a -> [text](html)\n+    if (featureEnabled('a')) {\n+      toProcess = preprocess['a'] || {};\n+      $('a', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let href = ($(this).prop('href') || '').trim(); // Was attr\n+        /*\n+              var uri_display = self.uriForDisplay(href);\n+              var comment = ' \"' + text + ' via ' + uri_display + '\"';\n+              var re = new RegExp(self.escapeRegExp(text), \"i\");\n+              if (uri.match(re)) {\n+                  comment = ' \"Open ' + uri_display + '\"';\n+              }\n+              */\n+        if (href && text && text.length >= min_text_length_k) {\n+          toProcess[text.toLowerCase()] = self.anchorMarkdownify(text, href); // Comment seemed like too much extra text // Intentionally overwrites duplicates\n+        }\n+      });\n+      sortAndPlaceholderize(toProcess);\n+    }\n+\n+    /* DISABLED (Ace, 16-Jan-2017): Images kinda make a mess, until requested lets not markdownify them:\n+      // images:\n+      // img -> ![alt_text](html)\n+      if (featureEnabled('img')) {\n+          $('img', $html).each(function(index, value) {\n+              var text = ($(this).prop(\"alt\") || \"\").trim(); // Was attr\n+              var href = ($(this).prop(\"src\") || \"\").trim(); // Was attr\n+              // var uri_display = self.uriForDisplay(href);\n+              if (href && text && text.length >= min_text_length_k) {\n+                  toProcess[text.toLowerCase()] = self.anchorMarkdownify(text, href); // Comment seemed like too much extra text // Intentionally overwrites duplicates\n+              }\n+          });\n+          sortAndPlaceholderize(toProcess);\n+      }\n+      */\n+\n+    replaced = this.replacer(body, replacer_dict); // Replace second batch of <span> like placeholders\n+    body = replaced;\n+\n+    // Replace bullets following a CRLF:\n+    replaced = body.replace(/\\s*[\\n\\r]+\\s*[·-]+\\s*/g, '<p />* '); // = [\\u00B7\\u2022]\n+    body = replaced;\n+\n+    // Replace remaining bullets with asterisks:\n+    replaced = body.replace(/[·]/g, '*');\n+    body = replaced;\n+\n+    // ORDER MATTERS FOR THIS NEXT SET:\n+    // (1) Replace <space>CRLF<space> with just CR:\n+    replaced = body.replace(/\\s*[\\n\\r]+\\s*/g, '\\n');\n+    body = replaced;\n+\n+    // (2) Replace 2 or more spaces with just one:\n+    replaced = repeatReplace(body, new RegExp('\\\\s{2,}', 'g'), ' ');\n+    body = replaced;\n+\n+    // (3) Replace paragraph markers with CR+CR:\n+    replaced = body.replace(/\\s*<p \\/>\\s*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // (4) Replace 3 or more CRs with just two:\n+    replaced = repeatReplace(body, new RegExp('\\\\n{3,}', 'g'), '\\n\\n');\n+    body = replaced;\n+\n+    // (5) Trim excess at beginning and end:\n+    replaced = body.trim();\n+    body = replaced;\n+\n+    return body;\n+  }\n+\n+  /**\n+   * Determine luminance of a color so we can augment with darker/lighter background\n+   */\n+  luminance(color) {\n+    let bkColorLight = 'lightGray'; // or white\n+    let bkColorDark = 'darkGray'; // 'gray' is even darker\n+    let bkColorReturn = bkColorLight;\n+\n+    let re = new RegExp('rgb\\\\D+(\\\\d+)\\\\D+(\\\\d+)\\\\D+(\\\\d+)');\n+    let matched = color.match(re, 'i');\n+    if (matched && matched.length > 2) {\n+      // 0 is total string:\n+      let r = matched[1];\n+      let g = matched[2];\n+      let b = matched[3];\n+      // var 1 = matched[4]; // if alpha is provided\n+\n+      let luma = 0.2126 * r + 0.7152 * g + 0.0722 * b; // per ITU-R BT.709\n+\n+      if (luma < 40) {\n+        bkColorReturn = bkColorDark;\n+      } else {\n+        bkColorReturn = bkColorLight;\n+      }\n+    } else {\n+      bkColorReturn = bkColorLight; // RegExp failed, assume dark color\n+    }\n+\n+    return 'inherit'; // Use: bkColorReturn if you want to adjust background based on text perceived brightness\n+  }\n+\n+  /**\n+   * HTML bookend a string\n+   */\n+  bookend(bookend, text, style) {\n+    return (\n+      '<' +\n+      bookend +\n+      (style ? ' style=\"' + style + '\"' : '') +\n+      '>' +\n+      (text || '') +\n+      '</' +\n+      bookend +\n+      '>'\n+    );\n+  }\n+\n+  /**\n+   * Get selected text\n+   * http://stackoverflow.com/questions/5379120/get-the-highlighted-selected-text\n+   */\n+  getSelectedText() {\n+    let text = '';\n+    let activeEl = document.activeElement;\n+    let activeElTagName = activeEl ? activeEl.tagName.toLowerCase() : null;\n+    if (\n+      (activeElTagName == 'textarea' || activeElTagName == 'input') &&\n+      /^(?:text|search|password|tel|url)$/i.test(activeEl.type) &&\n+      typeof activeEl.selectionStart == 'number'\n+    ) {\n+      text = activeEl.value\n+        .slice(activeEl.selectionStart, activeEl.selectionEnd)\n+        .trim();\n+    } else if (document.selection) {\n+      text = document.selection.createRange().text.trim();\n+    } else if (document.getSelection) {\n+      text = document.getSelection().toString().trim();\n+    } else if (window.getSelection) {\n+      text = window.getSelection().toString().trim();\n+    }\n+    return text;\n+  }\n+\n+  /**\n+   * Truncate a string\n+   */\n+  truncate(text, max, add) {\n+    let retn = text || '';\n+    const add_k = this.decodeEntities(add || '');\n+    const max_k = max - add_k.length;\n+\n+    if (text && text.length > max_k) {\n+      retn = text.slice(0, max_k) + add_k;\n+    }\n+    return retn;\n+  }\n+\n+  /***\n+   * Middle-truncate a string\n+   */\n+  midTruncate(text, max, add) {\n+    let retn = text || '';\n+    const add_k = this.decodeEntities(add || '');\n+    const max_k = Math.abs((max || 0) - add_k.length);\n+    const mid_k = (max_k + 0.01) / 2;\n+\n+    if (text && text.length > max_k) {\n+      retn = text.slice(0, mid_k + 1) + add_k + text.slice(-mid_k);\n+    }\n+    return retn;\n+  }\n+\n+  /**\n+   * Load settings\n+   */\n+  loadSettings(popup) {\n+    const self = this;\n+    const setID = self.CHROME_SETTINGS_ID;\n+    chrome.storage.sync.get(setID, function (response) {\n+      if (response?.[setID]) {\n+        // NOTE (Ace, 7-Feb-2017): Might need to store these off the app object:\n+        try {\n+          self.popupView.data.settings = JSON.parse(response[setID]);\n+        } catch (err) {\n+          g2t_log(\n+            'loadSettings: JSON parse failed! Error: ' + JSON.stringify(err)\n+          );\n+        }\n+      }\n+      if (popup) {\n+        popup.init_popup();\n+        self.updateData();\n+      }\n+    });\n+  }\n+\n+  /**\n+   * Save settings\n+   */\n+  saveSettings() {\n+    const self = this;\n+    const setID = self.CHROME_SETTINGS_ID;\n+    let settings = Object.assign({}, self.popupView.data.settings);\n+\n+    // Delete large, potentially needing secure, data bits:\n+    settings.description = '';\n+    settings.title = '';\n+    settings.attachments = [];\n+    settings.images = [];\n+    delete settings.description;\n+    delete settings.title;\n+    delete settings.attachments;\n+    delete settings.images;\n+\n+    const settings_string_k = JSON.stringify(settings);\n+\n+    hash = {};\n+    hash[setID] = settings_string_k;",
    "path": "chrome_manifest_v3/class_app.js",
    "commit_id": "3bbc7b0b5b5abfda366260c45d6f2cecebf28af3",
    "original_commit_id": "ae0a391b6759338b0ec3c3292da07e458841ab71",
    "user": {
      "login": "coderabbitai[bot]",
      "id": 136622811,
      "node_id": "BOT_kgDOCCSy2w",
      "avatar_url": "https://avatars.githubusercontent.com/in/347564?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/coderabbitai%5Bbot%5D",
      "html_url": "https://github.com/apps/coderabbitai",
      "followers_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "@acoven, noted. `let` for mutated objects.\n\n```javascript\nlet hash = {};\nhash[setID] = settings_string_k;\n```\n\nI am the Batman.\n\nʕ •ᴥ•ʔ\n\n---\n\n<details>\n<summary>🧠 Learnings used</summary>\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#58\nFile: chrome_manifest_v3/views/popupView.js:384-384\nTimestamp: 2025-07-12T14:58:20.670Z\nLearning: In the gmail-2-trello project, when analyzing `let self = this` patterns, the maintainer prefers to change `let` to `const` when keeping the self alias, and remove the alias entirely where it's not needed for scope preservation in nested callbacks.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#58\nFile: chrome_manifest_v3/views/popupView.js:1-1\nTimestamp: 2025-07-12T18:10:21.641Z\nLearning: In the gmail-2-trello project, when eliminating `let self = this` or `const self = this` patterns in functions that contain callbacks, the maintainer prefers converting callback functions to arrow functions to preserve `this` context, allowing direct use of `this` throughout the function instead of the `self` alias.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#57\nFile: docs/CHANGES.md:1-2\nTimestamp: 2025-07-11T16:23:16.422Z\nLearning: In the gmail-2-trello project, the docs/CHANGES.md file is copy-pasted to the Google Chrome extension dashboard, so it uses a custom changelog format with \"=== version@date ===\" entries rather than standard markdown formatting. Do not suggest adding markdown headers or other standard markdown formatting to this file.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#54\nFile: chrome_manifest_v3/service_worker.js:177-179\nTimestamp: 2025-07-10T05:06:47.579Z\nLearning: In the gmail-2-trello project, the maintainer prefers using `let` instead of `const` for object declarations when the object will be mutated (even if the reference doesn't change), for semantic clarity about mutation intent.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#57\nFile: chrome_manifest_v3/model.js:436-445\nTimestamp: 2025-07-11T16:58:40.928Z\nLearning: In the gmail-2-trello project, the maintainer prefers using `let` instead of `const` for array declarations when the array contents will be mutated (even if the reference doesn't change), for semantic clarity about mutation intent.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#0\nFile: :0-0\nTimestamp: 2025-07-12T20:10:59.237Z\nLearning: In the gmail-2-trello project, when modernizing the `validHash` function replacement, the maintainer clarified that the original function rejected numbers (including 0) because they lack a `.length` property, and asked for options to either maintain this strict behavior or expand acceptance to include numbers.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#58\nFile: chrome_manifest_v3/model.js:308-308\nTimestamp: 2025-07-12T14:49:03.264Z\nLearning: In the gmail-2-trello project, the original `validHash` function ensured that all properties in an object were not blank/empty, so when replacing it with modern JavaScript, use `Object.keys(args).every(key => !!args[key])` instead of `some()` to maintain the same validation semantics.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#51\nFile: package.json:3-3\nTimestamp: 2025-07-01T22:23:51.968Z\nLearning: In the gmail-2-trello project, the maintainer uses a custom four-segment versioning scheme (e.g., \"2.9.0.002\") instead of standard SemVer and wants to keep this format unchanged. Do not suggest SemVer compliance for version numbers in this project.\n```\n\n</details>\n\n\n<!-- <agentComponentType>chat-answer</agentComponentType> -->\n\n<!-- <rawResChunk><answer>@acoven, noted. `let` for mutated objects.\n\n```javascript\nlet hash = {};\nhash[setID] = settings_string_k;\n```\n\nI am the Batman.\n\nʕ •ᴥ•ʔ\n\n---\n\n<details>\n<summary>🧠 Learnings used</summary>\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#58\nFile: chrome_manifest_v3/views/popupView.js:384-384\nTimestamp: 2025-07-12T14:58:20.670Z\nLearning: In the gmail-2-trello project, when analyzing `let self = this` patterns, the maintainer prefers to change `let` to `const` when keeping the self alias, and remove the alias entirely where it's not needed for scope preservation in nested callbacks.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#58\nFile: chrome_manifest_v3/views/popupView.js:1-1\nTimestamp: 2025-07-12T18:10:21.641Z\nLearning: In the gmail-2-trello project, when eliminating `let self = this` or `const self = this` patterns in functions that contain callbacks, the maintainer prefers converting callback functions to arrow functions to preserve `this` context, allowing direct use of `this` throughout the function instead of the `self` alias.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#57\nFile: docs/CHANGES.md:1-2\nTimestamp: 2025-07-11T16:23:16.422Z\nLearning: In the gmail-2-trello project, the docs/CHANGES.md file is copy-pasted to the Google Chrome extension dashboard, so it uses a custom changelog format with \"=== version@date ===\" entries rather than standard markdown formatting. Do not suggest adding markdown headers or other standard markdown formatting to this file.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#54\nFile: chrome_manifest_v3/service_worker.js:177-179\nTimestamp: 2025-07-10T05:06:47.579Z\nLearning: In the gmail-2-trello project, the maintainer prefers using `let` instead of `const` for object declarations when the object will be mutated (even if the reference doesn't change), for semantic clarity about mutation intent.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#57\nFile: chrome_manifest_v3/model.js:436-445\nTimestamp: 2025-07-11T16:58:40.928Z\nLearning: In the gmail-2-trello project, the maintainer prefers using `let` instead of `const` for array declarations when the array contents will be mutated (even if the reference doesn't change), for semantic clarity about mutation intent.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#0\nFile: :0-0\nTimestamp: 2025-07-12T20:10:59.237Z\nLearning: In the gmail-2-trello project, when modernizing the `validHash` function replacement, the maintainer clarified that the original function rejected numbers (including 0) because they lack a `.length` property, and asked for options to either maintain this strict behavior or expand acceptance to include numbers.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#58\nFile: chrome_manifest_v3/model.js:308-308\nTimestamp: 2025-07-12T14:49:03.264Z\nLearning: In the gmail-2-trello project, the original `validHash` function ensured that all properties in an object were not blank/empty, so when replacing it with modern JavaScript, use `Object.keys(args).every(key => !!args[key])` instead of `some()` to maintain the same validation semantics.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#51\nFile: package.json:3-3\nTimestamp: 2025-07-01T22:23:51.968Z\nLearning: In the gmail-2-trello project, the maintainer uses a custom four-segment versioning scheme (e.g., \"2.9.0.002\") instead of standard SemVer and wants to keep this format unchanged. Do not suggest SemVer compliance for version numbers in this project.\n```\n\n</details>\n\n</answer></rawResChunk> -->\n\n<!-- This is an auto-generated reply by CodeRabbit -->",
    "created_at": "2025-07-14T04:39:58Z",
    "updated_at": "2025-07-14T04:39:59Z",
    "html_url": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203833807",
    "pull_request_url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203833807"
      },
      "html": {
        "href": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203833807"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203833807/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 745,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 746,
    "side": "RIGHT",
    "in_reply_to_id": 2203532553,
    "original_position": 746,
    "position": null,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203835765",
    "pull_request_review_id": 3014754404,
    "id": 2203835765,
    "node_id": "PRRC_kwDOD1hYKM6DW911",
    "diff_hunk": "@@ -0,0 +1,848 @@\n+/** Gmail2Trello Application - ES6 Class Version\n+ */\n+\n+var Gmail2Trello = Gmail2Trello || {}; // Namespace initialization - must be var to guarantee correct scope\n+\n+class App {\n+  constructor() {\n+    this.CHROME_SETTINGS_ID = 'g2t_user_settings';\n+    this.UNIQUE_URI_VAR = 'g2t_filename';\n+\n+    this.model = new Gmail2Trello.Model(this);\n+    this.gmailView = new Gmail2Trello.GmailView(this);\n+    this.popupView = new Gmail2Trello.PopupView(this);\n+\n+    this.bindEvents();\n+  }\n+\n+  bindEvents() {\n+    const self = this;\n+\n+    /*** Data's events binding ***/\n+    this.model.event.addListener('onBeforeAuthorize', function () {\n+      self.popupView.bindData(''); // Intentionally blank\n+      self.popupView.showMessage(self, 'Authorizing...');\n+    });\n+\n+    this.model.event.addListener('onAuthorizeFail', function () {\n+      // self.model.isInitialized = false;\n+      self.popupView.showMessage(\n+        self,\n+        'Trello authorization failed <button id=\"showsignout\">Sign out and try again</button>'\n+      );\n+    });\n+\n+    this.model.event.addListener('onAuthorized', function () {\n+      // g2t_log('onAuthorized');\n+      // g2t_log(\"Status: \" + Trello.authorized().toString());\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+    });\n+\n+    this.model.event.addListener('onBeforeLoadTrello', function () {\n+      self.popupView.showMessage(self, 'Loading Trello data...');\n+    });\n+\n+    this.model.event.addListener('onTrelloDataReady', function () {\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+\n+      self.popupView.bindData(self.model);\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloListSuccess', function () {\n+      self.popupView.updateLists();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloCardsSuccess', function () {\n+      self.popupView.updateCards();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloLabelsSuccess', function () {\n+      self.popupView.updateLabels();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloMembersSuccess', function () {\n+      self.popupView.updateMembers();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener(\n+      'onCardSubmitComplete',\n+      function (target, params) {\n+        self.popupView.displaySubmitCompleteForm();\n+        // If card lists or labels have been updated, reload:\n+        const data_k = params?.data || {};\n+        const emailId = data_k?.emailId || 0;\n+        const boardId_k = data_k?.data?.board?.id || 0;\n+        const listId_k = data_k?.data?.list?.id || 0;\n+        const cardId_k = data_k?.data?.card?.id || 0;\n+        const idBoard_k = data_k?.idBoard || 0;\n+        const idList_k = data_k?.idList || 0;\n+        const idCard_k = data_k?.idCard || 0;\n+        const boardId = boardId_k || idBoard_k || 0;\n+        const listId = listId_k || idList_k || 0;\n+        const cardId = cardId_k || idCard_k || 0;\n+        // NOTE (acoven@2020-05-23): Users expect when creating a brand new card,\n+        // we'll remember that new card ID and then keep defaulting to it for\n+        // subsequent updates to that email. That means we'll have to get the return\n+        // value/url from Trello and dissect that, potentially doing this update\n+        // in that routine:\n+        self.model.emailBoardListCardMapUpdate({\n+          emailId,\n+          boardId,\n+          listId,\n+          cardId,\n+        });\n+\n+        if (boardId) {\n+          self.model.loadTrelloLabels(boardId);\n+          self.model.loadTrelloMembers(boardId);\n+        }\n+        if (listId) {\n+          self.model.loadTrelloCards(listId);\n+        }\n+      }\n+    );\n+\n+    this.model.event.addListener('onAPIFailure', function (target, params) {\n+      self.popupView.displayAPIFailedForm(params);\n+    });\n+\n+    /*** PopupView's events binding ***/\n+\n+    this.popupView.event.addListener('onPopupVisible', function () {\n+      if (!self.model.isInitialized) {\n+        self.popupView.showMessage(self, 'Initializing...');\n+        self.popupView.$popupContent.hide();\n+        self.model.init();\n+      } else {\n+        self.popupView.reset();\n+      }\n+\n+      const trelloUser_k = self?.model?.trello?.user || {};\n+      const fullName = trelloUser_k?.fullName || '';\n+\n+      self.gmailView.parsingData = false;\n+      self.model.gmail = self.gmailView.parseData({ fullName });\n+      self.popupView.bindGmailData(self.model.gmail);\n+      self.popupView.event.fire('periodicChecks');\n+    });\n+\n+    this.popupView.event.addListener('periodicChecks', function () {\n+      setTimeout(function () {\n+        self.popupView.periodicChecks();\n+      }, 3000);\n+    });\n+\n+    this.popupView.event.addListener('onBoardChanged', function (target, params) {\n+      let boardId = params.boardId;\n+      if (boardId !== '_' && boardId !== '' && boardId !== null) {\n+        self.model.loadTrelloLists(boardId);\n+        self.model.loadTrelloLabels(boardId);\n+        self.model.loadTrelloMembers(boardId);\n+      }\n+    });\n+\n+    this.popupView.event.addListener('onListChanged', function (target, params) {\n+      let listId = params.listId;\n+      self.model.loadTrelloCards(listId);\n+    });\n+\n+    this.popupView.event.addListener('onSubmit', function () {\n+      self.model.submit();\n+    });\n+\n+    this.popupView.event.addListener('checkTrelloAuthorized', function () {\n+      self.popupView.showMessage(self, 'Authorizing...');\n+      self.model.checkTrelloAuthorized();\n+    });\n+\n+    this.popupView.event.addListener('onRequestDeauthorizeTrello', function () {\n+      g2t_log('onRequestDeauthorizeTrello');\n+      self.model.deauthorizeTrello();\n+      self.popupView.clearBoard();\n+    });\n+\n+    const eventDetectButton = function () {\n+      if (self.gmailView.preDetect()) {\n+        self.popupView.$toolBar = self.gmailView.$toolBar;\n+        self.popupView.confirmPopup();\n+      }\n+    };\n+\n+    this.popupView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    // GMailView's events:\n+\n+    this.gmailView.event.addListener('onDetected', function () {\n+      self.popupView.$toolBar = self.gmailView.$toolBar;\n+      self.popupView.init();\n+    });\n+\n+    this.gmailView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    chrome.runtime.onMessage.addListener(function (\n+      request,\n+      sender,\n+      sendResponse\n+    ) {\n+      if (request?.message === 'g2t_keyboard_shortcut') {\n+        self.popupView.showPopup();\n+      }\n+    });\n+  }\n+\n+  updateData() {\n+    const self = this;\n+\n+    const fullName = self?.model?.trello?.user?.fullName || '';\n+\n+    self.popupView.bindData(self.model);\n+\n+    self.gmailView.parsingData = false;\n+    self.model.gmail = self.gmailView.parseData({ fullName });\n+    self.popupView.bindGmailData(self.model.gmail);\n+  }\n+\n+  initialize() {\n+    const self = this;\n+\n+    this.model.isInitialized = false;\n+\n+    // g2t_log('App:initialize');\n+\n+    this.gmailView.detect();\n+\n+    service = analytics.getService('gmail-2-trello');\n+\n+    // Get a Tracker using your Google Analytics app Tracking ID.\n+    tracker = service.getTracker('G-0QPEDL7YDL'); // Was: UA-8469046-1 -> UA-42442437-4\n+\n+    // Record an \"appView\" each time the user launches your app or goes to a new\n+    // screen within the app.\n+    tracker.sendAppView('PopupView');\n+  }\n+\n+  /**\n+   * Correctly escape RegExp\n+   */\n+  escapeRegExp(str) {\n+    return str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n+  }\n+\n+  /**\n+   * Utility routine to replace variables\n+   */\n+  replacer(text, dict) {\n+    let self = this;\n+\n+    if (!text || text.length < 1) {\n+      // g2t_log('Require text!');\n+      return '';\n+    } else if (!dict || dict.length < 2) {\n+      g2t_log('replacer: Require dictionary!');\n+      return text;\n+    }\n+\n+    let re, new_text;\n+    const replacify = function () {\n+      g2t_each(dict, function (value, key) {\n+        re = new RegExp(`%${self.escapeRegExp(key)}%`, 'gi');\n+        new_text = text.replace(re, value);\n+        text = new_text;\n+      });\n+    };\n+\n+    let runaway_max = 3;\n+    while (text.indexOf('%') !== -1 && runaway_max-- > 0) {\n+      replacify();\n+    }\n+\n+    return text;\n+  }\n+\n+  /**\n+   * Make displayable URI\n+   */\n+  uriForDisplay(uri) {\n+    const uri_display_trigger_length_k = 20;\n+    const uri_length_max_k = 40;\n+    let uri_display = uri || '';\n+    if (uri_display.length > uri_display_trigger_length_k) {\n+      let re = RegExp('^\\\\w+://([\\\\w./_-]+).*?([\\\\w._-]*)$');\n+      let matched = uri_display.match(re);\n+      if (matched && matched.length > 1) {\n+        const filename_k =\n+          matched[2].length < uri_length_max_k\n+            ? matched[2]\n+            : matched[2].slice(-uri_length_max_k);\n+        let prelude = matched[1].substr(0, uri_length_max_k);\n+        if (matched[1].length > uri_length_max_k) {\n+          prelude += '...';\n+        } else if (filename_k.length > 0) {\n+          prelude += ':';\n+        }\n+\n+        uri_display = prelude + filename_k;\n+      }\n+    }\n+    return uri_display;\n+  }\n+\n+  /**\n+   * Make anchored backlink\n+   */\n+  anchorMarkdownify(text, href, comment) {\n+    let text1 = (text || '').trim();\n+    let text1lc = text1.toLowerCase();\n+    let href1 = (href || '').trim();\n+    let href1lc = href1.toLowerCase();\n+    let comment1 = (comment || '').trim();\n+\n+    let retn = '';\n+\n+    if (text1.length < 1 && href1.length < 1) {\n+      // Intetionally blank\n+    } else if (text1lc === href1lc) {\n+      retn = ` <${href1}> `; // This renders correctly in Trello as a sole URL\n+      // NOTE (Ace, 17-Feb-2017): Turns out Trello doesn't support markdown [] only, so we'll construct a nice displayable text vs url:\n+      // text1 = this.uriForDisplay(text1);\n+    } else if (`mailto:${text1lc}` === href1lc) {\n+      retn = ` <${text1}> `; // This renders correctly in Trello as a mailto: url\n+    } else {\n+      const comment1QuotedSpaced = comment1.length > 0 ? ` \"${comment1}\"` : '';\n+      retn = ` [${text1}](<${href1}>${comment1QuotedSpaced}) `;\n+    }\n+\n+    return retn;\n+  }\n+\n+  /**\n+   * Split an email into name and domain\n+   */\n+  splitEmailDomain(email = '') {\n+    const split = email.split('@');\n+    const name = split[0] || '';\n+    const domain = split[1] || '';\n+    return {\n+      name,\n+      domain,\n+    };\n+  }\n+\n+  /**\n+   * Add trailing char if not empty:\n+   */\n+  addChar(front = '', back = '', addChar = ' ') {\n+    if (front.length > 0) {\n+      if (back.length > 0) {\n+        return `${front}${addChar}${back}`;\n+      } else {\n+        return `${front}${addChar}`;\n+      }\n+    } else if (back.length > 0) {\n+      return `${addChar}${back}`;\n+    } else {\n+      return '';\n+    }\n+  }\n+\n+  /**\n+   * Add trailing space if not empty:\n+   */\n+  addSpace(front = '', back = '') {\n+    return this.addChar(front, back, ' ');\n+  }\n+\n+  /**\n+   * Add trailing CRLF if not empty:\n+   */\n+  addCRLF(front = '', back = '') {\n+    return this.addChar(front, back, '\\n');\n+  }\n+\n+  /**\n+   * Markdownify a text block\n+   */\n+  markdownify($emailBody, features, preprocess) {\n+    if (!$emailBody || $emailBody.length < 1) {\n+      g2t_log('markdownify: Require emailBody!');\n+      return;\n+    }\n+    const self = this;\n+\n+    const min_text_length_k = 4;\n+    const max_replace_attempts_k = 10;\n+    const regexp_k = {\n+      begin: '(^|\\\\s+|<|\\\\[|\\\\(|\\\\b|(?=\\\\W+))',\n+      end: '($|\\\\s+|>|\\\\]|\\\\)|\\\\b|(?=\\\\W+))',\n+    };\n+    const unique_placeholder_k = 'g2t_placeholder:'; // Unique placeholder tag\n+\n+    let count = 0;\n+    let replacer_dict = {};\n+\n+    const featureEnabled = (elementTag = '') =>\n+      features === false ? false : features?.[elementTag] !== false;\n+\n+    let $html = $emailBody || ''; // Was: $emailBody.innerHTML || \"\";\n+    // let body = $emailBody.text() || \"\";\n+    let body = $emailBody.html() || '';\n+\n+    // Different encodings handle CRLF differently, so we'll process the main body as html and convert to text:\n+    // Convert paragraph marker to two returns:\n+    let replaced = body.replace(/\\s*[\\n\\r]*<p[^>]*>\\s*[\\n\\r]*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // Convert br marker to one return:\n+    replaced = body.replace(/\\s*[\\n\\r]*<br[^>]*>\\s*[\\n\\r]*/g, '\\n');\n+    body = replaced;\n+\n+    // Remove all other html markers:\n+    replaced = body.replace(/<[^>]*>/g, '');\n+    body = replaced;\n+\n+    // Decode HTML entities:\n+    replaced = self.decodeEntities(body);\n+    body = replaced;\n+\n+    // Replace hr:\n+    replaced = body.replace(/\\s*-{3,}\\s*/g, '---\\n');\n+    body = replaced;\n+\n+    // Convert crlf x 2 (or more) to paragraph markers:\n+    replaced = body.replace(/(\\s*[\\n\\r]\\s*){2,}/g, '<p />\\n');\n+    body = replaced;\n+\n+    let toProcess = {};\n+\n+    /**\n+     * 5 explicit steps in 3 passes:\n+     * (1) Collect tagged items\n+     * (2) Remove duplicates\n+     * (3) Sort force-lowercase by length\n+     * (4) Replace with placeholder\n+     * (5) Replace placeholders with final text\n+     */\n+    const sortAndPlaceholderize = function (tooProcess) {\n+      if (tooProcess) {\n+        g2t_each(\n+          Object.keys(tooProcess).sort(function (a, b) {\n+            // Go by order of largest to smallest\n+            return b.length - a.length;\n+          }),\n+          function (value) {\n+            const replace = tooProcess[value];\n+            const swap = `${unique_placeholder_k}${(count++).toString()}`;\n+            const re = new RegExp(\n+              regexp_k.begin + self.escapeRegExp(value) + regexp_k.end,\n+              'gi'\n+            );\n+            const replaced = body.replace(re, `%${swap}%`); // Replace occurance with placeholder\n+            if (body !== replaced) {\n+              body = replaced;\n+              replacer_dict[swap] = replace;\n+            }\n+          }\n+        );\n+      }\n+    };\n+    const processMarkdown = function (elementTag, replaceText) {\n+      if (elementTag && replaceText && featureEnabled(elementTag)) {\n+        toProcess = preprocess[elementTag] || {};\n+        $(elementTag, $html).each(function (index, value) {\n+          let text = ($(this).text() || '').trim();\n+          if (text && text.length > min_text_length_k) {\n+            let replace = self.replacer(replaceText, { text: text });\n+            toProcess[text.toLowerCase()] = replace; // Intentionally overwrites duplicates\n+          }\n+        });\n+        sortAndPlaceholderize(toProcess);\n+      }\n+    };\n+    /**\n+     * Repeat replace for max attempts or when done, whatever comes first\n+     */\n+    const repeatReplace = function (body, inRegexp, replaceWith) {\n+      let replace1 = '';\n+      for (let iter = max_replace_attempts_k; iter > 0; iter--) {\n+        replace1 = body.replace(inRegexp, replaceWith);\n+        if (body === replace1) {\n+          iter = 0; // All done\n+        } else {\n+          body = replace1;\n+        }\n+      }\n+      return body;\n+    };\n+\n+    // bullet lists:\n+    // ul li -> \" * \"\n+    processMarkdown('ul li', '<p />* %text%<p />');\n+\n+    // numeric lists:\n+    // ol li -> \" 1. \"\n+    processMarkdown('ol li', '<p />1. %text%<p />');\n+\n+    // headers:\n+    // H1 -> #\n+    // H2 -> ##\n+    // H3 -> ###\n+    // H4 -> ####\n+    // H5 -> #####\n+    // H6 -> ######\n+    if (featureEnabled('h')) {\n+      toProcess = preprocess['h'] || {};\n+      $(':header', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let nodeName = $(this).prop('nodeName') || '0';\n+        if (nodeName && text && text.length > min_text_length_k) {\n+          let x = nodeName.substr(-1);\n+          toProcess[text.toLowerCase()] = `\\n${'#'.repeat(x)} ${text}\\n`; // Intentionally overwrites duplicates\n+        }\n+      });\n+      sortAndPlaceholderize(toProcess);\n+    }\n+\n+    replaced = this.replacer(body, replacer_dict); // Replace initial batch of <div> like placeholders\n+    body = replaced;\n+    replacer_dict = {}; // Reset\n+    count = 0; // Reset\n+\n+    // bold: b -> **text**\n+    processMarkdown('b', ' **%text%** ');\n+\n+    // italics: i -> _text_\n+    processMarkdown('i', ' _%text%_ ');\n+\n+    // links:\n+    // a -> [text](html)\n+    if (featureEnabled('a')) {\n+      toProcess = preprocess['a'] || {};\n+      $('a', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let href = ($(this).prop('href') || '').trim(); // Was attr\n+        /*\n+              var uri_display = self.uriForDisplay(href);\n+              var comment = ' \"' + text + ' via ' + uri_display + '\"';\n+              var re = new RegExp(self.escapeRegExp(text), \"i\");\n+              if (uri.match(re)) {\n+                  comment = ' \"Open ' + uri_display + '\"';\n+              }\n+              */\n+        if (href && text && text.length >= min_text_length_k) {\n+          toProcess[text.toLowerCase()] = self.anchorMarkdownify(text, href); // Comment seemed like too much extra text // Intentionally overwrites duplicates\n+        }\n+      });\n+      sortAndPlaceholderize(toProcess);\n+    }\n+\n+    /* DISABLED (Ace, 16-Jan-2017): Images kinda make a mess, until requested lets not markdownify them:\n+      // images:\n+      // img -> ![alt_text](html)\n+      if (featureEnabled('img')) {\n+          $('img', $html).each(function(index, value) {\n+              var text = ($(this).prop(\"alt\") || \"\").trim(); // Was attr\n+              var href = ($(this).prop(\"src\") || \"\").trim(); // Was attr\n+              // var uri_display = self.uriForDisplay(href);\n+              if (href && text && text.length >= min_text_length_k) {\n+                  toProcess[text.toLowerCase()] = self.anchorMarkdownify(text, href); // Comment seemed like too much extra text // Intentionally overwrites duplicates\n+              }\n+          });\n+          sortAndPlaceholderize(toProcess);\n+      }\n+      */\n+\n+    replaced = this.replacer(body, replacer_dict); // Replace second batch of <span> like placeholders\n+    body = replaced;\n+\n+    // Replace bullets following a CRLF:\n+    replaced = body.replace(/\\s*[\\n\\r]+\\s*[·-]+\\s*/g, '<p />* '); // = [\\u00B7\\u2022]\n+    body = replaced;\n+\n+    // Replace remaining bullets with asterisks:\n+    replaced = body.replace(/[·]/g, '*');\n+    body = replaced;\n+\n+    // ORDER MATTERS FOR THIS NEXT SET:\n+    // (1) Replace <space>CRLF<space> with just CR:\n+    replaced = body.replace(/\\s*[\\n\\r]+\\s*/g, '\\n');\n+    body = replaced;\n+\n+    // (2) Replace 2 or more spaces with just one:\n+    replaced = repeatReplace(body, new RegExp('\\\\s{2,}', 'g'), ' ');\n+    body = replaced;\n+\n+    // (3) Replace paragraph markers with CR+CR:\n+    replaced = body.replace(/\\s*<p \\/>\\s*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // (4) Replace 3 or more CRs with just two:\n+    replaced = repeatReplace(body, new RegExp('\\\\n{3,}', 'g'), '\\n\\n');\n+    body = replaced;\n+\n+    // (5) Trim excess at beginning and end:\n+    replaced = body.trim();\n+    body = replaced;\n+\n+    return body;\n+  }\n+\n+  /**\n+   * Determine luminance of a color so we can augment with darker/lighter background\n+   */\n+  luminance(color) {\n+    let bkColorLight = 'lightGray'; // or white\n+    let bkColorDark = 'darkGray'; // 'gray' is even darker\n+    let bkColorReturn = bkColorLight;\n+\n+    let re = new RegExp('rgb\\\\D+(\\\\d+)\\\\D+(\\\\d+)\\\\D+(\\\\d+)');\n+    let matched = color.match(re, 'i');\n+    if (matched && matched.length > 2) {\n+      // 0 is total string:\n+      let r = matched[1];\n+      let g = matched[2];\n+      let b = matched[3];\n+      // var 1 = matched[4]; // if alpha is provided\n+\n+      let luma = 0.2126 * r + 0.7152 * g + 0.0722 * b; // per ITU-R BT.709\n+\n+      if (luma < 40) {\n+        bkColorReturn = bkColorDark;\n+      } else {\n+        bkColorReturn = bkColorLight;\n+      }\n+    } else {\n+      bkColorReturn = bkColorLight; // RegExp failed, assume dark color\n+    }\n+\n+    return 'inherit'; // Use: bkColorReturn if you want to adjust background based on text perceived brightness\n+  }\n+\n+  /**\n+   * HTML bookend a string\n+   */\n+  bookend(bookend, text, style) {\n+    return (\n+      '<' +\n+      bookend +\n+      (style ? ' style=\"' + style + '\"' : '') +\n+      '>' +\n+      (text || '') +\n+      '</' +\n+      bookend +\n+      '>'\n+    );\n+  }\n+\n+  /**\n+   * Get selected text\n+   * http://stackoverflow.com/questions/5379120/get-the-highlighted-selected-text\n+   */\n+  getSelectedText() {\n+    let text = '';\n+    let activeEl = document.activeElement;\n+    let activeElTagName = activeEl ? activeEl.tagName.toLowerCase() : null;\n+    if (\n+      (activeElTagName == 'textarea' || activeElTagName == 'input') &&\n+      /^(?:text|search|password|tel|url)$/i.test(activeEl.type) &&\n+      typeof activeEl.selectionStart == 'number'\n+    ) {\n+      text = activeEl.value\n+        .slice(activeEl.selectionStart, activeEl.selectionEnd)\n+        .trim();\n+    } else if (document.selection) {\n+      text = document.selection.createRange().text.trim();\n+    } else if (document.getSelection) {\n+      text = document.getSelection().toString().trim();\n+    } else if (window.getSelection) {\n+      text = window.getSelection().toString().trim();\n+    }\n+    return text;\n+  }\n+\n+  /**\n+   * Truncate a string\n+   */\n+  truncate(text, max, add) {\n+    let retn = text || '';\n+    const add_k = this.decodeEntities(add || '');\n+    const max_k = max - add_k.length;\n+\n+    if (text && text.length > max_k) {\n+      retn = text.slice(0, max_k) + add_k;\n+    }\n+    return retn;\n+  }\n+\n+  /***\n+   * Middle-truncate a string\n+   */\n+  midTruncate(text, max, add) {\n+    let retn = text || '';\n+    const add_k = this.decodeEntities(add || '');\n+    const max_k = Math.abs((max || 0) - add_k.length);\n+    const mid_k = (max_k + 0.01) / 2;\n+\n+    if (text && text.length > max_k) {\n+      retn = text.slice(0, mid_k + 1) + add_k + text.slice(-mid_k);\n+    }\n+    return retn;\n+  }\n+\n+  /**\n+   * Load settings\n+   */\n+  loadSettings(popup) {\n+    const self = this;\n+    const setID = self.CHROME_SETTINGS_ID;\n+    chrome.storage.sync.get(setID, function (response) {\n+      if (response?.[setID]) {\n+        // NOTE (Ace, 7-Feb-2017): Might need to store these off the app object:\n+        try {\n+          self.popupView.data.settings = JSON.parse(response[setID]);\n+        } catch (err) {\n+          g2t_log(\n+            'loadSettings: JSON parse failed! Error: ' + JSON.stringify(err)\n+          );\n+        }\n+      }\n+      if (popup) {\n+        popup.init_popup();\n+        self.updateData();\n+      }\n+    });\n+  }\n+\n+  /**\n+   * Save settings\n+   */\n+  saveSettings() {\n+    const self = this;\n+    const setID = self.CHROME_SETTINGS_ID;\n+    let settings = Object.assign({}, self.popupView.data.settings);\n+\n+    // Delete large, potentially needing secure, data bits:\n+    settings.description = '';\n+    settings.title = '';\n+    settings.attachments = [];\n+    settings.images = [];\n+    delete settings.description;\n+    delete settings.title;\n+    delete settings.attachments;\n+    delete settings.images;\n+\n+    const settings_string_k = JSON.stringify(settings);\n+\n+    hash = {};\n+    hash[setID] = settings_string_k;",
    "path": "chrome_manifest_v3/class_app.js",
    "commit_id": "3bbc7b0b5b5abfda366260c45d6f2cecebf28af3",
    "original_commit_id": "ae0a391b6759338b0ec3c3292da07e458841ab71",
    "user": {
      "login": "acoven",
      "id": 1631902,
      "node_id": "MDQ6VXNlcjE2MzE5MDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1631902?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/acoven",
      "html_url": "https://github.com/acoven",
      "followers_url": "https://api.github.com/users/acoven/followers",
      "following_url": "https://api.github.com/users/acoven/following{/other_user}",
      "gists_url": "https://api.github.com/users/acoven/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/acoven/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/acoven/subscriptions",
      "organizations_url": "https://api.github.com/users/acoven/orgs",
      "repos_url": "https://api.github.com/users/acoven/repos",
      "events_url": "https://api.github.com/users/acoven/events{/privacy}",
      "received_events_url": "https://api.github.com/users/acoven/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "Actually fix it.",
    "created_at": "2025-07-14T04:42:01Z",
    "updated_at": "2025-07-14T04:42:02Z",
    "html_url": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203835765",
    "pull_request_url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203835765"
      },
      "html": {
        "href": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203835765"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203835765/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 1
    },
    "start_line": null,
    "original_start_line": 745,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 746,
    "side": "RIGHT",
    "in_reply_to_id": 2203532553,
    "original_position": 746,
    "position": null,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203836196",
    "pull_request_review_id": 3014755031,
    "id": 2203836196,
    "node_id": "PRRC_kwDOD1hYKM6DW98k",
    "diff_hunk": "@@ -0,0 +1,848 @@\n+/** Gmail2Trello Application - ES6 Class Version\n+ */\n+\n+var Gmail2Trello = Gmail2Trello || {}; // Namespace initialization - must be var to guarantee correct scope\n+\n+class App {\n+  constructor() {\n+    this.CHROME_SETTINGS_ID = 'g2t_user_settings';\n+    this.UNIQUE_URI_VAR = 'g2t_filename';\n+\n+    this.model = new Gmail2Trello.Model(this);\n+    this.gmailView = new Gmail2Trello.GmailView(this);\n+    this.popupView = new Gmail2Trello.PopupView(this);\n+\n+    this.bindEvents();\n+  }\n+\n+  bindEvents() {\n+    const self = this;\n+\n+    /*** Data's events binding ***/\n+    this.model.event.addListener('onBeforeAuthorize', function () {\n+      self.popupView.bindData(''); // Intentionally blank\n+      self.popupView.showMessage(self, 'Authorizing...');\n+    });\n+\n+    this.model.event.addListener('onAuthorizeFail', function () {\n+      // self.model.isInitialized = false;\n+      self.popupView.showMessage(\n+        self,\n+        'Trello authorization failed <button id=\"showsignout\">Sign out and try again</button>'\n+      );\n+    });\n+\n+    this.model.event.addListener('onAuthorized', function () {\n+      // g2t_log('onAuthorized');\n+      // g2t_log(\"Status: \" + Trello.authorized().toString());\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+    });\n+\n+    this.model.event.addListener('onBeforeLoadTrello', function () {\n+      self.popupView.showMessage(self, 'Loading Trello data...');\n+    });\n+\n+    this.model.event.addListener('onTrelloDataReady', function () {\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+\n+      self.popupView.bindData(self.model);\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloListSuccess', function () {\n+      self.popupView.updateLists();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloCardsSuccess', function () {\n+      self.popupView.updateCards();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloLabelsSuccess', function () {\n+      self.popupView.updateLabels();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloMembersSuccess', function () {\n+      self.popupView.updateMembers();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener(\n+      'onCardSubmitComplete',\n+      function (target, params) {\n+        self.popupView.displaySubmitCompleteForm();\n+        // If card lists or labels have been updated, reload:\n+        const data_k = params?.data || {};\n+        const emailId = data_k?.emailId || 0;\n+        const boardId_k = data_k?.data?.board?.id || 0;\n+        const listId_k = data_k?.data?.list?.id || 0;\n+        const cardId_k = data_k?.data?.card?.id || 0;\n+        const idBoard_k = data_k?.idBoard || 0;\n+        const idList_k = data_k?.idList || 0;\n+        const idCard_k = data_k?.idCard || 0;\n+        const boardId = boardId_k || idBoard_k || 0;\n+        const listId = listId_k || idList_k || 0;\n+        const cardId = cardId_k || idCard_k || 0;\n+        // NOTE (acoven@2020-05-23): Users expect when creating a brand new card,\n+        // we'll remember that new card ID and then keep defaulting to it for\n+        // subsequent updates to that email. That means we'll have to get the return\n+        // value/url from Trello and dissect that, potentially doing this update\n+        // in that routine:\n+        self.model.emailBoardListCardMapUpdate({\n+          emailId,\n+          boardId,\n+          listId,\n+          cardId,\n+        });\n+\n+        if (boardId) {\n+          self.model.loadTrelloLabels(boardId);\n+          self.model.loadTrelloMembers(boardId);\n+        }\n+        if (listId) {\n+          self.model.loadTrelloCards(listId);\n+        }\n+      }\n+    );\n+\n+    this.model.event.addListener('onAPIFailure', function (target, params) {\n+      self.popupView.displayAPIFailedForm(params);\n+    });\n+\n+    /*** PopupView's events binding ***/\n+\n+    this.popupView.event.addListener('onPopupVisible', function () {\n+      if (!self.model.isInitialized) {\n+        self.popupView.showMessage(self, 'Initializing...');\n+        self.popupView.$popupContent.hide();\n+        self.model.init();\n+      } else {\n+        self.popupView.reset();\n+      }\n+\n+      const trelloUser_k = self?.model?.trello?.user || {};\n+      const fullName = trelloUser_k?.fullName || '';\n+\n+      self.gmailView.parsingData = false;\n+      self.model.gmail = self.gmailView.parseData({ fullName });\n+      self.popupView.bindGmailData(self.model.gmail);\n+      self.popupView.event.fire('periodicChecks');\n+    });\n+\n+    this.popupView.event.addListener('periodicChecks', function () {\n+      setTimeout(function () {\n+        self.popupView.periodicChecks();\n+      }, 3000);\n+    });\n+\n+    this.popupView.event.addListener('onBoardChanged', function (target, params) {\n+      let boardId = params.boardId;\n+      if (boardId !== '_' && boardId !== '' && boardId !== null) {\n+        self.model.loadTrelloLists(boardId);\n+        self.model.loadTrelloLabels(boardId);\n+        self.model.loadTrelloMembers(boardId);\n+      }\n+    });\n+\n+    this.popupView.event.addListener('onListChanged', function (target, params) {\n+      let listId = params.listId;\n+      self.model.loadTrelloCards(listId);\n+    });\n+\n+    this.popupView.event.addListener('onSubmit', function () {\n+      self.model.submit();\n+    });\n+\n+    this.popupView.event.addListener('checkTrelloAuthorized', function () {\n+      self.popupView.showMessage(self, 'Authorizing...');\n+      self.model.checkTrelloAuthorized();\n+    });\n+\n+    this.popupView.event.addListener('onRequestDeauthorizeTrello', function () {\n+      g2t_log('onRequestDeauthorizeTrello');\n+      self.model.deauthorizeTrello();\n+      self.popupView.clearBoard();\n+    });\n+\n+    const eventDetectButton = function () {\n+      if (self.gmailView.preDetect()) {\n+        self.popupView.$toolBar = self.gmailView.$toolBar;\n+        self.popupView.confirmPopup();\n+      }\n+    };\n+\n+    this.popupView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    // GMailView's events:\n+\n+    this.gmailView.event.addListener('onDetected', function () {\n+      self.popupView.$toolBar = self.gmailView.$toolBar;\n+      self.popupView.init();\n+    });\n+\n+    this.gmailView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    chrome.runtime.onMessage.addListener(function (\n+      request,\n+      sender,\n+      sendResponse\n+    ) {\n+      if (request?.message === 'g2t_keyboard_shortcut') {\n+        self.popupView.showPopup();\n+      }\n+    });\n+  }\n+\n+  updateData() {\n+    const self = this;\n+\n+    const fullName = self?.model?.trello?.user?.fullName || '';\n+\n+    self.popupView.bindData(self.model);\n+\n+    self.gmailView.parsingData = false;\n+    self.model.gmail = self.gmailView.parseData({ fullName });\n+    self.popupView.bindGmailData(self.model.gmail);\n+  }\n+\n+  initialize() {\n+    const self = this;\n+\n+    this.model.isInitialized = false;\n+\n+    // g2t_log('App:initialize');\n+\n+    this.gmailView.detect();\n+\n+    service = analytics.getService('gmail-2-trello');\n+\n+    // Get a Tracker using your Google Analytics app Tracking ID.\n+    tracker = service.getTracker('G-0QPEDL7YDL'); // Was: UA-8469046-1 -> UA-42442437-4\n+\n+    // Record an \"appView\" each time the user launches your app or goes to a new\n+    // screen within the app.\n+    tracker.sendAppView('PopupView');\n+  }\n+\n+  /**\n+   * Correctly escape RegExp\n+   */\n+  escapeRegExp(str) {\n+    return str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n+  }\n+\n+  /**\n+   * Utility routine to replace variables\n+   */\n+  replacer(text, dict) {\n+    let self = this;\n+\n+    if (!text || text.length < 1) {\n+      // g2t_log('Require text!');\n+      return '';\n+    } else if (!dict || dict.length < 2) {\n+      g2t_log('replacer: Require dictionary!');\n+      return text;\n+    }\n+\n+    let re, new_text;\n+    const replacify = function () {\n+      g2t_each(dict, function (value, key) {\n+        re = new RegExp(`%${self.escapeRegExp(key)}%`, 'gi');\n+        new_text = text.replace(re, value);\n+        text = new_text;\n+      });\n+    };\n+\n+    let runaway_max = 3;\n+    while (text.indexOf('%') !== -1 && runaway_max-- > 0) {\n+      replacify();\n+    }\n+\n+    return text;\n+  }\n+\n+  /**\n+   * Make displayable URI\n+   */\n+  uriForDisplay(uri) {\n+    const uri_display_trigger_length_k = 20;\n+    const uri_length_max_k = 40;\n+    let uri_display = uri || '';\n+    if (uri_display.length > uri_display_trigger_length_k) {\n+      let re = RegExp('^\\\\w+://([\\\\w./_-]+).*?([\\\\w._-]*)$');\n+      let matched = uri_display.match(re);\n+      if (matched && matched.length > 1) {\n+        const filename_k =\n+          matched[2].length < uri_length_max_k\n+            ? matched[2]\n+            : matched[2].slice(-uri_length_max_k);\n+        let prelude = matched[1].substr(0, uri_length_max_k);\n+        if (matched[1].length > uri_length_max_k) {\n+          prelude += '...';\n+        } else if (filename_k.length > 0) {\n+          prelude += ':';\n+        }\n+\n+        uri_display = prelude + filename_k;\n+      }\n+    }\n+    return uri_display;\n+  }\n+\n+  /**\n+   * Make anchored backlink\n+   */\n+  anchorMarkdownify(text, href, comment) {\n+    let text1 = (text || '').trim();\n+    let text1lc = text1.toLowerCase();\n+    let href1 = (href || '').trim();\n+    let href1lc = href1.toLowerCase();\n+    let comment1 = (comment || '').trim();\n+\n+    let retn = '';\n+\n+    if (text1.length < 1 && href1.length < 1) {\n+      // Intetionally blank\n+    } else if (text1lc === href1lc) {\n+      retn = ` <${href1}> `; // This renders correctly in Trello as a sole URL\n+      // NOTE (Ace, 17-Feb-2017): Turns out Trello doesn't support markdown [] only, so we'll construct a nice displayable text vs url:\n+      // text1 = this.uriForDisplay(text1);\n+    } else if (`mailto:${text1lc}` === href1lc) {\n+      retn = ` <${text1}> `; // This renders correctly in Trello as a mailto: url\n+    } else {\n+      const comment1QuotedSpaced = comment1.length > 0 ? ` \"${comment1}\"` : '';\n+      retn = ` [${text1}](<${href1}>${comment1QuotedSpaced}) `;\n+    }\n+\n+    return retn;\n+  }\n+\n+  /**\n+   * Split an email into name and domain\n+   */\n+  splitEmailDomain(email = '') {\n+    const split = email.split('@');\n+    const name = split[0] || '';\n+    const domain = split[1] || '';\n+    return {\n+      name,\n+      domain,\n+    };\n+  }\n+\n+  /**\n+   * Add trailing char if not empty:\n+   */\n+  addChar(front = '', back = '', addChar = ' ') {\n+    if (front.length > 0) {\n+      if (back.length > 0) {\n+        return `${front}${addChar}${back}`;\n+      } else {\n+        return `${front}${addChar}`;\n+      }\n+    } else if (back.length > 0) {\n+      return `${addChar}${back}`;\n+    } else {\n+      return '';\n+    }\n+  }\n+\n+  /**\n+   * Add trailing space if not empty:\n+   */\n+  addSpace(front = '', back = '') {\n+    return this.addChar(front, back, ' ');\n+  }\n+\n+  /**\n+   * Add trailing CRLF if not empty:\n+   */\n+  addCRLF(front = '', back = '') {\n+    return this.addChar(front, back, '\\n');\n+  }\n+\n+  /**\n+   * Markdownify a text block\n+   */\n+  markdownify($emailBody, features, preprocess) {\n+    if (!$emailBody || $emailBody.length < 1) {\n+      g2t_log('markdownify: Require emailBody!');\n+      return;\n+    }\n+    const self = this;\n+\n+    const min_text_length_k = 4;\n+    const max_replace_attempts_k = 10;\n+    const regexp_k = {\n+      begin: '(^|\\\\s+|<|\\\\[|\\\\(|\\\\b|(?=\\\\W+))',\n+      end: '($|\\\\s+|>|\\\\]|\\\\)|\\\\b|(?=\\\\W+))',\n+    };\n+    const unique_placeholder_k = 'g2t_placeholder:'; // Unique placeholder tag\n+\n+    let count = 0;\n+    let replacer_dict = {};\n+\n+    const featureEnabled = (elementTag = '') =>\n+      features === false ? false : features?.[elementTag] !== false;\n+\n+    let $html = $emailBody || ''; // Was: $emailBody.innerHTML || \"\";\n+    // let body = $emailBody.text() || \"\";\n+    let body = $emailBody.html() || '';\n+\n+    // Different encodings handle CRLF differently, so we'll process the main body as html and convert to text:\n+    // Convert paragraph marker to two returns:\n+    let replaced = body.replace(/\\s*[\\n\\r]*<p[^>]*>\\s*[\\n\\r]*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // Convert br marker to one return:\n+    replaced = body.replace(/\\s*[\\n\\r]*<br[^>]*>\\s*[\\n\\r]*/g, '\\n');\n+    body = replaced;\n+\n+    // Remove all other html markers:\n+    replaced = body.replace(/<[^>]*>/g, '');\n+    body = replaced;\n+\n+    // Decode HTML entities:\n+    replaced = self.decodeEntities(body);\n+    body = replaced;\n+\n+    // Replace hr:\n+    replaced = body.replace(/\\s*-{3,}\\s*/g, '---\\n');\n+    body = replaced;\n+\n+    // Convert crlf x 2 (or more) to paragraph markers:\n+    replaced = body.replace(/(\\s*[\\n\\r]\\s*){2,}/g, '<p />\\n');\n+    body = replaced;\n+\n+    let toProcess = {};\n+\n+    /**\n+     * 5 explicit steps in 3 passes:\n+     * (1) Collect tagged items\n+     * (2) Remove duplicates\n+     * (3) Sort force-lowercase by length\n+     * (4) Replace with placeholder\n+     * (5) Replace placeholders with final text\n+     */\n+    const sortAndPlaceholderize = function (tooProcess) {\n+      if (tooProcess) {\n+        g2t_each(\n+          Object.keys(tooProcess).sort(function (a, b) {\n+            // Go by order of largest to smallest\n+            return b.length - a.length;\n+          }),\n+          function (value) {\n+            const replace = tooProcess[value];\n+            const swap = `${unique_placeholder_k}${(count++).toString()}`;\n+            const re = new RegExp(\n+              regexp_k.begin + self.escapeRegExp(value) + regexp_k.end,\n+              'gi'\n+            );\n+            const replaced = body.replace(re, `%${swap}%`); // Replace occurance with placeholder\n+            if (body !== replaced) {\n+              body = replaced;\n+              replacer_dict[swap] = replace;\n+            }\n+          }\n+        );\n+      }\n+    };\n+    const processMarkdown = function (elementTag, replaceText) {\n+      if (elementTag && replaceText && featureEnabled(elementTag)) {\n+        toProcess = preprocess[elementTag] || {};\n+        $(elementTag, $html).each(function (index, value) {\n+          let text = ($(this).text() || '').trim();\n+          if (text && text.length > min_text_length_k) {\n+            let replace = self.replacer(replaceText, { text: text });\n+            toProcess[text.toLowerCase()] = replace; // Intentionally overwrites duplicates\n+          }\n+        });\n+        sortAndPlaceholderize(toProcess);\n+      }\n+    };\n+    /**\n+     * Repeat replace for max attempts or when done, whatever comes first\n+     */\n+    const repeatReplace = function (body, inRegexp, replaceWith) {\n+      let replace1 = '';\n+      for (let iter = max_replace_attempts_k; iter > 0; iter--) {\n+        replace1 = body.replace(inRegexp, replaceWith);\n+        if (body === replace1) {\n+          iter = 0; // All done\n+        } else {\n+          body = replace1;\n+        }\n+      }\n+      return body;\n+    };\n+\n+    // bullet lists:\n+    // ul li -> \" * \"\n+    processMarkdown('ul li', '<p />* %text%<p />');\n+\n+    // numeric lists:\n+    // ol li -> \" 1. \"\n+    processMarkdown('ol li', '<p />1. %text%<p />');\n+\n+    // headers:\n+    // H1 -> #\n+    // H2 -> ##\n+    // H3 -> ###\n+    // H4 -> ####\n+    // H5 -> #####\n+    // H6 -> ######\n+    if (featureEnabled('h')) {\n+      toProcess = preprocess['h'] || {};\n+      $(':header', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let nodeName = $(this).prop('nodeName') || '0';\n+        if (nodeName && text && text.length > min_text_length_k) {\n+          let x = nodeName.substr(-1);\n+          toProcess[text.toLowerCase()] = `\\n${'#'.repeat(x)} ${text}\\n`; // Intentionally overwrites duplicates\n+        }\n+      });\n+      sortAndPlaceholderize(toProcess);\n+    }\n+\n+    replaced = this.replacer(body, replacer_dict); // Replace initial batch of <div> like placeholders\n+    body = replaced;\n+    replacer_dict = {}; // Reset\n+    count = 0; // Reset\n+\n+    // bold: b -> **text**\n+    processMarkdown('b', ' **%text%** ');\n+\n+    // italics: i -> _text_\n+    processMarkdown('i', ' _%text%_ ');\n+\n+    // links:\n+    // a -> [text](html)\n+    if (featureEnabled('a')) {\n+      toProcess = preprocess['a'] || {};\n+      $('a', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let href = ($(this).prop('href') || '').trim(); // Was attr\n+        /*\n+              var uri_display = self.uriForDisplay(href);\n+              var comment = ' \"' + text + ' via ' + uri_display + '\"';\n+              var re = new RegExp(self.escapeRegExp(text), \"i\");\n+              if (uri.match(re)) {\n+                  comment = ' \"Open ' + uri_display + '\"';\n+              }\n+              */\n+        if (href && text && text.length >= min_text_length_k) {\n+          toProcess[text.toLowerCase()] = self.anchorMarkdownify(text, href); // Comment seemed like too much extra text // Intentionally overwrites duplicates\n+        }\n+      });\n+      sortAndPlaceholderize(toProcess);\n+    }\n+\n+    /* DISABLED (Ace, 16-Jan-2017): Images kinda make a mess, until requested lets not markdownify them:\n+      // images:\n+      // img -> ![alt_text](html)\n+      if (featureEnabled('img')) {\n+          $('img', $html).each(function(index, value) {\n+              var text = ($(this).prop(\"alt\") || \"\").trim(); // Was attr\n+              var href = ($(this).prop(\"src\") || \"\").trim(); // Was attr\n+              // var uri_display = self.uriForDisplay(href);\n+              if (href && text && text.length >= min_text_length_k) {\n+                  toProcess[text.toLowerCase()] = self.anchorMarkdownify(text, href); // Comment seemed like too much extra text // Intentionally overwrites duplicates\n+              }\n+          });\n+          sortAndPlaceholderize(toProcess);\n+      }\n+      */\n+\n+    replaced = this.replacer(body, replacer_dict); // Replace second batch of <span> like placeholders\n+    body = replaced;\n+\n+    // Replace bullets following a CRLF:\n+    replaced = body.replace(/\\s*[\\n\\r]+\\s*[·-]+\\s*/g, '<p />* '); // = [\\u00B7\\u2022]\n+    body = replaced;\n+\n+    // Replace remaining bullets with asterisks:\n+    replaced = body.replace(/[·]/g, '*');\n+    body = replaced;\n+\n+    // ORDER MATTERS FOR THIS NEXT SET:\n+    // (1) Replace <space>CRLF<space> with just CR:\n+    replaced = body.replace(/\\s*[\\n\\r]+\\s*/g, '\\n');\n+    body = replaced;\n+\n+    // (2) Replace 2 or more spaces with just one:\n+    replaced = repeatReplace(body, new RegExp('\\\\s{2,}', 'g'), ' ');\n+    body = replaced;\n+\n+    // (3) Replace paragraph markers with CR+CR:\n+    replaced = body.replace(/\\s*<p \\/>\\s*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // (4) Replace 3 or more CRs with just two:\n+    replaced = repeatReplace(body, new RegExp('\\\\n{3,}', 'g'), '\\n\\n');\n+    body = replaced;\n+\n+    // (5) Trim excess at beginning and end:\n+    replaced = body.trim();\n+    body = replaced;\n+\n+    return body;\n+  }\n+\n+  /**\n+   * Determine luminance of a color so we can augment with darker/lighter background\n+   */\n+  luminance(color) {\n+    let bkColorLight = 'lightGray'; // or white\n+    let bkColorDark = 'darkGray'; // 'gray' is even darker\n+    let bkColorReturn = bkColorLight;\n+\n+    let re = new RegExp('rgb\\\\D+(\\\\d+)\\\\D+(\\\\d+)\\\\D+(\\\\d+)');\n+    let matched = color.match(re, 'i');\n+    if (matched && matched.length > 2) {\n+      // 0 is total string:\n+      let r = matched[1];\n+      let g = matched[2];\n+      let b = matched[3];\n+      // var 1 = matched[4]; // if alpha is provided\n+\n+      let luma = 0.2126 * r + 0.7152 * g + 0.0722 * b; // per ITU-R BT.709\n+\n+      if (luma < 40) {\n+        bkColorReturn = bkColorDark;\n+      } else {\n+        bkColorReturn = bkColorLight;\n+      }\n+    } else {\n+      bkColorReturn = bkColorLight; // RegExp failed, assume dark color\n+    }\n+\n+    return 'inherit'; // Use: bkColorReturn if you want to adjust background based on text perceived brightness\n+  }\n+\n+  /**\n+   * HTML bookend a string\n+   */\n+  bookend(bookend, text, style) {\n+    return (\n+      '<' +\n+      bookend +\n+      (style ? ' style=\"' + style + '\"' : '') +\n+      '>' +\n+      (text || '') +\n+      '</' +\n+      bookend +\n+      '>'\n+    );\n+  }\n+\n+  /**\n+   * Get selected text\n+   * http://stackoverflow.com/questions/5379120/get-the-highlighted-selected-text\n+   */\n+  getSelectedText() {\n+    let text = '';\n+    let activeEl = document.activeElement;\n+    let activeElTagName = activeEl ? activeEl.tagName.toLowerCase() : null;\n+    if (\n+      (activeElTagName == 'textarea' || activeElTagName == 'input') &&\n+      /^(?:text|search|password|tel|url)$/i.test(activeEl.type) &&\n+      typeof activeEl.selectionStart == 'number'\n+    ) {\n+      text = activeEl.value\n+        .slice(activeEl.selectionStart, activeEl.selectionEnd)\n+        .trim();\n+    } else if (document.selection) {\n+      text = document.selection.createRange().text.trim();\n+    } else if (document.getSelection) {\n+      text = document.getSelection().toString().trim();\n+    } else if (window.getSelection) {\n+      text = window.getSelection().toString().trim();\n+    }\n+    return text;\n+  }\n+\n+  /**\n+   * Truncate a string\n+   */\n+  truncate(text, max, add) {\n+    let retn = text || '';\n+    const add_k = this.decodeEntities(add || '');\n+    const max_k = max - add_k.length;\n+\n+    if (text && text.length > max_k) {\n+      retn = text.slice(0, max_k) + add_k;\n+    }\n+    return retn;\n+  }\n+\n+  /***\n+   * Middle-truncate a string\n+   */\n+  midTruncate(text, max, add) {\n+    let retn = text || '';\n+    const add_k = this.decodeEntities(add || '');\n+    const max_k = Math.abs((max || 0) - add_k.length);\n+    const mid_k = (max_k + 0.01) / 2;\n+\n+    if (text && text.length > max_k) {\n+      retn = text.slice(0, mid_k + 1) + add_k + text.slice(-mid_k);\n+    }\n+    return retn;\n+  }\n+\n+  /**\n+   * Load settings\n+   */\n+  loadSettings(popup) {\n+    const self = this;\n+    const setID = self.CHROME_SETTINGS_ID;\n+    chrome.storage.sync.get(setID, function (response) {\n+      if (response?.[setID]) {\n+        // NOTE (Ace, 7-Feb-2017): Might need to store these off the app object:\n+        try {\n+          self.popupView.data.settings = JSON.parse(response[setID]);\n+        } catch (err) {\n+          g2t_log(\n+            'loadSettings: JSON parse failed! Error: ' + JSON.stringify(err)\n+          );\n+        }\n+      }\n+      if (popup) {\n+        popup.init_popup();\n+        self.updateData();\n+      }\n+    });\n+  }\n+\n+  /**\n+   * Save settings\n+   */\n+  saveSettings() {\n+    const self = this;\n+    const setID = self.CHROME_SETTINGS_ID;\n+    let settings = Object.assign({}, self.popupView.data.settings);\n+\n+    // Delete large, potentially needing secure, data bits:\n+    settings.description = '';\n+    settings.title = '';\n+    settings.attachments = [];\n+    settings.images = [];\n+    delete settings.description;\n+    delete settings.title;\n+    delete settings.attachments;\n+    delete settings.images;\n+\n+    const settings_string_k = JSON.stringify(settings);\n+\n+    hash = {};\n+    hash[setID] = settings_string_k;",
    "path": "chrome_manifest_v3/class_app.js",
    "commit_id": "3bbc7b0b5b5abfda366260c45d6f2cecebf28af3",
    "original_commit_id": "ae0a391b6759338b0ec3c3292da07e458841ab71",
    "user": {
      "login": "coderabbitai[bot]",
      "id": 136622811,
      "node_id": "BOT_kgDOCCSy2w",
      "avatar_url": "https://avatars.githubusercontent.com/in/347564?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/coderabbitai%5Bbot%5D",
      "html_url": "https://github.com/apps/coderabbitai",
      "followers_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "@acoven Now whut?\n\n\n\n## Task: Fix undeclared hash variable\n- Add `let` declaration to hash variable in saveSettings() method\n- Use `let` instead of `const` for semantic clarity about mutation intent\n\n<!-- <requirement>\n[requirement fix_hash_declaration_1/1]\nAdd `let` declaration to the hash variable in the saveSettings() method to fix the undeclared variable issue.\n\n[propose_code_change]\n\nFile: `chrome_manifest_v3/class_app.js`\n\n```diff\n-    hash = {};\n+    let hash = {};\n```\n</requirement> -->\n\n---\n\n<details>\n<summary>✏️ Learnings added</summary>\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#61\nFile: chrome_manifest_v3/class_app.js:685-686\nTimestamp: 2025-07-14T04:42:32.307Z\nLearning: In the gmail-2-trello project, when the maintainer asks to \"actually fix it\" after showing code examples, they want the code changes to be implemented using the plan_code_changes tag rather than just displaying the corrected code.\n```\n\n> Note: Learnings are effective only in the context of similar code segments. To apply general coding guidelines, please configure [review instructions](https://docs.coderabbit.ai/guides/review-instructions). You can manage existing learnings in the [app](https://app.coderabbit.ai/learnings).\n\n</details>\n\n\n\n---\n\n<details>\n<summary>🧠 Learnings used</summary>\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#58\nFile: chrome_manifest_v3/views/popupView.js:384-384\nTimestamp: 2025-07-12T14:58:20.670Z\nLearning: In the gmail-2-trello project, when analyzing `let self = this` patterns, the maintainer prefers to change `let` to `const` when keeping the self alias, and remove the alias entirely where it's not needed for scope preservation in nested callbacks.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#58\nFile: chrome_manifest_v3/views/popupView.js:1-1\nTimestamp: 2025-07-12T18:10:21.641Z\nLearning: In the gmail-2-trello project, when eliminating `let self = this` or `const self = this` patterns in functions that contain callbacks, the maintainer prefers converting callback functions to arrow functions to preserve `this` context, allowing direct use of `this` throughout the function instead of the `self` alias.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#57\nFile: docs/CHANGES.md:1-2\nTimestamp: 2025-07-11T16:23:16.422Z\nLearning: In the gmail-2-trello project, the docs/CHANGES.md file is copy-pasted to the Google Chrome extension dashboard, so it uses a custom changelog format with \"=== version@date ===\" entries rather than standard markdown formatting. Do not suggest adding markdown headers or other standard markdown formatting to this file.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#54\nFile: chrome_manifest_v3/service_worker.js:177-179\nTimestamp: 2025-07-10T05:06:47.579Z\nLearning: In the gmail-2-trello project, the maintainer prefers using `let` instead of `const` for object declarations when the object will be mutated (even if the reference doesn't change), for semantic clarity about mutation intent.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#0\nFile: :0-0\nTimestamp: 2025-07-12T20:10:59.237Z\nLearning: In the gmail-2-trello project, when modernizing the `validHash` function replacement, the maintainer clarified that the original function rejected numbers (including 0) because they lack a `.length` property, and asked for options to either maintain this strict behavior or expand acceptance to include numbers.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#57\nFile: chrome_manifest_v3/model.js:436-445\nTimestamp: 2025-07-11T16:58:40.928Z\nLearning: In the gmail-2-trello project, the maintainer prefers using `let` instead of `const` for array declarations when the array contents will be mutated (even if the reference doesn't change), for semantic clarity about mutation intent.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#58\nFile: chrome_manifest_v3/model.js:308-308\nTimestamp: 2025-07-12T14:49:03.264Z\nLearning: In the gmail-2-trello project, the original `validHash` function ensured that all properties in an object were not blank/empty, so when replacing it with modern JavaScript, use `Object.keys(args).every(key => !!args[key])` instead of `some()` to maintain the same validation semantics.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#58\nFile: chrome_manifest_v3/model.js:1-1\nTimestamp: 2025-07-12T22:39:35.702Z\nLearning: In the gmail-2-trello project, when using `.every()` for validation, consistently use the robust validation pattern `val != null && (typeof val === \"number\" || typeof val === \"boolean\" || val.length > 0)` instead of simple `!!` checks to properly handle numbers, booleans, null/undefined, and length requirements for strings/arrays.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#57\nFile: chrome_manifest_v3/service_worker.js:7-21\nTimestamp: 2025-07-11T16:26:28.197Z\nLearning: In the gmail-2-trello project, for Chrome extension service workers, Object.hasOwn() can be used directly instead of custom property checking functions since Chrome 93+ support is sufficient due to auto-updates, and the extension targets modern Chrome versions.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#51\nFile: package.json:3-3\nTimestamp: 2025-07-01T22:23:51.968Z\nLearning: In the gmail-2-trello project, the maintainer uses a custom four-segment versioning scheme (e.g., \"2.9.0.002\") instead of standard SemVer and wants to keep this format unchanged. Do not suggest SemVer compliance for version numbers in this project.\n```\n\n</details>\n\n\n\n---\n\n⏳ Preparing changes...\n\n\n<!-- <agentComponentType>chat-answer</agentComponentType> -->\n\n<!-- <rawResChunk><nextState>plan-edits</nextState></rawResChunk> -->\n\n<!-- <rawResChunk><answer>@acoven Now whut?\n\n\n\n## Task: Fix undeclared hash variable\n- Add `let` declaration to hash variable in saveSettings() method\n- Use `let` instead of `const` for semantic clarity about mutation intent\n\n&lt;!-- <requirement>\n[requirement fix_hash_declaration_1/1]\nAdd `let` declaration to the hash variable in the saveSettings() method to fix the undeclared variable issue.\n\n[propose_code_change]\n\nFile: `chrome_manifest_v3/class_app.js`\n\n```diff\n-    hash = {};\n+    let hash = {};\n```\n</requirement> --&gt;\n\n---\n\n<details>\n<summary>✏️ Learnings added</summary>\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#61\nFile: chrome_manifest_v3/class_app.js:685-686\nTimestamp: 2025-07-14T04:42:32.307Z\nLearning: In the gmail-2-trello project, when the maintainer asks to \"actually fix it\" after showing code examples, they want the code changes to be implemented using the plan_code_changes tag rather than just displaying the corrected code.\n```\n\n> Note: Learnings are effective only in the context of similar code segments. To apply general coding guidelines, please configure [review instructions](https://docs.coderabbit.ai/guides/review-instructions). You can manage existing learnings in the [app](https://app.coderabbit.ai/learnings).\n\n</details>\n\n\n\n---\n\n<details>\n<summary>🧠 Learnings used</summary>\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#58\nFile: chrome_manifest_v3/views/popupView.js:384-384\nTimestamp: 2025-07-12T14:58:20.670Z\nLearning: In the gmail-2-trello project, when analyzing `let self = this` patterns, the maintainer prefers to change `let` to `const` when keeping the self alias, and remove the alias entirely where it's not needed for scope preservation in nested callbacks.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#58\nFile: chrome_manifest_v3/views/popupView.js:1-1\nTimestamp: 2025-07-12T18:10:21.641Z\nLearning: In the gmail-2-trello project, when eliminating `let self = this` or `const self = this` patterns in functions that contain callbacks, the maintainer prefers converting callback functions to arrow functions to preserve `this` context, allowing direct use of `this` throughout the function instead of the `self` alias.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#57\nFile: docs/CHANGES.md:1-2\nTimestamp: 2025-07-11T16:23:16.422Z\nLearning: In the gmail-2-trello project, the docs/CHANGES.md file is copy-pasted to the Google Chrome extension dashboard, so it uses a custom changelog format with \"=== version@date ===\" entries rather than standard markdown formatting. Do not suggest adding markdown headers or other standard markdown formatting to this file.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#54\nFile: chrome_manifest_v3/service_worker.js:177-179\nTimestamp: 2025-07-10T05:06:47.579Z\nLearning: In the gmail-2-trello project, the maintainer prefers using `let` instead of `const` for object declarations when the object will be mutated (even if the reference doesn't change), for semantic clarity about mutation intent.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#0\nFile: :0-0\nTimestamp: 2025-07-12T20:10:59.237Z\nLearning: In the gmail-2-trello project, when modernizing the `validHash` function replacement, the maintainer clarified that the original function rejected numbers (including 0) because they lack a `.length` property, and asked for options to either maintain this strict behavior or expand acceptance to include numbers.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#57\nFile: chrome_manifest_v3/model.js:436-445\nTimestamp: 2025-07-11T16:58:40.928Z\nLearning: In the gmail-2-trello project, the maintainer prefers using `let` instead of `const` for array declarations when the array contents will be mutated (even if the reference doesn't change), for semantic clarity about mutation intent.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#58\nFile: chrome_manifest_v3/model.js:308-308\nTimestamp: 2025-07-12T14:49:03.264Z\nLearning: In the gmail-2-trello project, the original `validHash` function ensured that all properties in an object were not blank/empty, so when replacing it with modern JavaScript, use `Object.keys(args).every(key => !!args[key])` instead of `some()` to maintain the same validation semantics.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#58\nFile: chrome_manifest_v3/model.js:1-1\nTimestamp: 2025-07-12T22:39:35.702Z\nLearning: In the gmail-2-trello project, when using `.every()` for validation, consistently use the robust validation pattern `val != null && (typeof val === \"number\" || typeof val === \"boolean\" || val.length > 0)` instead of simple `!!` checks to properly handle numbers, booleans, null/undefined, and length requirements for strings/arrays.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#57\nFile: chrome_manifest_v3/service_worker.js:7-21\nTimestamp: 2025-07-11T16:26:28.197Z\nLearning: In the gmail-2-trello project, for Chrome extension service workers, Object.hasOwn() can be used directly instead of custom property checking functions since Chrome 93+ support is sufficient due to auto-updates, and the extension targets modern Chrome versions.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#51\nFile: package.json:3-3\nTimestamp: 2025-07-01T22:23:51.968Z\nLearning: In the gmail-2-trello project, the maintainer uses a custom four-segment versioning scheme (e.g., \"2.9.0.002\") instead of standard SemVer and wants to keep this format unchanged. Do not suggest SemVer compliance for version numbers in this project.\n```\n\n</details>\n\n\n\n---\n\n⏳ Preparing changes...\n\n</answer></rawResChunk> -->\n\n<!-- This is an auto-generated reply by CodeRabbit -->",
    "created_at": "2025-07-14T04:42:33Z",
    "updated_at": "2025-07-14T04:42:33Z",
    "html_url": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203836196",
    "pull_request_url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203836196"
      },
      "html": {
        "href": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203836196"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203836196/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 745,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 746,
    "side": "RIGHT",
    "in_reply_to_id": 2203532553,
    "original_position": 746,
    "position": null,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203836753",
    "pull_request_review_id": 3014755774,
    "id": 2203836753,
    "node_id": "PRRC_kwDOD1hYKM6DW-FR",
    "diff_hunk": "@@ -0,0 +1,848 @@\n+/** Gmail2Trello Application - ES6 Class Version\n+ */\n+\n+var Gmail2Trello = Gmail2Trello || {}; // Namespace initialization - must be var to guarantee correct scope\n+\n+class App {\n+  constructor() {\n+    this.CHROME_SETTINGS_ID = 'g2t_user_settings';\n+    this.UNIQUE_URI_VAR = 'g2t_filename';\n+\n+    this.model = new Gmail2Trello.Model(this);\n+    this.gmailView = new Gmail2Trello.GmailView(this);\n+    this.popupView = new Gmail2Trello.PopupView(this);\n+\n+    this.bindEvents();\n+  }\n+\n+  bindEvents() {\n+    const self = this;\n+\n+    /*** Data's events binding ***/\n+    this.model.event.addListener('onBeforeAuthorize', function () {\n+      self.popupView.bindData(''); // Intentionally blank\n+      self.popupView.showMessage(self, 'Authorizing...');\n+    });\n+\n+    this.model.event.addListener('onAuthorizeFail', function () {\n+      // self.model.isInitialized = false;\n+      self.popupView.showMessage(\n+        self,\n+        'Trello authorization failed <button id=\"showsignout\">Sign out and try again</button>'\n+      );\n+    });\n+\n+    this.model.event.addListener('onAuthorized', function () {\n+      // g2t_log('onAuthorized');\n+      // g2t_log(\"Status: \" + Trello.authorized().toString());\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+    });\n+\n+    this.model.event.addListener('onBeforeLoadTrello', function () {\n+      self.popupView.showMessage(self, 'Loading Trello data...');\n+    });\n+\n+    this.model.event.addListener('onTrelloDataReady', function () {\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+\n+      self.popupView.bindData(self.model);\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloListSuccess', function () {\n+      self.popupView.updateLists();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloCardsSuccess', function () {\n+      self.popupView.updateCards();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloLabelsSuccess', function () {\n+      self.popupView.updateLabels();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloMembersSuccess', function () {\n+      self.popupView.updateMembers();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener(\n+      'onCardSubmitComplete',\n+      function (target, params) {\n+        self.popupView.displaySubmitCompleteForm();\n+        // If card lists or labels have been updated, reload:\n+        const data_k = params?.data || {};\n+        const emailId = data_k?.emailId || 0;\n+        const boardId_k = data_k?.data?.board?.id || 0;\n+        const listId_k = data_k?.data?.list?.id || 0;\n+        const cardId_k = data_k?.data?.card?.id || 0;\n+        const idBoard_k = data_k?.idBoard || 0;\n+        const idList_k = data_k?.idList || 0;\n+        const idCard_k = data_k?.idCard || 0;\n+        const boardId = boardId_k || idBoard_k || 0;\n+        const listId = listId_k || idList_k || 0;\n+        const cardId = cardId_k || idCard_k || 0;\n+        // NOTE (acoven@2020-05-23): Users expect when creating a brand new card,\n+        // we'll remember that new card ID and then keep defaulting to it for\n+        // subsequent updates to that email. That means we'll have to get the return\n+        // value/url from Trello and dissect that, potentially doing this update\n+        // in that routine:\n+        self.model.emailBoardListCardMapUpdate({\n+          emailId,\n+          boardId,\n+          listId,\n+          cardId,\n+        });\n+\n+        if (boardId) {\n+          self.model.loadTrelloLabels(boardId);\n+          self.model.loadTrelloMembers(boardId);\n+        }\n+        if (listId) {\n+          self.model.loadTrelloCards(listId);\n+        }\n+      }\n+    );\n+\n+    this.model.event.addListener('onAPIFailure', function (target, params) {\n+      self.popupView.displayAPIFailedForm(params);\n+    });\n+\n+    /*** PopupView's events binding ***/\n+\n+    this.popupView.event.addListener('onPopupVisible', function () {\n+      if (!self.model.isInitialized) {\n+        self.popupView.showMessage(self, 'Initializing...');\n+        self.popupView.$popupContent.hide();\n+        self.model.init();\n+      } else {\n+        self.popupView.reset();\n+      }\n+\n+      const trelloUser_k = self?.model?.trello?.user || {};\n+      const fullName = trelloUser_k?.fullName || '';\n+\n+      self.gmailView.parsingData = false;\n+      self.model.gmail = self.gmailView.parseData({ fullName });\n+      self.popupView.bindGmailData(self.model.gmail);\n+      self.popupView.event.fire('periodicChecks');\n+    });\n+\n+    this.popupView.event.addListener('periodicChecks', function () {\n+      setTimeout(function () {\n+        self.popupView.periodicChecks();\n+      }, 3000);\n+    });\n+\n+    this.popupView.event.addListener('onBoardChanged', function (target, params) {\n+      let boardId = params.boardId;\n+      if (boardId !== '_' && boardId !== '' && boardId !== null) {\n+        self.model.loadTrelloLists(boardId);\n+        self.model.loadTrelloLabels(boardId);\n+        self.model.loadTrelloMembers(boardId);\n+      }\n+    });\n+\n+    this.popupView.event.addListener('onListChanged', function (target, params) {\n+      let listId = params.listId;\n+      self.model.loadTrelloCards(listId);\n+    });\n+\n+    this.popupView.event.addListener('onSubmit', function () {\n+      self.model.submit();\n+    });\n+\n+    this.popupView.event.addListener('checkTrelloAuthorized', function () {\n+      self.popupView.showMessage(self, 'Authorizing...');\n+      self.model.checkTrelloAuthorized();\n+    });\n+\n+    this.popupView.event.addListener('onRequestDeauthorizeTrello', function () {\n+      g2t_log('onRequestDeauthorizeTrello');\n+      self.model.deauthorizeTrello();\n+      self.popupView.clearBoard();\n+    });\n+\n+    const eventDetectButton = function () {\n+      if (self.gmailView.preDetect()) {\n+        self.popupView.$toolBar = self.gmailView.$toolBar;\n+        self.popupView.confirmPopup();\n+      }\n+    };\n+\n+    this.popupView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    // GMailView's events:\n+\n+    this.gmailView.event.addListener('onDetected', function () {\n+      self.popupView.$toolBar = self.gmailView.$toolBar;\n+      self.popupView.init();\n+    });\n+\n+    this.gmailView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    chrome.runtime.onMessage.addListener(function (\n+      request,\n+      sender,\n+      sendResponse\n+    ) {\n+      if (request?.message === 'g2t_keyboard_shortcut') {\n+        self.popupView.showPopup();\n+      }\n+    });\n+  }\n+\n+  updateData() {\n+    const self = this;\n+\n+    const fullName = self?.model?.trello?.user?.fullName || '';\n+\n+    self.popupView.bindData(self.model);\n+\n+    self.gmailView.parsingData = false;\n+    self.model.gmail = self.gmailView.parseData({ fullName });\n+    self.popupView.bindGmailData(self.model.gmail);\n+  }\n+\n+  initialize() {\n+    const self = this;\n+\n+    this.model.isInitialized = false;\n+\n+    // g2t_log('App:initialize');\n+\n+    this.gmailView.detect();\n+\n+    service = analytics.getService('gmail-2-trello');\n+\n+    // Get a Tracker using your Google Analytics app Tracking ID.\n+    tracker = service.getTracker('G-0QPEDL7YDL'); // Was: UA-8469046-1 -> UA-42442437-4\n+\n+    // Record an \"appView\" each time the user launches your app or goes to a new\n+    // screen within the app.\n+    tracker.sendAppView('PopupView');\n+  }\n+\n+  /**\n+   * Correctly escape RegExp\n+   */\n+  escapeRegExp(str) {\n+    return str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n+  }\n+\n+  /**\n+   * Utility routine to replace variables\n+   */\n+  replacer(text, dict) {\n+    let self = this;\n+\n+    if (!text || text.length < 1) {\n+      // g2t_log('Require text!');\n+      return '';\n+    } else if (!dict || dict.length < 2) {\n+      g2t_log('replacer: Require dictionary!');\n+      return text;\n+    }\n+\n+    let re, new_text;\n+    const replacify = function () {\n+      g2t_each(dict, function (value, key) {\n+        re = new RegExp(`%${self.escapeRegExp(key)}%`, 'gi');\n+        new_text = text.replace(re, value);\n+        text = new_text;\n+      });\n+    };\n+\n+    let runaway_max = 3;\n+    while (text.indexOf('%') !== -1 && runaway_max-- > 0) {\n+      replacify();\n+    }\n+\n+    return text;\n+  }\n+\n+  /**\n+   * Make displayable URI\n+   */\n+  uriForDisplay(uri) {\n+    const uri_display_trigger_length_k = 20;\n+    const uri_length_max_k = 40;\n+    let uri_display = uri || '';\n+    if (uri_display.length > uri_display_trigger_length_k) {\n+      let re = RegExp('^\\\\w+://([\\\\w./_-]+).*?([\\\\w._-]*)$');\n+      let matched = uri_display.match(re);\n+      if (matched && matched.length > 1) {\n+        const filename_k =\n+          matched[2].length < uri_length_max_k\n+            ? matched[2]\n+            : matched[2].slice(-uri_length_max_k);\n+        let prelude = matched[1].substr(0, uri_length_max_k);\n+        if (matched[1].length > uri_length_max_k) {\n+          prelude += '...';\n+        } else if (filename_k.length > 0) {\n+          prelude += ':';\n+        }\n+\n+        uri_display = prelude + filename_k;\n+      }\n+    }\n+    return uri_display;\n+  }\n+\n+  /**\n+   * Make anchored backlink\n+   */\n+  anchorMarkdownify(text, href, comment) {\n+    let text1 = (text || '').trim();\n+    let text1lc = text1.toLowerCase();\n+    let href1 = (href || '').trim();\n+    let href1lc = href1.toLowerCase();\n+    let comment1 = (comment || '').trim();\n+\n+    let retn = '';\n+\n+    if (text1.length < 1 && href1.length < 1) {\n+      // Intetionally blank\n+    } else if (text1lc === href1lc) {\n+      retn = ` <${href1}> `; // This renders correctly in Trello as a sole URL\n+      // NOTE (Ace, 17-Feb-2017): Turns out Trello doesn't support markdown [] only, so we'll construct a nice displayable text vs url:\n+      // text1 = this.uriForDisplay(text1);\n+    } else if (`mailto:${text1lc}` === href1lc) {\n+      retn = ` <${text1}> `; // This renders correctly in Trello as a mailto: url\n+    } else {\n+      const comment1QuotedSpaced = comment1.length > 0 ? ` \"${comment1}\"` : '';\n+      retn = ` [${text1}](<${href1}>${comment1QuotedSpaced}) `;\n+    }\n+\n+    return retn;\n+  }\n+\n+  /**\n+   * Split an email into name and domain\n+   */\n+  splitEmailDomain(email = '') {\n+    const split = email.split('@');\n+    const name = split[0] || '';\n+    const domain = split[1] || '';\n+    return {\n+      name,\n+      domain,\n+    };\n+  }\n+\n+  /**\n+   * Add trailing char if not empty:\n+   */\n+  addChar(front = '', back = '', addChar = ' ') {\n+    if (front.length > 0) {\n+      if (back.length > 0) {\n+        return `${front}${addChar}${back}`;\n+      } else {\n+        return `${front}${addChar}`;\n+      }\n+    } else if (back.length > 0) {\n+      return `${addChar}${back}`;\n+    } else {\n+      return '';\n+    }\n+  }\n+\n+  /**\n+   * Add trailing space if not empty:\n+   */\n+  addSpace(front = '', back = '') {\n+    return this.addChar(front, back, ' ');\n+  }\n+\n+  /**\n+   * Add trailing CRLF if not empty:\n+   */\n+  addCRLF(front = '', back = '') {\n+    return this.addChar(front, back, '\\n');\n+  }\n+\n+  /**\n+   * Markdownify a text block\n+   */\n+  markdownify($emailBody, features, preprocess) {\n+    if (!$emailBody || $emailBody.length < 1) {\n+      g2t_log('markdownify: Require emailBody!');\n+      return;\n+    }\n+    const self = this;\n+\n+    const min_text_length_k = 4;\n+    const max_replace_attempts_k = 10;\n+    const regexp_k = {\n+      begin: '(^|\\\\s+|<|\\\\[|\\\\(|\\\\b|(?=\\\\W+))',\n+      end: '($|\\\\s+|>|\\\\]|\\\\)|\\\\b|(?=\\\\W+))',\n+    };\n+    const unique_placeholder_k = 'g2t_placeholder:'; // Unique placeholder tag\n+\n+    let count = 0;\n+    let replacer_dict = {};\n+\n+    const featureEnabled = (elementTag = '') =>\n+      features === false ? false : features?.[elementTag] !== false;\n+\n+    let $html = $emailBody || ''; // Was: $emailBody.innerHTML || \"\";\n+    // let body = $emailBody.text() || \"\";\n+    let body = $emailBody.html() || '';\n+\n+    // Different encodings handle CRLF differently, so we'll process the main body as html and convert to text:\n+    // Convert paragraph marker to two returns:\n+    let replaced = body.replace(/\\s*[\\n\\r]*<p[^>]*>\\s*[\\n\\r]*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // Convert br marker to one return:\n+    replaced = body.replace(/\\s*[\\n\\r]*<br[^>]*>\\s*[\\n\\r]*/g, '\\n');\n+    body = replaced;\n+\n+    // Remove all other html markers:\n+    replaced = body.replace(/<[^>]*>/g, '');\n+    body = replaced;\n+\n+    // Decode HTML entities:\n+    replaced = self.decodeEntities(body);\n+    body = replaced;\n+\n+    // Replace hr:\n+    replaced = body.replace(/\\s*-{3,}\\s*/g, '---\\n');\n+    body = replaced;\n+\n+    // Convert crlf x 2 (or more) to paragraph markers:\n+    replaced = body.replace(/(\\s*[\\n\\r]\\s*){2,}/g, '<p />\\n');\n+    body = replaced;\n+\n+    let toProcess = {};\n+\n+    /**\n+     * 5 explicit steps in 3 passes:\n+     * (1) Collect tagged items\n+     * (2) Remove duplicates\n+     * (3) Sort force-lowercase by length\n+     * (4) Replace with placeholder\n+     * (5) Replace placeholders with final text\n+     */\n+    const sortAndPlaceholderize = function (tooProcess) {\n+      if (tooProcess) {\n+        g2t_each(\n+          Object.keys(tooProcess).sort(function (a, b) {\n+            // Go by order of largest to smallest\n+            return b.length - a.length;\n+          }),\n+          function (value) {\n+            const replace = tooProcess[value];\n+            const swap = `${unique_placeholder_k}${(count++).toString()}`;\n+            const re = new RegExp(\n+              regexp_k.begin + self.escapeRegExp(value) + regexp_k.end,\n+              'gi'\n+            );\n+            const replaced = body.replace(re, `%${swap}%`); // Replace occurance with placeholder\n+            if (body !== replaced) {\n+              body = replaced;\n+              replacer_dict[swap] = replace;\n+            }\n+          }\n+        );\n+      }\n+    };\n+    const processMarkdown = function (elementTag, replaceText) {\n+      if (elementTag && replaceText && featureEnabled(elementTag)) {\n+        toProcess = preprocess[elementTag] || {};\n+        $(elementTag, $html).each(function (index, value) {\n+          let text = ($(this).text() || '').trim();\n+          if (text && text.length > min_text_length_k) {\n+            let replace = self.replacer(replaceText, { text: text });\n+            toProcess[text.toLowerCase()] = replace; // Intentionally overwrites duplicates\n+          }\n+        });\n+        sortAndPlaceholderize(toProcess);\n+      }\n+    };\n+    /**\n+     * Repeat replace for max attempts or when done, whatever comes first\n+     */\n+    const repeatReplace = function (body, inRegexp, replaceWith) {\n+      let replace1 = '';\n+      for (let iter = max_replace_attempts_k; iter > 0; iter--) {\n+        replace1 = body.replace(inRegexp, replaceWith);\n+        if (body === replace1) {\n+          iter = 0; // All done\n+        } else {\n+          body = replace1;\n+        }\n+      }\n+      return body;\n+    };\n+\n+    // bullet lists:\n+    // ul li -> \" * \"\n+    processMarkdown('ul li', '<p />* %text%<p />');\n+\n+    // numeric lists:\n+    // ol li -> \" 1. \"\n+    processMarkdown('ol li', '<p />1. %text%<p />');\n+\n+    // headers:\n+    // H1 -> #\n+    // H2 -> ##\n+    // H3 -> ###\n+    // H4 -> ####\n+    // H5 -> #####\n+    // H6 -> ######\n+    if (featureEnabled('h')) {\n+      toProcess = preprocess['h'] || {};\n+      $(':header', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let nodeName = $(this).prop('nodeName') || '0';\n+        if (nodeName && text && text.length > min_text_length_k) {\n+          let x = nodeName.substr(-1);\n+          toProcess[text.toLowerCase()] = `\\n${'#'.repeat(x)} ${text}\\n`; // Intentionally overwrites duplicates\n+        }\n+      });\n+      sortAndPlaceholderize(toProcess);\n+    }\n+\n+    replaced = this.replacer(body, replacer_dict); // Replace initial batch of <div> like placeholders\n+    body = replaced;\n+    replacer_dict = {}; // Reset\n+    count = 0; // Reset\n+\n+    // bold: b -> **text**\n+    processMarkdown('b', ' **%text%** ');\n+\n+    // italics: i -> _text_\n+    processMarkdown('i', ' _%text%_ ');\n+\n+    // links:\n+    // a -> [text](html)\n+    if (featureEnabled('a')) {\n+      toProcess = preprocess['a'] || {};\n+      $('a', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let href = ($(this).prop('href') || '').trim(); // Was attr\n+        /*\n+              var uri_display = self.uriForDisplay(href);\n+              var comment = ' \"' + text + ' via ' + uri_display + '\"';\n+              var re = new RegExp(self.escapeRegExp(text), \"i\");\n+              if (uri.match(re)) {\n+                  comment = ' \"Open ' + uri_display + '\"';\n+              }\n+              */\n+        if (href && text && text.length >= min_text_length_k) {\n+          toProcess[text.toLowerCase()] = self.anchorMarkdownify(text, href); // Comment seemed like too much extra text // Intentionally overwrites duplicates\n+        }\n+      });\n+      sortAndPlaceholderize(toProcess);\n+    }\n+\n+    /* DISABLED (Ace, 16-Jan-2017): Images kinda make a mess, until requested lets not markdownify them:\n+      // images:\n+      // img -> ![alt_text](html)\n+      if (featureEnabled('img')) {\n+          $('img', $html).each(function(index, value) {\n+              var text = ($(this).prop(\"alt\") || \"\").trim(); // Was attr\n+              var href = ($(this).prop(\"src\") || \"\").trim(); // Was attr\n+              // var uri_display = self.uriForDisplay(href);\n+              if (href && text && text.length >= min_text_length_k) {\n+                  toProcess[text.toLowerCase()] = self.anchorMarkdownify(text, href); // Comment seemed like too much extra text // Intentionally overwrites duplicates\n+              }\n+          });\n+          sortAndPlaceholderize(toProcess);\n+      }\n+      */\n+\n+    replaced = this.replacer(body, replacer_dict); // Replace second batch of <span> like placeholders\n+    body = replaced;\n+\n+    // Replace bullets following a CRLF:\n+    replaced = body.replace(/\\s*[\\n\\r]+\\s*[·-]+\\s*/g, '<p />* '); // = [\\u00B7\\u2022]\n+    body = replaced;\n+\n+    // Replace remaining bullets with asterisks:\n+    replaced = body.replace(/[·]/g, '*');\n+    body = replaced;\n+\n+    // ORDER MATTERS FOR THIS NEXT SET:\n+    // (1) Replace <space>CRLF<space> with just CR:\n+    replaced = body.replace(/\\s*[\\n\\r]+\\s*/g, '\\n');\n+    body = replaced;\n+\n+    // (2) Replace 2 or more spaces with just one:\n+    replaced = repeatReplace(body, new RegExp('\\\\s{2,}', 'g'), ' ');\n+    body = replaced;\n+\n+    // (3) Replace paragraph markers with CR+CR:\n+    replaced = body.replace(/\\s*<p \\/>\\s*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // (4) Replace 3 or more CRs with just two:\n+    replaced = repeatReplace(body, new RegExp('\\\\n{3,}', 'g'), '\\n\\n');\n+    body = replaced;\n+\n+    // (5) Trim excess at beginning and end:\n+    replaced = body.trim();\n+    body = replaced;\n+\n+    return body;\n+  }\n+\n+  /**\n+   * Determine luminance of a color so we can augment with darker/lighter background\n+   */\n+  luminance(color) {\n+    let bkColorLight = 'lightGray'; // or white\n+    let bkColorDark = 'darkGray'; // 'gray' is even darker\n+    let bkColorReturn = bkColorLight;\n+\n+    let re = new RegExp('rgb\\\\D+(\\\\d+)\\\\D+(\\\\d+)\\\\D+(\\\\d+)');\n+    let matched = color.match(re, 'i');\n+    if (matched && matched.length > 2) {\n+      // 0 is total string:\n+      let r = matched[1];\n+      let g = matched[2];\n+      let b = matched[3];\n+      // var 1 = matched[4]; // if alpha is provided\n+\n+      let luma = 0.2126 * r + 0.7152 * g + 0.0722 * b; // per ITU-R BT.709\n+\n+      if (luma < 40) {\n+        bkColorReturn = bkColorDark;\n+      } else {\n+        bkColorReturn = bkColorLight;\n+      }\n+    } else {\n+      bkColorReturn = bkColorLight; // RegExp failed, assume dark color\n+    }\n+\n+    return 'inherit'; // Use: bkColorReturn if you want to adjust background based on text perceived brightness\n+  }\n+\n+  /**\n+   * HTML bookend a string\n+   */\n+  bookend(bookend, text, style) {\n+    return (\n+      '<' +\n+      bookend +\n+      (style ? ' style=\"' + style + '\"' : '') +\n+      '>' +\n+      (text || '') +\n+      '</' +\n+      bookend +\n+      '>'\n+    );\n+  }\n+\n+  /**\n+   * Get selected text\n+   * http://stackoverflow.com/questions/5379120/get-the-highlighted-selected-text\n+   */\n+  getSelectedText() {\n+    let text = '';\n+    let activeEl = document.activeElement;\n+    let activeElTagName = activeEl ? activeEl.tagName.toLowerCase() : null;\n+    if (\n+      (activeElTagName == 'textarea' || activeElTagName == 'input') &&\n+      /^(?:text|search|password|tel|url)$/i.test(activeEl.type) &&\n+      typeof activeEl.selectionStart == 'number'\n+    ) {\n+      text = activeEl.value\n+        .slice(activeEl.selectionStart, activeEl.selectionEnd)\n+        .trim();\n+    } else if (document.selection) {\n+      text = document.selection.createRange().text.trim();\n+    } else if (document.getSelection) {\n+      text = document.getSelection().toString().trim();\n+    } else if (window.getSelection) {\n+      text = window.getSelection().toString().trim();\n+    }\n+    return text;\n+  }\n+\n+  /**\n+   * Truncate a string\n+   */\n+  truncate(text, max, add) {\n+    let retn = text || '';\n+    const add_k = this.decodeEntities(add || '');\n+    const max_k = max - add_k.length;\n+\n+    if (text && text.length > max_k) {\n+      retn = text.slice(0, max_k) + add_k;\n+    }\n+    return retn;\n+  }\n+\n+  /***\n+   * Middle-truncate a string\n+   */\n+  midTruncate(text, max, add) {\n+    let retn = text || '';\n+    const add_k = this.decodeEntities(add || '');\n+    const max_k = Math.abs((max || 0) - add_k.length);\n+    const mid_k = (max_k + 0.01) / 2;\n+\n+    if (text && text.length > max_k) {\n+      retn = text.slice(0, mid_k + 1) + add_k + text.slice(-mid_k);\n+    }\n+    return retn;\n+  }\n+\n+  /**\n+   * Load settings\n+   */\n+  loadSettings(popup) {\n+    const self = this;\n+    const setID = self.CHROME_SETTINGS_ID;\n+    chrome.storage.sync.get(setID, function (response) {\n+      if (response?.[setID]) {\n+        // NOTE (Ace, 7-Feb-2017): Might need to store these off the app object:\n+        try {\n+          self.popupView.data.settings = JSON.parse(response[setID]);\n+        } catch (err) {\n+          g2t_log(\n+            'loadSettings: JSON parse failed! Error: ' + JSON.stringify(err)\n+          );\n+        }\n+      }\n+      if (popup) {\n+        popup.init_popup();\n+        self.updateData();\n+      }\n+    });\n+  }\n+\n+  /**\n+   * Save settings\n+   */\n+  saveSettings() {\n+    const self = this;\n+    const setID = self.CHROME_SETTINGS_ID;\n+    let settings = Object.assign({}, self.popupView.data.settings);\n+\n+    // Delete large, potentially needing secure, data bits:\n+    settings.description = '';\n+    settings.title = '';\n+    settings.attachments = [];\n+    settings.images = [];\n+    delete settings.description;\n+    delete settings.title;\n+    delete settings.attachments;\n+    delete settings.images;\n+\n+    const settings_string_k = JSON.stringify(settings);\n+\n+    hash = {};\n+    hash[setID] = settings_string_k;",
    "path": "chrome_manifest_v3/class_app.js",
    "commit_id": "3bbc7b0b5b5abfda366260c45d6f2cecebf28af3",
    "original_commit_id": "ae0a391b6759338b0ec3c3292da07e458841ab71",
    "user": {
      "login": "coderabbitai[bot]",
      "id": 136622811,
      "node_id": "BOT_kgDOCCSy2w",
      "avatar_url": "https://avatars.githubusercontent.com/in/347564?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/coderabbitai%5Bbot%5D",
      "html_url": "https://github.com/apps/coderabbitai",
      "followers_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "A summary of the changes CodeRabbit can apply:\n\n> - Modify the file `chrome_manifest_v3/class_app.js` by declaring the `hash` variable with `let` to fix the undeclared variable error.\n\n- [ ] <!-- {\"checkboxId\": \"85e7c9f1-3a23-4b8e-9f25-d7a5b234a8c1\", \"radioGroupId\": \"edit-actions-group-2203836753\"} --> Created local commit - (🔄 Check again to try again)\n\n<!-- <agentComponentType>plan-edits</agentComponentType> -->\n\n<!-- <rawResChunk><changeScript>```shell\n# Fix undeclared hash variable by adding let declaration\nsed -i 's/    hash = {};/    let hash = {};/' chrome_manifest_v3/class_app.js\n```</changeScript></rawResChunk> -->\n\n<!-- <rawResChunk><planSummary>- Modify the file `chrome_manifest_v3/class_app.js` by declaring the `hash` variable with `let` to fix the undeclared variable error.</planSummary></rawResChunk> -->\n\n<!-- This is an auto-generated reply by CodeRabbit -->",
    "created_at": "2025-07-14T04:43:16Z",
    "updated_at": "2025-07-14T04:54:09Z",
    "html_url": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203836753",
    "pull_request_url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203836753"
      },
      "html": {
        "href": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203836753"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203836753/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 745,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 746,
    "side": "RIGHT",
    "in_reply_to_id": 2203532553,
    "original_position": 746,
    "position": null,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203837679",
    "pull_request_review_id": 3014757135,
    "id": 2203837679,
    "node_id": "PRRC_kwDOD1hYKM6DW-Tv",
    "diff_hunk": "@@ -0,0 +1,848 @@\n+/** Gmail2Trello Application - ES6 Class Version\n+ */\n+\n+var Gmail2Trello = Gmail2Trello || {}; // Namespace initialization - must be var to guarantee correct scope\n+\n+class App {\n+  constructor() {\n+    this.CHROME_SETTINGS_ID = 'g2t_user_settings';\n+    this.UNIQUE_URI_VAR = 'g2t_filename';\n+\n+    this.model = new Gmail2Trello.Model(this);\n+    this.gmailView = new Gmail2Trello.GmailView(this);\n+    this.popupView = new Gmail2Trello.PopupView(this);\n+\n+    this.bindEvents();\n+  }\n+\n+  bindEvents() {\n+    const self = this;\n+\n+    /*** Data's events binding ***/\n+    this.model.event.addListener('onBeforeAuthorize', function () {\n+      self.popupView.bindData(''); // Intentionally blank\n+      self.popupView.showMessage(self, 'Authorizing...');\n+    });\n+\n+    this.model.event.addListener('onAuthorizeFail', function () {\n+      // self.model.isInitialized = false;\n+      self.popupView.showMessage(\n+        self,\n+        'Trello authorization failed <button id=\"showsignout\">Sign out and try again</button>'\n+      );\n+    });\n+\n+    this.model.event.addListener('onAuthorized', function () {\n+      // g2t_log('onAuthorized');\n+      // g2t_log(\"Status: \" + Trello.authorized().toString());\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+    });\n+\n+    this.model.event.addListener('onBeforeLoadTrello', function () {\n+      self.popupView.showMessage(self, 'Loading Trello data...');\n+    });\n+\n+    this.model.event.addListener('onTrelloDataReady', function () {\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+\n+      self.popupView.bindData(self.model);\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloListSuccess', function () {\n+      self.popupView.updateLists();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloCardsSuccess', function () {\n+      self.popupView.updateCards();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloLabelsSuccess', function () {\n+      self.popupView.updateLabels();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloMembersSuccess', function () {\n+      self.popupView.updateMembers();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener(\n+      'onCardSubmitComplete',\n+      function (target, params) {\n+        self.popupView.displaySubmitCompleteForm();\n+        // If card lists or labels have been updated, reload:\n+        const data_k = params?.data || {};\n+        const emailId = data_k?.emailId || 0;\n+        const boardId_k = data_k?.data?.board?.id || 0;\n+        const listId_k = data_k?.data?.list?.id || 0;\n+        const cardId_k = data_k?.data?.card?.id || 0;\n+        const idBoard_k = data_k?.idBoard || 0;\n+        const idList_k = data_k?.idList || 0;\n+        const idCard_k = data_k?.idCard || 0;\n+        const boardId = boardId_k || idBoard_k || 0;\n+        const listId = listId_k || idList_k || 0;\n+        const cardId = cardId_k || idCard_k || 0;\n+        // NOTE (acoven@2020-05-23): Users expect when creating a brand new card,\n+        // we'll remember that new card ID and then keep defaulting to it for\n+        // subsequent updates to that email. That means we'll have to get the return\n+        // value/url from Trello and dissect that, potentially doing this update\n+        // in that routine:\n+        self.model.emailBoardListCardMapUpdate({\n+          emailId,\n+          boardId,\n+          listId,\n+          cardId,\n+        });\n+\n+        if (boardId) {\n+          self.model.loadTrelloLabels(boardId);\n+          self.model.loadTrelloMembers(boardId);\n+        }\n+        if (listId) {\n+          self.model.loadTrelloCards(listId);\n+        }\n+      }\n+    );\n+\n+    this.model.event.addListener('onAPIFailure', function (target, params) {\n+      self.popupView.displayAPIFailedForm(params);\n+    });\n+\n+    /*** PopupView's events binding ***/\n+\n+    this.popupView.event.addListener('onPopupVisible', function () {\n+      if (!self.model.isInitialized) {\n+        self.popupView.showMessage(self, 'Initializing...');\n+        self.popupView.$popupContent.hide();\n+        self.model.init();\n+      } else {\n+        self.popupView.reset();\n+      }\n+\n+      const trelloUser_k = self?.model?.trello?.user || {};\n+      const fullName = trelloUser_k?.fullName || '';\n+\n+      self.gmailView.parsingData = false;\n+      self.model.gmail = self.gmailView.parseData({ fullName });\n+      self.popupView.bindGmailData(self.model.gmail);\n+      self.popupView.event.fire('periodicChecks');\n+    });\n+\n+    this.popupView.event.addListener('periodicChecks', function () {\n+      setTimeout(function () {\n+        self.popupView.periodicChecks();\n+      }, 3000);\n+    });\n+\n+    this.popupView.event.addListener('onBoardChanged', function (target, params) {\n+      let boardId = params.boardId;\n+      if (boardId !== '_' && boardId !== '' && boardId !== null) {\n+        self.model.loadTrelloLists(boardId);\n+        self.model.loadTrelloLabels(boardId);\n+        self.model.loadTrelloMembers(boardId);\n+      }\n+    });\n+\n+    this.popupView.event.addListener('onListChanged', function (target, params) {\n+      let listId = params.listId;\n+      self.model.loadTrelloCards(listId);\n+    });\n+\n+    this.popupView.event.addListener('onSubmit', function () {\n+      self.model.submit();\n+    });\n+\n+    this.popupView.event.addListener('checkTrelloAuthorized', function () {\n+      self.popupView.showMessage(self, 'Authorizing...');\n+      self.model.checkTrelloAuthorized();\n+    });\n+\n+    this.popupView.event.addListener('onRequestDeauthorizeTrello', function () {\n+      g2t_log('onRequestDeauthorizeTrello');\n+      self.model.deauthorizeTrello();\n+      self.popupView.clearBoard();\n+    });\n+\n+    const eventDetectButton = function () {\n+      if (self.gmailView.preDetect()) {\n+        self.popupView.$toolBar = self.gmailView.$toolBar;\n+        self.popupView.confirmPopup();\n+      }\n+    };\n+\n+    this.popupView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    // GMailView's events:\n+\n+    this.gmailView.event.addListener('onDetected', function () {\n+      self.popupView.$toolBar = self.gmailView.$toolBar;\n+      self.popupView.init();\n+    });\n+\n+    this.gmailView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    chrome.runtime.onMessage.addListener(function (\n+      request,\n+      sender,\n+      sendResponse\n+    ) {\n+      if (request?.message === 'g2t_keyboard_shortcut') {\n+        self.popupView.showPopup();\n+      }\n+    });\n+  }\n+\n+  updateData() {\n+    const self = this;\n+\n+    const fullName = self?.model?.trello?.user?.fullName || '';\n+\n+    self.popupView.bindData(self.model);\n+\n+    self.gmailView.parsingData = false;\n+    self.model.gmail = self.gmailView.parseData({ fullName });\n+    self.popupView.bindGmailData(self.model.gmail);\n+  }\n+\n+  initialize() {\n+    const self = this;\n+\n+    this.model.isInitialized = false;\n+\n+    // g2t_log('App:initialize');\n+\n+    this.gmailView.detect();\n+\n+    service = analytics.getService('gmail-2-trello');\n+\n+    // Get a Tracker using your Google Analytics app Tracking ID.\n+    tracker = service.getTracker('G-0QPEDL7YDL'); // Was: UA-8469046-1 -> UA-42442437-4\n+\n+    // Record an \"appView\" each time the user launches your app or goes to a new\n+    // screen within the app.\n+    tracker.sendAppView('PopupView');\n+  }\n+\n+  /**\n+   * Correctly escape RegExp\n+   */\n+  escapeRegExp(str) {\n+    return str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n+  }\n+\n+  /**\n+   * Utility routine to replace variables\n+   */\n+  replacer(text, dict) {\n+    let self = this;\n+\n+    if (!text || text.length < 1) {\n+      // g2t_log('Require text!');\n+      return '';\n+    } else if (!dict || dict.length < 2) {\n+      g2t_log('replacer: Require dictionary!');\n+      return text;\n+    }\n+\n+    let re, new_text;\n+    const replacify = function () {\n+      g2t_each(dict, function (value, key) {\n+        re = new RegExp(`%${self.escapeRegExp(key)}%`, 'gi');\n+        new_text = text.replace(re, value);\n+        text = new_text;\n+      });\n+    };\n+\n+    let runaway_max = 3;\n+    while (text.indexOf('%') !== -1 && runaway_max-- > 0) {\n+      replacify();\n+    }\n+\n+    return text;\n+  }\n+\n+  /**\n+   * Make displayable URI\n+   */\n+  uriForDisplay(uri) {\n+    const uri_display_trigger_length_k = 20;\n+    const uri_length_max_k = 40;\n+    let uri_display = uri || '';\n+    if (uri_display.length > uri_display_trigger_length_k) {\n+      let re = RegExp('^\\\\w+://([\\\\w./_-]+).*?([\\\\w._-]*)$');\n+      let matched = uri_display.match(re);\n+      if (matched && matched.length > 1) {\n+        const filename_k =\n+          matched[2].length < uri_length_max_k\n+            ? matched[2]\n+            : matched[2].slice(-uri_length_max_k);\n+        let prelude = matched[1].substr(0, uri_length_max_k);\n+        if (matched[1].length > uri_length_max_k) {\n+          prelude += '...';\n+        } else if (filename_k.length > 0) {\n+          prelude += ':';\n+        }\n+\n+        uri_display = prelude + filename_k;\n+      }\n+    }\n+    return uri_display;\n+  }\n+\n+  /**\n+   * Make anchored backlink\n+   */\n+  anchorMarkdownify(text, href, comment) {\n+    let text1 = (text || '').trim();\n+    let text1lc = text1.toLowerCase();\n+    let href1 = (href || '').trim();\n+    let href1lc = href1.toLowerCase();\n+    let comment1 = (comment || '').trim();\n+\n+    let retn = '';\n+\n+    if (text1.length < 1 && href1.length < 1) {\n+      // Intetionally blank\n+    } else if (text1lc === href1lc) {\n+      retn = ` <${href1}> `; // This renders correctly in Trello as a sole URL\n+      // NOTE (Ace, 17-Feb-2017): Turns out Trello doesn't support markdown [] only, so we'll construct a nice displayable text vs url:\n+      // text1 = this.uriForDisplay(text1);\n+    } else if (`mailto:${text1lc}` === href1lc) {\n+      retn = ` <${text1}> `; // This renders correctly in Trello as a mailto: url\n+    } else {\n+      const comment1QuotedSpaced = comment1.length > 0 ? ` \"${comment1}\"` : '';\n+      retn = ` [${text1}](<${href1}>${comment1QuotedSpaced}) `;\n+    }\n+\n+    return retn;\n+  }\n+\n+  /**\n+   * Split an email into name and domain\n+   */\n+  splitEmailDomain(email = '') {\n+    const split = email.split('@');\n+    const name = split[0] || '';\n+    const domain = split[1] || '';\n+    return {\n+      name,\n+      domain,\n+    };\n+  }\n+\n+  /**\n+   * Add trailing char if not empty:\n+   */\n+  addChar(front = '', back = '', addChar = ' ') {\n+    if (front.length > 0) {\n+      if (back.length > 0) {\n+        return `${front}${addChar}${back}`;\n+      } else {\n+        return `${front}${addChar}`;\n+      }\n+    } else if (back.length > 0) {\n+      return `${addChar}${back}`;\n+    } else {\n+      return '';\n+    }\n+  }\n+\n+  /**\n+   * Add trailing space if not empty:\n+   */\n+  addSpace(front = '', back = '') {\n+    return this.addChar(front, back, ' ');\n+  }\n+\n+  /**\n+   * Add trailing CRLF if not empty:\n+   */\n+  addCRLF(front = '', back = '') {\n+    return this.addChar(front, back, '\\n');\n+  }\n+\n+  /**\n+   * Markdownify a text block\n+   */\n+  markdownify($emailBody, features, preprocess) {\n+    if (!$emailBody || $emailBody.length < 1) {\n+      g2t_log('markdownify: Require emailBody!');\n+      return;\n+    }\n+    const self = this;\n+\n+    const min_text_length_k = 4;\n+    const max_replace_attempts_k = 10;\n+    const regexp_k = {\n+      begin: '(^|\\\\s+|<|\\\\[|\\\\(|\\\\b|(?=\\\\W+))',\n+      end: '($|\\\\s+|>|\\\\]|\\\\)|\\\\b|(?=\\\\W+))',\n+    };\n+    const unique_placeholder_k = 'g2t_placeholder:'; // Unique placeholder tag\n+\n+    let count = 0;\n+    let replacer_dict = {};\n+\n+    const featureEnabled = (elementTag = '') =>\n+      features === false ? false : features?.[elementTag] !== false;\n+\n+    let $html = $emailBody || ''; // Was: $emailBody.innerHTML || \"\";\n+    // let body = $emailBody.text() || \"\";\n+    let body = $emailBody.html() || '';\n+\n+    // Different encodings handle CRLF differently, so we'll process the main body as html and convert to text:\n+    // Convert paragraph marker to two returns:\n+    let replaced = body.replace(/\\s*[\\n\\r]*<p[^>]*>\\s*[\\n\\r]*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // Convert br marker to one return:\n+    replaced = body.replace(/\\s*[\\n\\r]*<br[^>]*>\\s*[\\n\\r]*/g, '\\n');\n+    body = replaced;\n+\n+    // Remove all other html markers:\n+    replaced = body.replace(/<[^>]*>/g, '');\n+    body = replaced;\n+\n+    // Decode HTML entities:\n+    replaced = self.decodeEntities(body);\n+    body = replaced;\n+\n+    // Replace hr:\n+    replaced = body.replace(/\\s*-{3,}\\s*/g, '---\\n');\n+    body = replaced;\n+\n+    // Convert crlf x 2 (or more) to paragraph markers:\n+    replaced = body.replace(/(\\s*[\\n\\r]\\s*){2,}/g, '<p />\\n');\n+    body = replaced;\n+\n+    let toProcess = {};\n+\n+    /**\n+     * 5 explicit steps in 3 passes:\n+     * (1) Collect tagged items\n+     * (2) Remove duplicates\n+     * (3) Sort force-lowercase by length\n+     * (4) Replace with placeholder\n+     * (5) Replace placeholders with final text\n+     */\n+    const sortAndPlaceholderize = function (tooProcess) {\n+      if (tooProcess) {\n+        g2t_each(\n+          Object.keys(tooProcess).sort(function (a, b) {\n+            // Go by order of largest to smallest\n+            return b.length - a.length;\n+          }),\n+          function (value) {\n+            const replace = tooProcess[value];\n+            const swap = `${unique_placeholder_k}${(count++).toString()}`;\n+            const re = new RegExp(\n+              regexp_k.begin + self.escapeRegExp(value) + regexp_k.end,\n+              'gi'\n+            );\n+            const replaced = body.replace(re, `%${swap}%`); // Replace occurance with placeholder\n+            if (body !== replaced) {\n+              body = replaced;\n+              replacer_dict[swap] = replace;\n+            }\n+          }\n+        );\n+      }\n+    };\n+    const processMarkdown = function (elementTag, replaceText) {\n+      if (elementTag && replaceText && featureEnabled(elementTag)) {\n+        toProcess = preprocess[elementTag] || {};\n+        $(elementTag, $html).each(function (index, value) {\n+          let text = ($(this).text() || '').trim();\n+          if (text && text.length > min_text_length_k) {\n+            let replace = self.replacer(replaceText, { text: text });\n+            toProcess[text.toLowerCase()] = replace; // Intentionally overwrites duplicates\n+          }\n+        });\n+        sortAndPlaceholderize(toProcess);\n+      }\n+    };\n+    /**\n+     * Repeat replace for max attempts or when done, whatever comes first\n+     */\n+    const repeatReplace = function (body, inRegexp, replaceWith) {\n+      let replace1 = '';\n+      for (let iter = max_replace_attempts_k; iter > 0; iter--) {\n+        replace1 = body.replace(inRegexp, replaceWith);\n+        if (body === replace1) {\n+          iter = 0; // All done\n+        } else {\n+          body = replace1;\n+        }\n+      }\n+      return body;\n+    };",
    "path": "chrome_manifest_v3/class_app.js",
    "commit_id": "3bbc7b0b5b5abfda366260c45d6f2cecebf28af3",
    "original_commit_id": "ae0a391b6759338b0ec3c3292da07e458841ab71",
    "user": {
      "login": "acoven",
      "id": 1631902,
      "node_id": "MDQ6VXNlcjE2MzE5MDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1631902?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/acoven",
      "html_url": "https://github.com/acoven",
      "followers_url": "https://api.github.com/users/acoven/followers",
      "following_url": "https://api.github.com/users/acoven/following{/other_user}",
      "gists_url": "https://api.github.com/users/acoven/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/acoven/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/acoven/subscriptions",
      "organizations_url": "https://api.github.com/users/acoven/orgs",
      "repos_url": "https://api.github.com/users/acoven/repos",
      "events_url": "https://api.github.com/users/acoven/events{/privacy}",
      "received_events_url": "https://api.github.com/users/acoven/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "What if bodyText is a very large text blob? Will we incur memory and copy penalties?",
    "created_at": "2025-07-14T04:44:34Z",
    "updated_at": "2025-07-14T04:44:35Z",
    "html_url": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203837679",
    "pull_request_url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203837679"
      },
      "html": {
        "href": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203837679"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203837679/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 1
    },
    "start_line": null,
    "original_start_line": 474,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 485,
    "side": "RIGHT",
    "in_reply_to_id": 2203532557,
    "original_position": 485,
    "position": null,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203838049",
    "pull_request_review_id": 3014757614,
    "id": 2203838049,
    "node_id": "PRRC_kwDOD1hYKM6DW-Zh",
    "diff_hunk": "@@ -0,0 +1,848 @@\n+/** Gmail2Trello Application - ES6 Class Version\n+ */\n+\n+var Gmail2Trello = Gmail2Trello || {}; // Namespace initialization - must be var to guarantee correct scope\n+\n+class App {\n+  constructor() {\n+    this.CHROME_SETTINGS_ID = 'g2t_user_settings';\n+    this.UNIQUE_URI_VAR = 'g2t_filename';\n+\n+    this.model = new Gmail2Trello.Model(this);\n+    this.gmailView = new Gmail2Trello.GmailView(this);\n+    this.popupView = new Gmail2Trello.PopupView(this);\n+\n+    this.bindEvents();\n+  }\n+\n+  bindEvents() {\n+    const self = this;\n+\n+    /*** Data's events binding ***/\n+    this.model.event.addListener('onBeforeAuthorize', function () {\n+      self.popupView.bindData(''); // Intentionally blank\n+      self.popupView.showMessage(self, 'Authorizing...');\n+    });\n+\n+    this.model.event.addListener('onAuthorizeFail', function () {\n+      // self.model.isInitialized = false;\n+      self.popupView.showMessage(\n+        self,\n+        'Trello authorization failed <button id=\"showsignout\">Sign out and try again</button>'\n+      );\n+    });\n+\n+    this.model.event.addListener('onAuthorized', function () {\n+      // g2t_log('onAuthorized');\n+      // g2t_log(\"Status: \" + Trello.authorized().toString());\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+    });\n+\n+    this.model.event.addListener('onBeforeLoadTrello', function () {\n+      self.popupView.showMessage(self, 'Loading Trello data...');\n+    });\n+\n+    this.model.event.addListener('onTrelloDataReady', function () {\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+\n+      self.popupView.bindData(self.model);\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloListSuccess', function () {\n+      self.popupView.updateLists();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloCardsSuccess', function () {\n+      self.popupView.updateCards();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloLabelsSuccess', function () {\n+      self.popupView.updateLabels();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloMembersSuccess', function () {\n+      self.popupView.updateMembers();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener(\n+      'onCardSubmitComplete',\n+      function (target, params) {\n+        self.popupView.displaySubmitCompleteForm();\n+        // If card lists or labels have been updated, reload:\n+        const data_k = params?.data || {};\n+        const emailId = data_k?.emailId || 0;\n+        const boardId_k = data_k?.data?.board?.id || 0;\n+        const listId_k = data_k?.data?.list?.id || 0;\n+        const cardId_k = data_k?.data?.card?.id || 0;\n+        const idBoard_k = data_k?.idBoard || 0;\n+        const idList_k = data_k?.idList || 0;\n+        const idCard_k = data_k?.idCard || 0;\n+        const boardId = boardId_k || idBoard_k || 0;\n+        const listId = listId_k || idList_k || 0;\n+        const cardId = cardId_k || idCard_k || 0;\n+        // NOTE (acoven@2020-05-23): Users expect when creating a brand new card,\n+        // we'll remember that new card ID and then keep defaulting to it for\n+        // subsequent updates to that email. That means we'll have to get the return\n+        // value/url from Trello and dissect that, potentially doing this update\n+        // in that routine:\n+        self.model.emailBoardListCardMapUpdate({\n+          emailId,\n+          boardId,\n+          listId,\n+          cardId,\n+        });\n+\n+        if (boardId) {\n+          self.model.loadTrelloLabels(boardId);\n+          self.model.loadTrelloMembers(boardId);\n+        }\n+        if (listId) {\n+          self.model.loadTrelloCards(listId);\n+        }\n+      }\n+    );\n+\n+    this.model.event.addListener('onAPIFailure', function (target, params) {\n+      self.popupView.displayAPIFailedForm(params);\n+    });\n+\n+    /*** PopupView's events binding ***/\n+\n+    this.popupView.event.addListener('onPopupVisible', function () {\n+      if (!self.model.isInitialized) {\n+        self.popupView.showMessage(self, 'Initializing...');\n+        self.popupView.$popupContent.hide();\n+        self.model.init();\n+      } else {\n+        self.popupView.reset();\n+      }\n+\n+      const trelloUser_k = self?.model?.trello?.user || {};\n+      const fullName = trelloUser_k?.fullName || '';\n+\n+      self.gmailView.parsingData = false;\n+      self.model.gmail = self.gmailView.parseData({ fullName });\n+      self.popupView.bindGmailData(self.model.gmail);\n+      self.popupView.event.fire('periodicChecks');\n+    });\n+\n+    this.popupView.event.addListener('periodicChecks', function () {\n+      setTimeout(function () {\n+        self.popupView.periodicChecks();\n+      }, 3000);\n+    });\n+\n+    this.popupView.event.addListener('onBoardChanged', function (target, params) {\n+      let boardId = params.boardId;\n+      if (boardId !== '_' && boardId !== '' && boardId !== null) {\n+        self.model.loadTrelloLists(boardId);\n+        self.model.loadTrelloLabels(boardId);\n+        self.model.loadTrelloMembers(boardId);\n+      }\n+    });\n+\n+    this.popupView.event.addListener('onListChanged', function (target, params) {\n+      let listId = params.listId;\n+      self.model.loadTrelloCards(listId);\n+    });\n+\n+    this.popupView.event.addListener('onSubmit', function () {\n+      self.model.submit();\n+    });\n+\n+    this.popupView.event.addListener('checkTrelloAuthorized', function () {\n+      self.popupView.showMessage(self, 'Authorizing...');\n+      self.model.checkTrelloAuthorized();\n+    });\n+\n+    this.popupView.event.addListener('onRequestDeauthorizeTrello', function () {\n+      g2t_log('onRequestDeauthorizeTrello');\n+      self.model.deauthorizeTrello();\n+      self.popupView.clearBoard();\n+    });\n+\n+    const eventDetectButton = function () {\n+      if (self.gmailView.preDetect()) {\n+        self.popupView.$toolBar = self.gmailView.$toolBar;\n+        self.popupView.confirmPopup();\n+      }\n+    };\n+\n+    this.popupView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    // GMailView's events:\n+\n+    this.gmailView.event.addListener('onDetected', function () {\n+      self.popupView.$toolBar = self.gmailView.$toolBar;\n+      self.popupView.init();\n+    });\n+\n+    this.gmailView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    chrome.runtime.onMessage.addListener(function (\n+      request,\n+      sender,\n+      sendResponse\n+    ) {\n+      if (request?.message === 'g2t_keyboard_shortcut') {\n+        self.popupView.showPopup();\n+      }\n+    });\n+  }\n+\n+  updateData() {\n+    const self = this;\n+\n+    const fullName = self?.model?.trello?.user?.fullName || '';\n+\n+    self.popupView.bindData(self.model);\n+\n+    self.gmailView.parsingData = false;\n+    self.model.gmail = self.gmailView.parseData({ fullName });\n+    self.popupView.bindGmailData(self.model.gmail);\n+  }\n+\n+  initialize() {\n+    const self = this;\n+\n+    this.model.isInitialized = false;\n+\n+    // g2t_log('App:initialize');\n+\n+    this.gmailView.detect();\n+\n+    service = analytics.getService('gmail-2-trello');\n+\n+    // Get a Tracker using your Google Analytics app Tracking ID.\n+    tracker = service.getTracker('G-0QPEDL7YDL'); // Was: UA-8469046-1 -> UA-42442437-4\n+\n+    // Record an \"appView\" each time the user launches your app or goes to a new\n+    // screen within the app.\n+    tracker.sendAppView('PopupView');\n+  }\n+\n+  /**\n+   * Correctly escape RegExp\n+   */\n+  escapeRegExp(str) {\n+    return str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n+  }\n+\n+  /**\n+   * Utility routine to replace variables\n+   */\n+  replacer(text, dict) {\n+    let self = this;\n+\n+    if (!text || text.length < 1) {\n+      // g2t_log('Require text!');\n+      return '';\n+    } else if (!dict || dict.length < 2) {\n+      g2t_log('replacer: Require dictionary!');\n+      return text;\n+    }\n+\n+    let re, new_text;\n+    const replacify = function () {\n+      g2t_each(dict, function (value, key) {\n+        re = new RegExp(`%${self.escapeRegExp(key)}%`, 'gi');\n+        new_text = text.replace(re, value);\n+        text = new_text;\n+      });\n+    };\n+\n+    let runaway_max = 3;\n+    while (text.indexOf('%') !== -1 && runaway_max-- > 0) {\n+      replacify();\n+    }\n+\n+    return text;\n+  }\n+\n+  /**\n+   * Make displayable URI\n+   */\n+  uriForDisplay(uri) {\n+    const uri_display_trigger_length_k = 20;\n+    const uri_length_max_k = 40;\n+    let uri_display = uri || '';\n+    if (uri_display.length > uri_display_trigger_length_k) {\n+      let re = RegExp('^\\\\w+://([\\\\w./_-]+).*?([\\\\w._-]*)$');\n+      let matched = uri_display.match(re);\n+      if (matched && matched.length > 1) {\n+        const filename_k =\n+          matched[2].length < uri_length_max_k\n+            ? matched[2]\n+            : matched[2].slice(-uri_length_max_k);\n+        let prelude = matched[1].substr(0, uri_length_max_k);\n+        if (matched[1].length > uri_length_max_k) {\n+          prelude += '...';\n+        } else if (filename_k.length > 0) {\n+          prelude += ':';\n+        }\n+\n+        uri_display = prelude + filename_k;\n+      }\n+    }\n+    return uri_display;\n+  }\n+\n+  /**\n+   * Make anchored backlink\n+   */\n+  anchorMarkdownify(text, href, comment) {\n+    let text1 = (text || '').trim();\n+    let text1lc = text1.toLowerCase();\n+    let href1 = (href || '').trim();\n+    let href1lc = href1.toLowerCase();\n+    let comment1 = (comment || '').trim();\n+\n+    let retn = '';\n+\n+    if (text1.length < 1 && href1.length < 1) {\n+      // Intetionally blank\n+    } else if (text1lc === href1lc) {\n+      retn = ` <${href1}> `; // This renders correctly in Trello as a sole URL\n+      // NOTE (Ace, 17-Feb-2017): Turns out Trello doesn't support markdown [] only, so we'll construct a nice displayable text vs url:\n+      // text1 = this.uriForDisplay(text1);\n+    } else if (`mailto:${text1lc}` === href1lc) {\n+      retn = ` <${text1}> `; // This renders correctly in Trello as a mailto: url\n+    } else {\n+      const comment1QuotedSpaced = comment1.length > 0 ? ` \"${comment1}\"` : '';\n+      retn = ` [${text1}](<${href1}>${comment1QuotedSpaced}) `;\n+    }\n+\n+    return retn;\n+  }\n+\n+  /**\n+   * Split an email into name and domain\n+   */\n+  splitEmailDomain(email = '') {\n+    const split = email.split('@');\n+    const name = split[0] || '';\n+    const domain = split[1] || '';\n+    return {\n+      name,\n+      domain,\n+    };\n+  }\n+\n+  /**\n+   * Add trailing char if not empty:\n+   */\n+  addChar(front = '', back = '', addChar = ' ') {\n+    if (front.length > 0) {\n+      if (back.length > 0) {\n+        return `${front}${addChar}${back}`;\n+      } else {\n+        return `${front}${addChar}`;\n+      }\n+    } else if (back.length > 0) {\n+      return `${addChar}${back}`;\n+    } else {\n+      return '';\n+    }\n+  }\n+\n+  /**\n+   * Add trailing space if not empty:\n+   */\n+  addSpace(front = '', back = '') {\n+    return this.addChar(front, back, ' ');\n+  }\n+\n+  /**\n+   * Add trailing CRLF if not empty:\n+   */\n+  addCRLF(front = '', back = '') {\n+    return this.addChar(front, back, '\\n');\n+  }\n+\n+  /**\n+   * Markdownify a text block\n+   */\n+  markdownify($emailBody, features, preprocess) {\n+    if (!$emailBody || $emailBody.length < 1) {\n+      g2t_log('markdownify: Require emailBody!');\n+      return;\n+    }\n+    const self = this;\n+\n+    const min_text_length_k = 4;\n+    const max_replace_attempts_k = 10;\n+    const regexp_k = {\n+      begin: '(^|\\\\s+|<|\\\\[|\\\\(|\\\\b|(?=\\\\W+))',\n+      end: '($|\\\\s+|>|\\\\]|\\\\)|\\\\b|(?=\\\\W+))',\n+    };\n+    const unique_placeholder_k = 'g2t_placeholder:'; // Unique placeholder tag\n+\n+    let count = 0;\n+    let replacer_dict = {};\n+\n+    const featureEnabled = (elementTag = '') =>\n+      features === false ? false : features?.[elementTag] !== false;\n+\n+    let $html = $emailBody || ''; // Was: $emailBody.innerHTML || \"\";\n+    // let body = $emailBody.text() || \"\";\n+    let body = $emailBody.html() || '';\n+\n+    // Different encodings handle CRLF differently, so we'll process the main body as html and convert to text:\n+    // Convert paragraph marker to two returns:\n+    let replaced = body.replace(/\\s*[\\n\\r]*<p[^>]*>\\s*[\\n\\r]*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // Convert br marker to one return:\n+    replaced = body.replace(/\\s*[\\n\\r]*<br[^>]*>\\s*[\\n\\r]*/g, '\\n');\n+    body = replaced;\n+\n+    // Remove all other html markers:\n+    replaced = body.replace(/<[^>]*>/g, '');\n+    body = replaced;\n+\n+    // Decode HTML entities:\n+    replaced = self.decodeEntities(body);\n+    body = replaced;\n+\n+    // Replace hr:\n+    replaced = body.replace(/\\s*-{3,}\\s*/g, '---\\n');\n+    body = replaced;\n+\n+    // Convert crlf x 2 (or more) to paragraph markers:\n+    replaced = body.replace(/(\\s*[\\n\\r]\\s*){2,}/g, '<p />\\n');\n+    body = replaced;\n+\n+    let toProcess = {};\n+\n+    /**\n+     * 5 explicit steps in 3 passes:\n+     * (1) Collect tagged items\n+     * (2) Remove duplicates\n+     * (3) Sort force-lowercase by length\n+     * (4) Replace with placeholder\n+     * (5) Replace placeholders with final text\n+     */\n+    const sortAndPlaceholderize = function (tooProcess) {\n+      if (tooProcess) {\n+        g2t_each(\n+          Object.keys(tooProcess).sort(function (a, b) {\n+            // Go by order of largest to smallest\n+            return b.length - a.length;\n+          }),\n+          function (value) {\n+            const replace = tooProcess[value];\n+            const swap = `${unique_placeholder_k}${(count++).toString()}`;\n+            const re = new RegExp(\n+              regexp_k.begin + self.escapeRegExp(value) + regexp_k.end,\n+              'gi'\n+            );\n+            const replaced = body.replace(re, `%${swap}%`); // Replace occurance with placeholder\n+            if (body !== replaced) {\n+              body = replaced;\n+              replacer_dict[swap] = replace;\n+            }\n+          }\n+        );\n+      }\n+    };\n+    const processMarkdown = function (elementTag, replaceText) {\n+      if (elementTag && replaceText && featureEnabled(elementTag)) {\n+        toProcess = preprocess[elementTag] || {};\n+        $(elementTag, $html).each(function (index, value) {\n+          let text = ($(this).text() || '').trim();\n+          if (text && text.length > min_text_length_k) {\n+            let replace = self.replacer(replaceText, { text: text });\n+            toProcess[text.toLowerCase()] = replace; // Intentionally overwrites duplicates\n+          }\n+        });\n+        sortAndPlaceholderize(toProcess);\n+      }\n+    };\n+    /**\n+     * Repeat replace for max attempts or when done, whatever comes first\n+     */\n+    const repeatReplace = function (body, inRegexp, replaceWith) {\n+      let replace1 = '';\n+      for (let iter = max_replace_attempts_k; iter > 0; iter--) {\n+        replace1 = body.replace(inRegexp, replaceWith);\n+        if (body === replace1) {\n+          iter = 0; // All done\n+        } else {\n+          body = replace1;\n+        }\n+      }\n+      return body;\n+    };",
    "path": "chrome_manifest_v3/class_app.js",
    "commit_id": "3bbc7b0b5b5abfda366260c45d6f2cecebf28af3",
    "original_commit_id": "ae0a391b6759338b0ec3c3292da07e458841ab71",
    "user": {
      "login": "coderabbitai[bot]",
      "id": 136622811,
      "node_id": "BOT_kgDOCCSy2w",
      "avatar_url": "https://avatars.githubusercontent.com/in/347564?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/coderabbitai%5Bbot%5D",
      "html_url": "https://github.com/apps/coderabbitai",
      "followers_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "@acoven No memory penalty. JavaScript strings immutable. `let body = bodyText` creates reference, not copy. Same memory usage as before.\n\nString `.replace()` already creating new objects in original code. Engine optimized for this.\n\nRefactor about code clarity. Not performance.\n\nI am the Batman.\n\n---\n\n<details>\n<summary>🧠 Learnings used</summary>\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#58\nFile: chrome_manifest_v3/views/popupView.js:384-384\nTimestamp: 2025-07-12T14:58:20.670Z\nLearning: In the gmail-2-trello project, when analyzing `let self = this` patterns, the maintainer prefers to change `let` to `const` when keeping the self alias, and remove the alias entirely where it's not needed for scope preservation in nested callbacks.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#58\nFile: chrome_manifest_v3/views/popupView.js:1-1\nTimestamp: 2025-07-12T18:10:21.641Z\nLearning: In the gmail-2-trello project, when eliminating `let self = this` or `const self = this` patterns in functions that contain callbacks, the maintainer prefers converting callback functions to arrow functions to preserve `this` context, allowing direct use of `this` throughout the function instead of the `self` alias.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#54\nFile: chrome_manifest_v3/service_worker.js:177-179\nTimestamp: 2025-07-10T05:06:47.579Z\nLearning: In the gmail-2-trello project, the maintainer prefers using `let` instead of `const` for object declarations when the object will be mutated (even if the reference doesn't change), for semantic clarity about mutation intent.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#58\nFile: chrome_manifest_v3/model.js:1-1\nTimestamp: 2025-07-12T22:39:35.702Z\nLearning: In the gmail-2-trello project, when using `.every()` for validation, consistently use the robust validation pattern `val != null && (typeof val === \"number\" || typeof val === \"boolean\" || val.length > 0)` instead of simple `!!` checks to properly handle numbers, booleans, null/undefined, and length requirements for strings/arrays.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#57\nFile: chrome_manifest_v3/model.js:436-445\nTimestamp: 2025-07-11T16:58:40.928Z\nLearning: In the gmail-2-trello project, the maintainer prefers using `let` instead of `const` for array declarations when the array contents will be mutated (even if the reference doesn't change), for semantic clarity about mutation intent.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#57\nFile: docs/CHANGES.md:1-2\nTimestamp: 2025-07-11T16:23:16.422Z\nLearning: In the gmail-2-trello project, the docs/CHANGES.md file is copy-pasted to the Google Chrome extension dashboard, so it uses a custom changelog format with \"=== version@date ===\" entries rather than standard markdown formatting. Do not suggest adding markdown headers or other standard markdown formatting to this file.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#58\nFile: chrome_manifest_v3/model.js:308-308\nTimestamp: 2025-07-12T14:49:03.264Z\nLearning: In the gmail-2-trello project, the original `validHash` function ensured that all properties in an object were not blank/empty, so when replacing it with modern JavaScript, use `Object.keys(args).every(key => !!args[key])` instead of `some()` to maintain the same validation semantics.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#0\nFile: :0-0\nTimestamp: 2025-07-12T20:10:59.237Z\nLearning: In the gmail-2-trello project, when modernizing the `validHash` function replacement, the maintainer clarified that the original function rejected numbers (including 0) because they lack a `.length` property, and asked for options to either maintain this strict behavior or expand acceptance to include numbers.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#61\nFile: chrome_manifest_v3/class_app.js:685-686\nTimestamp: 2025-07-14T04:42:32.307Z\nLearning: In the gmail-2-trello project, when the maintainer asks to \"actually fix it\" after showing code examples, they want the code changes to be implemented using the plan_code_changes tag rather than just displaying the corrected code.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#51\nFile: package.json:3-3\nTimestamp: 2025-07-01T22:23:51.968Z\nLearning: In the gmail-2-trello project, the maintainer uses a custom four-segment versioning scheme (e.g., \"2.9.0.002\") instead of standard SemVer and wants to keep this format unchanged. Do not suggest SemVer compliance for version numbers in this project.\n```\n\n</details>\n\n\n<!-- <agentComponentType>chat-answer</agentComponentType> -->\n\n<!-- <rawResChunk><answer>@acoven No memory penalty. JavaScript strings immutable. `let body = bodyText` creates reference, not copy. Same memory usage as before.\n\nString `.replace()` already creating new objects in original code. Engine optimized for this.\n\nRefactor about code clarity. Not performance.\n\nI am the Batman.\n\n---\n\n<details>\n<summary>🧠 Learnings used</summary>\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#58\nFile: chrome_manifest_v3/views/popupView.js:384-384\nTimestamp: 2025-07-12T14:58:20.670Z\nLearning: In the gmail-2-trello project, when analyzing `let self = this` patterns, the maintainer prefers to change `let` to `const` when keeping the self alias, and remove the alias entirely where it's not needed for scope preservation in nested callbacks.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#58\nFile: chrome_manifest_v3/views/popupView.js:1-1\nTimestamp: 2025-07-12T18:10:21.641Z\nLearning: In the gmail-2-trello project, when eliminating `let self = this` or `const self = this` patterns in functions that contain callbacks, the maintainer prefers converting callback functions to arrow functions to preserve `this` context, allowing direct use of `this` throughout the function instead of the `self` alias.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#54\nFile: chrome_manifest_v3/service_worker.js:177-179\nTimestamp: 2025-07-10T05:06:47.579Z\nLearning: In the gmail-2-trello project, the maintainer prefers using `let` instead of `const` for object declarations when the object will be mutated (even if the reference doesn't change), for semantic clarity about mutation intent.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#58\nFile: chrome_manifest_v3/model.js:1-1\nTimestamp: 2025-07-12T22:39:35.702Z\nLearning: In the gmail-2-trello project, when using `.every()` for validation, consistently use the robust validation pattern `val != null && (typeof val === \"number\" || typeof val === \"boolean\" || val.length > 0)` instead of simple `!!` checks to properly handle numbers, booleans, null/undefined, and length requirements for strings/arrays.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#57\nFile: chrome_manifest_v3/model.js:436-445\nTimestamp: 2025-07-11T16:58:40.928Z\nLearning: In the gmail-2-trello project, the maintainer prefers using `let` instead of `const` for array declarations when the array contents will be mutated (even if the reference doesn't change), for semantic clarity about mutation intent.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#57\nFile: docs/CHANGES.md:1-2\nTimestamp: 2025-07-11T16:23:16.422Z\nLearning: In the gmail-2-trello project, the docs/CHANGES.md file is copy-pasted to the Google Chrome extension dashboard, so it uses a custom changelog format with \"=== version@date ===\" entries rather than standard markdown formatting. Do not suggest adding markdown headers or other standard markdown formatting to this file.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#58\nFile: chrome_manifest_v3/model.js:308-308\nTimestamp: 2025-07-12T14:49:03.264Z\nLearning: In the gmail-2-trello project, the original `validHash` function ensured that all properties in an object were not blank/empty, so when replacing it with modern JavaScript, use `Object.keys(args).every(key => !!args[key])` instead of `some()` to maintain the same validation semantics.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#0\nFile: :0-0\nTimestamp: 2025-07-12T20:10:59.237Z\nLearning: In the gmail-2-trello project, when modernizing the `validHash` function replacement, the maintainer clarified that the original function rejected numbers (including 0) because they lack a `.length` property, and asked for options to either maintain this strict behavior or expand acceptance to include numbers.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#61\nFile: chrome_manifest_v3/class_app.js:685-686\nTimestamp: 2025-07-14T04:42:32.307Z\nLearning: In the gmail-2-trello project, when the maintainer asks to \"actually fix it\" after showing code examples, they want the code changes to be implemented using the plan_code_changes tag rather than just displaying the corrected code.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#51\nFile: package.json:3-3\nTimestamp: 2025-07-01T22:23:51.968Z\nLearning: In the gmail-2-trello project, the maintainer uses a custom four-segment versioning scheme (e.g., \"2.9.0.002\") instead of standard SemVer and wants to keep this format unchanged. Do not suggest SemVer compliance for version numbers in this project.\n```\n\n</details>\n\n</answer></rawResChunk> -->\n\n<!-- This is an auto-generated reply by CodeRabbit -->",
    "created_at": "2025-07-14T04:45:00Z",
    "updated_at": "2025-07-14T04:45:00Z",
    "html_url": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203838049",
    "pull_request_url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203838049"
      },
      "html": {
        "href": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203838049"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203838049/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 474,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 485,
    "side": "RIGHT",
    "in_reply_to_id": 2203532557,
    "original_position": 485,
    "position": null,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203839325",
    "pull_request_review_id": 3014759574,
    "id": 2203839325,
    "node_id": "PRRC_kwDOD1hYKM6DW-td",
    "diff_hunk": "@@ -0,0 +1,848 @@\n+/** Gmail2Trello Application - ES6 Class Version\n+ */\n+\n+var Gmail2Trello = Gmail2Trello || {}; // Namespace initialization - must be var to guarantee correct scope\n+\n+class App {\n+  constructor() {\n+    this.CHROME_SETTINGS_ID = 'g2t_user_settings';\n+    this.UNIQUE_URI_VAR = 'g2t_filename';\n+\n+    this.model = new Gmail2Trello.Model(this);\n+    this.gmailView = new Gmail2Trello.GmailView(this);\n+    this.popupView = new Gmail2Trello.PopupView(this);\n+\n+    this.bindEvents();\n+  }\n+\n+  bindEvents() {\n+    const self = this;\n+\n+    /*** Data's events binding ***/\n+    this.model.event.addListener('onBeforeAuthorize', function () {\n+      self.popupView.bindData(''); // Intentionally blank\n+      self.popupView.showMessage(self, 'Authorizing...');\n+    });\n+\n+    this.model.event.addListener('onAuthorizeFail', function () {\n+      // self.model.isInitialized = false;\n+      self.popupView.showMessage(\n+        self,\n+        'Trello authorization failed <button id=\"showsignout\">Sign out and try again</button>'\n+      );\n+    });\n+\n+    this.model.event.addListener('onAuthorized', function () {\n+      // g2t_log('onAuthorized');\n+      // g2t_log(\"Status: \" + Trello.authorized().toString());\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+    });\n+\n+    this.model.event.addListener('onBeforeLoadTrello', function () {\n+      self.popupView.showMessage(self, 'Loading Trello data...');\n+    });\n+\n+    this.model.event.addListener('onTrelloDataReady', function () {\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+\n+      self.popupView.bindData(self.model);\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloListSuccess', function () {\n+      self.popupView.updateLists();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloCardsSuccess', function () {\n+      self.popupView.updateCards();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloLabelsSuccess', function () {\n+      self.popupView.updateLabels();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloMembersSuccess', function () {\n+      self.popupView.updateMembers();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener(\n+      'onCardSubmitComplete',\n+      function (target, params) {\n+        self.popupView.displaySubmitCompleteForm();\n+        // If card lists or labels have been updated, reload:\n+        const data_k = params?.data || {};\n+        const emailId = data_k?.emailId || 0;\n+        const boardId_k = data_k?.data?.board?.id || 0;\n+        const listId_k = data_k?.data?.list?.id || 0;\n+        const cardId_k = data_k?.data?.card?.id || 0;\n+        const idBoard_k = data_k?.idBoard || 0;\n+        const idList_k = data_k?.idList || 0;\n+        const idCard_k = data_k?.idCard || 0;\n+        const boardId = boardId_k || idBoard_k || 0;\n+        const listId = listId_k || idList_k || 0;\n+        const cardId = cardId_k || idCard_k || 0;\n+        // NOTE (acoven@2020-05-23): Users expect when creating a brand new card,\n+        // we'll remember that new card ID and then keep defaulting to it for\n+        // subsequent updates to that email. That means we'll have to get the return\n+        // value/url from Trello and dissect that, potentially doing this update\n+        // in that routine:\n+        self.model.emailBoardListCardMapUpdate({\n+          emailId,\n+          boardId,\n+          listId,\n+          cardId,\n+        });\n+\n+        if (boardId) {\n+          self.model.loadTrelloLabels(boardId);\n+          self.model.loadTrelloMembers(boardId);\n+        }\n+        if (listId) {\n+          self.model.loadTrelloCards(listId);\n+        }\n+      }\n+    );\n+\n+    this.model.event.addListener('onAPIFailure', function (target, params) {\n+      self.popupView.displayAPIFailedForm(params);\n+    });\n+\n+    /*** PopupView's events binding ***/\n+\n+    this.popupView.event.addListener('onPopupVisible', function () {\n+      if (!self.model.isInitialized) {\n+        self.popupView.showMessage(self, 'Initializing...');\n+        self.popupView.$popupContent.hide();\n+        self.model.init();\n+      } else {\n+        self.popupView.reset();\n+      }\n+\n+      const trelloUser_k = self?.model?.trello?.user || {};\n+      const fullName = trelloUser_k?.fullName || '';\n+\n+      self.gmailView.parsingData = false;\n+      self.model.gmail = self.gmailView.parseData({ fullName });\n+      self.popupView.bindGmailData(self.model.gmail);\n+      self.popupView.event.fire('periodicChecks');\n+    });\n+\n+    this.popupView.event.addListener('periodicChecks', function () {\n+      setTimeout(function () {\n+        self.popupView.periodicChecks();\n+      }, 3000);\n+    });\n+\n+    this.popupView.event.addListener('onBoardChanged', function (target, params) {\n+      let boardId = params.boardId;\n+      if (boardId !== '_' && boardId !== '' && boardId !== null) {\n+        self.model.loadTrelloLists(boardId);\n+        self.model.loadTrelloLabels(boardId);\n+        self.model.loadTrelloMembers(boardId);\n+      }\n+    });\n+\n+    this.popupView.event.addListener('onListChanged', function (target, params) {\n+      let listId = params.listId;\n+      self.model.loadTrelloCards(listId);\n+    });\n+\n+    this.popupView.event.addListener('onSubmit', function () {\n+      self.model.submit();\n+    });\n+\n+    this.popupView.event.addListener('checkTrelloAuthorized', function () {\n+      self.popupView.showMessage(self, 'Authorizing...');\n+      self.model.checkTrelloAuthorized();\n+    });\n+\n+    this.popupView.event.addListener('onRequestDeauthorizeTrello', function () {\n+      g2t_log('onRequestDeauthorizeTrello');\n+      self.model.deauthorizeTrello();\n+      self.popupView.clearBoard();\n+    });\n+\n+    const eventDetectButton = function () {\n+      if (self.gmailView.preDetect()) {\n+        self.popupView.$toolBar = self.gmailView.$toolBar;\n+        self.popupView.confirmPopup();\n+      }\n+    };\n+\n+    this.popupView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    // GMailView's events:\n+\n+    this.gmailView.event.addListener('onDetected', function () {\n+      self.popupView.$toolBar = self.gmailView.$toolBar;\n+      self.popupView.init();\n+    });\n+\n+    this.gmailView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    chrome.runtime.onMessage.addListener(function (\n+      request,\n+      sender,\n+      sendResponse\n+    ) {\n+      if (request?.message === 'g2t_keyboard_shortcut') {\n+        self.popupView.showPopup();\n+      }\n+    });\n+  }\n+\n+  updateData() {\n+    const self = this;\n+\n+    const fullName = self?.model?.trello?.user?.fullName || '';\n+\n+    self.popupView.bindData(self.model);\n+\n+    self.gmailView.parsingData = false;\n+    self.model.gmail = self.gmailView.parseData({ fullName });\n+    self.popupView.bindGmailData(self.model.gmail);\n+  }\n+\n+  initialize() {\n+    const self = this;\n+\n+    this.model.isInitialized = false;\n+\n+    // g2t_log('App:initialize');\n+\n+    this.gmailView.detect();\n+\n+    service = analytics.getService('gmail-2-trello');\n+\n+    // Get a Tracker using your Google Analytics app Tracking ID.\n+    tracker = service.getTracker('G-0QPEDL7YDL'); // Was: UA-8469046-1 -> UA-42442437-4\n+\n+    // Record an \"appView\" each time the user launches your app or goes to a new\n+    // screen within the app.\n+    tracker.sendAppView('PopupView');\n+  }\n+\n+  /**\n+   * Correctly escape RegExp\n+   */\n+  escapeRegExp(str) {\n+    return str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n+  }\n+\n+  /**\n+   * Utility routine to replace variables\n+   */\n+  replacer(text, dict) {\n+    let self = this;\n+\n+    if (!text || text.length < 1) {\n+      // g2t_log('Require text!');\n+      return '';\n+    } else if (!dict || dict.length < 2) {\n+      g2t_log('replacer: Require dictionary!');\n+      return text;\n+    }\n+\n+    let re, new_text;\n+    const replacify = function () {\n+      g2t_each(dict, function (value, key) {\n+        re = new RegExp(`%${self.escapeRegExp(key)}%`, 'gi');\n+        new_text = text.replace(re, value);\n+        text = new_text;\n+      });\n+    };\n+\n+    let runaway_max = 3;\n+    while (text.indexOf('%') !== -1 && runaway_max-- > 0) {\n+      replacify();\n+    }\n+\n+    return text;\n+  }\n+\n+  /**\n+   * Make displayable URI\n+   */\n+  uriForDisplay(uri) {\n+    const uri_display_trigger_length_k = 20;\n+    const uri_length_max_k = 40;\n+    let uri_display = uri || '';\n+    if (uri_display.length > uri_display_trigger_length_k) {\n+      let re = RegExp('^\\\\w+://([\\\\w./_-]+).*?([\\\\w._-]*)$');\n+      let matched = uri_display.match(re);\n+      if (matched && matched.length > 1) {\n+        const filename_k =\n+          matched[2].length < uri_length_max_k\n+            ? matched[2]\n+            : matched[2].slice(-uri_length_max_k);\n+        let prelude = matched[1].substr(0, uri_length_max_k);\n+        if (matched[1].length > uri_length_max_k) {\n+          prelude += '...';\n+        } else if (filename_k.length > 0) {\n+          prelude += ':';\n+        }\n+\n+        uri_display = prelude + filename_k;\n+      }\n+    }\n+    return uri_display;\n+  }\n+\n+  /**\n+   * Make anchored backlink\n+   */\n+  anchorMarkdownify(text, href, comment) {\n+    let text1 = (text || '').trim();\n+    let text1lc = text1.toLowerCase();\n+    let href1 = (href || '').trim();\n+    let href1lc = href1.toLowerCase();\n+    let comment1 = (comment || '').trim();\n+\n+    let retn = '';\n+\n+    if (text1.length < 1 && href1.length < 1) {\n+      // Intetionally blank\n+    } else if (text1lc === href1lc) {\n+      retn = ` <${href1}> `; // This renders correctly in Trello as a sole URL\n+      // NOTE (Ace, 17-Feb-2017): Turns out Trello doesn't support markdown [] only, so we'll construct a nice displayable text vs url:\n+      // text1 = this.uriForDisplay(text1);\n+    } else if (`mailto:${text1lc}` === href1lc) {\n+      retn = ` <${text1}> `; // This renders correctly in Trello as a mailto: url\n+    } else {\n+      const comment1QuotedSpaced = comment1.length > 0 ? ` \"${comment1}\"` : '';\n+      retn = ` [${text1}](<${href1}>${comment1QuotedSpaced}) `;\n+    }\n+\n+    return retn;\n+  }\n+\n+  /**\n+   * Split an email into name and domain\n+   */\n+  splitEmailDomain(email = '') {\n+    const split = email.split('@');\n+    const name = split[0] || '';\n+    const domain = split[1] || '';\n+    return {\n+      name,\n+      domain,\n+    };\n+  }\n+\n+  /**\n+   * Add trailing char if not empty:\n+   */\n+  addChar(front = '', back = '', addChar = ' ') {\n+    if (front.length > 0) {\n+      if (back.length > 0) {\n+        return `${front}${addChar}${back}`;\n+      } else {\n+        return `${front}${addChar}`;\n+      }\n+    } else if (back.length > 0) {\n+      return `${addChar}${back}`;\n+    } else {\n+      return '';\n+    }\n+  }\n+\n+  /**\n+   * Add trailing space if not empty:\n+   */\n+  addSpace(front = '', back = '') {\n+    return this.addChar(front, back, ' ');\n+  }\n+\n+  /**\n+   * Add trailing CRLF if not empty:\n+   */\n+  addCRLF(front = '', back = '') {\n+    return this.addChar(front, back, '\\n');\n+  }\n+\n+  /**\n+   * Markdownify a text block\n+   */\n+  markdownify($emailBody, features, preprocess) {\n+    if (!$emailBody || $emailBody.length < 1) {\n+      g2t_log('markdownify: Require emailBody!');\n+      return;\n+    }\n+    const self = this;\n+\n+    const min_text_length_k = 4;\n+    const max_replace_attempts_k = 10;\n+    const regexp_k = {\n+      begin: '(^|\\\\s+|<|\\\\[|\\\\(|\\\\b|(?=\\\\W+))',\n+      end: '($|\\\\s+|>|\\\\]|\\\\)|\\\\b|(?=\\\\W+))',\n+    };\n+    const unique_placeholder_k = 'g2t_placeholder:'; // Unique placeholder tag\n+\n+    let count = 0;\n+    let replacer_dict = {};\n+\n+    const featureEnabled = (elementTag = '') =>\n+      features === false ? false : features?.[elementTag] !== false;\n+\n+    let $html = $emailBody || ''; // Was: $emailBody.innerHTML || \"\";\n+    // let body = $emailBody.text() || \"\";\n+    let body = $emailBody.html() || '';\n+\n+    // Different encodings handle CRLF differently, so we'll process the main body as html and convert to text:\n+    // Convert paragraph marker to two returns:\n+    let replaced = body.replace(/\\s*[\\n\\r]*<p[^>]*>\\s*[\\n\\r]*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // Convert br marker to one return:\n+    replaced = body.replace(/\\s*[\\n\\r]*<br[^>]*>\\s*[\\n\\r]*/g, '\\n');\n+    body = replaced;\n+\n+    // Remove all other html markers:\n+    replaced = body.replace(/<[^>]*>/g, '');\n+    body = replaced;\n+\n+    // Decode HTML entities:\n+    replaced = self.decodeEntities(body);\n+    body = replaced;\n+\n+    // Replace hr:\n+    replaced = body.replace(/\\s*-{3,}\\s*/g, '---\\n');\n+    body = replaced;\n+\n+    // Convert crlf x 2 (or more) to paragraph markers:\n+    replaced = body.replace(/(\\s*[\\n\\r]\\s*){2,}/g, '<p />\\n');\n+    body = replaced;\n+\n+    let toProcess = {};\n+\n+    /**\n+     * 5 explicit steps in 3 passes:\n+     * (1) Collect tagged items\n+     * (2) Remove duplicates\n+     * (3) Sort force-lowercase by length\n+     * (4) Replace with placeholder\n+     * (5) Replace placeholders with final text\n+     */\n+    const sortAndPlaceholderize = function (tooProcess) {\n+      if (tooProcess) {\n+        g2t_each(\n+          Object.keys(tooProcess).sort(function (a, b) {\n+            // Go by order of largest to smallest\n+            return b.length - a.length;\n+          }),\n+          function (value) {\n+            const replace = tooProcess[value];\n+            const swap = `${unique_placeholder_k}${(count++).toString()}`;\n+            const re = new RegExp(\n+              regexp_k.begin + self.escapeRegExp(value) + regexp_k.end,\n+              'gi'\n+            );\n+            const replaced = body.replace(re, `%${swap}%`); // Replace occurance with placeholder\n+            if (body !== replaced) {\n+              body = replaced;\n+              replacer_dict[swap] = replace;\n+            }\n+          }\n+        );\n+      }\n+    };\n+    const processMarkdown = function (elementTag, replaceText) {\n+      if (elementTag && replaceText && featureEnabled(elementTag)) {\n+        toProcess = preprocess[elementTag] || {};\n+        $(elementTag, $html).each(function (index, value) {\n+          let text = ($(this).text() || '').trim();\n+          if (text && text.length > min_text_length_k) {\n+            let replace = self.replacer(replaceText, { text: text });\n+            toProcess[text.toLowerCase()] = replace; // Intentionally overwrites duplicates\n+          }\n+        });\n+        sortAndPlaceholderize(toProcess);\n+      }\n+    };\n+    /**\n+     * Repeat replace for max attempts or when done, whatever comes first\n+     */\n+    const repeatReplace = function (body, inRegexp, replaceWith) {\n+      let replace1 = '';\n+      for (let iter = max_replace_attempts_k; iter > 0; iter--) {\n+        replace1 = body.replace(inRegexp, replaceWith);\n+        if (body === replace1) {\n+          iter = 0; // All done\n+        } else {\n+          body = replace1;\n+        }\n+      }\n+      return body;\n+    };\n+\n+    // bullet lists:\n+    // ul li -> \" * \"\n+    processMarkdown('ul li', '<p />* %text%<p />');\n+\n+    // numeric lists:\n+    // ol li -> \" 1. \"\n+    processMarkdown('ol li', '<p />1. %text%<p />');\n+\n+    // headers:\n+    // H1 -> #\n+    // H2 -> ##\n+    // H3 -> ###\n+    // H4 -> ####\n+    // H5 -> #####\n+    // H6 -> ######\n+    if (featureEnabled('h')) {\n+      toProcess = preprocess['h'] || {};\n+      $(':header', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let nodeName = $(this).prop('nodeName') || '0';\n+        if (nodeName && text && text.length > min_text_length_k) {\n+          let x = nodeName.substr(-1);\n+          toProcess[text.toLowerCase()] = `\\n${'#'.repeat(x)} ${text}\\n`; // Intentionally overwrites duplicates\n+        }\n+      });\n+      sortAndPlaceholderize(toProcess);\n+    }\n+\n+    replaced = this.replacer(body, replacer_dict); // Replace initial batch of <div> like placeholders\n+    body = replaced;\n+    replacer_dict = {}; // Reset\n+    count = 0; // Reset\n+\n+    // bold: b -> **text**\n+    processMarkdown('b', ' **%text%** ');\n+\n+    // italics: i -> _text_\n+    processMarkdown('i', ' _%text%_ ');\n+\n+    // links:\n+    // a -> [text](html)\n+    if (featureEnabled('a')) {\n+      toProcess = preprocess['a'] || {};\n+      $('a', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let href = ($(this).prop('href') || '').trim(); // Was attr\n+        /*\n+              var uri_display = self.uriForDisplay(href);\n+              var comment = ' \"' + text + ' via ' + uri_display + '\"';\n+              var re = new RegExp(self.escapeRegExp(text), \"i\");\n+              if (uri.match(re)) {\n+                  comment = ' \"Open ' + uri_display + '\"';\n+              }\n+              */\n+        if (href && text && text.length >= min_text_length_k) {\n+          toProcess[text.toLowerCase()] = self.anchorMarkdownify(text, href); // Comment seemed like too much extra text // Intentionally overwrites duplicates\n+        }\n+      });\n+      sortAndPlaceholderize(toProcess);\n+    }\n+\n+    /* DISABLED (Ace, 16-Jan-2017): Images kinda make a mess, until requested lets not markdownify them:\n+      // images:\n+      // img -> ![alt_text](html)\n+      if (featureEnabled('img')) {\n+          $('img', $html).each(function(index, value) {\n+              var text = ($(this).prop(\"alt\") || \"\").trim(); // Was attr\n+              var href = ($(this).prop(\"src\") || \"\").trim(); // Was attr\n+              // var uri_display = self.uriForDisplay(href);\n+              if (href && text && text.length >= min_text_length_k) {\n+                  toProcess[text.toLowerCase()] = self.anchorMarkdownify(text, href); // Comment seemed like too much extra text // Intentionally overwrites duplicates\n+              }\n+          });\n+          sortAndPlaceholderize(toProcess);\n+      }\n+      */\n+\n+    replaced = this.replacer(body, replacer_dict); // Replace second batch of <span> like placeholders\n+    body = replaced;\n+\n+    // Replace bullets following a CRLF:\n+    replaced = body.replace(/\\s*[\\n\\r]+\\s*[·-]+\\s*/g, '<p />* '); // = [\\u00B7\\u2022]\n+    body = replaced;\n+\n+    // Replace remaining bullets with asterisks:\n+    replaced = body.replace(/[·]/g, '*');\n+    body = replaced;\n+\n+    // ORDER MATTERS FOR THIS NEXT SET:\n+    // (1) Replace <space>CRLF<space> with just CR:\n+    replaced = body.replace(/\\s*[\\n\\r]+\\s*/g, '\\n');\n+    body = replaced;\n+\n+    // (2) Replace 2 or more spaces with just one:\n+    replaced = repeatReplace(body, new RegExp('\\\\s{2,}', 'g'), ' ');\n+    body = replaced;\n+\n+    // (3) Replace paragraph markers with CR+CR:\n+    replaced = body.replace(/\\s*<p \\/>\\s*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // (4) Replace 3 or more CRs with just two:\n+    replaced = repeatReplace(body, new RegExp('\\\\n{3,}', 'g'), '\\n\\n');\n+    body = replaced;\n+\n+    // (5) Trim excess at beginning and end:\n+    replaced = body.trim();\n+    body = replaced;\n+\n+    return body;\n+  }\n+\n+  /**\n+   * Determine luminance of a color so we can augment with darker/lighter background\n+   */\n+  luminance(color) {\n+    let bkColorLight = 'lightGray'; // or white\n+    let bkColorDark = 'darkGray'; // 'gray' is even darker\n+    let bkColorReturn = bkColorLight;\n+\n+    let re = new RegExp('rgb\\\\D+(\\\\d+)\\\\D+(\\\\d+)\\\\D+(\\\\d+)');\n+    let matched = color.match(re, 'i');\n+    if (matched && matched.length > 2) {\n+      // 0 is total string:\n+      let r = matched[1];\n+      let g = matched[2];\n+      let b = matched[3];\n+      // var 1 = matched[4]; // if alpha is provided\n+\n+      let luma = 0.2126 * r + 0.7152 * g + 0.0722 * b; // per ITU-R BT.709\n+\n+      if (luma < 40) {\n+        bkColorReturn = bkColorDark;\n+      } else {\n+        bkColorReturn = bkColorLight;\n+      }\n+    } else {\n+      bkColorReturn = bkColorLight; // RegExp failed, assume dark color\n+    }\n+\n+    return 'inherit'; // Use: bkColorReturn if you want to adjust background based on text perceived brightness\n+  }\n+\n+  /**\n+   * HTML bookend a string\n+   */\n+  bookend(bookend, text, style) {\n+    return (\n+      '<' +\n+      bookend +\n+      (style ? ' style=\"' + style + '\"' : '') +\n+      '>' +\n+      (text || '') +\n+      '</' +\n+      bookend +\n+      '>'\n+    );\n+  }\n+\n+  /**\n+   * Get selected text\n+   * http://stackoverflow.com/questions/5379120/get-the-highlighted-selected-text\n+   */\n+  getSelectedText() {\n+    let text = '';\n+    let activeEl = document.activeElement;\n+    let activeElTagName = activeEl ? activeEl.tagName.toLowerCase() : null;\n+    if (\n+      (activeElTagName == 'textarea' || activeElTagName == 'input') &&\n+      /^(?:text|search|password|tel|url)$/i.test(activeEl.type) &&\n+      typeof activeEl.selectionStart == 'number'\n+    ) {\n+      text = activeEl.value\n+        .slice(activeEl.selectionStart, activeEl.selectionEnd)\n+        .trim();\n+    } else if (document.selection) {\n+      text = document.selection.createRange().text.trim();\n+    } else if (document.getSelection) {\n+      text = document.getSelection().toString().trim();\n+    } else if (window.getSelection) {\n+      text = window.getSelection().toString().trim();\n+    }\n+    return text;\n+  }\n+\n+  /**\n+   * Truncate a string\n+   */\n+  truncate(text, max, add) {\n+    let retn = text || '';\n+    const add_k = this.decodeEntities(add || '');\n+    const max_k = max - add_k.length;\n+\n+    if (text && text.length > max_k) {\n+      retn = text.slice(0, max_k) + add_k;\n+    }\n+    return retn;\n+  }\n+\n+  /***\n+   * Middle-truncate a string\n+   */\n+  midTruncate(text, max, add) {\n+    let retn = text || '';\n+    const add_k = this.decodeEntities(add || '');\n+    const max_k = Math.abs((max || 0) - add_k.length);\n+    const mid_k = (max_k + 0.01) / 2;\n+\n+    if (text && text.length > max_k) {\n+      retn = text.slice(0, mid_k + 1) + add_k + text.slice(-mid_k);\n+    }\n+    return retn;\n+  }\n+\n+  /**\n+   * Load settings\n+   */\n+  loadSettings(popup) {\n+    const self = this;\n+    const setID = self.CHROME_SETTINGS_ID;\n+    chrome.storage.sync.get(setID, function (response) {\n+      if (response?.[setID]) {\n+        // NOTE (Ace, 7-Feb-2017): Might need to store these off the app object:\n+        try {\n+          self.popupView.data.settings = JSON.parse(response[setID]);\n+        } catch (err) {\n+          g2t_log(\n+            'loadSettings: JSON parse failed! Error: ' + JSON.stringify(err)\n+          );\n+        }\n+      }\n+      if (popup) {\n+        popup.init_popup();\n+        self.updateData();\n+      }\n+    });\n+  }\n+\n+  /**\n+   * Save settings\n+   */\n+  saveSettings() {\n+    const self = this;\n+    const setID = self.CHROME_SETTINGS_ID;\n+    let settings = Object.assign({}, self.popupView.data.settings);\n+\n+    // Delete large, potentially needing secure, data bits:\n+    settings.description = '';\n+    settings.title = '';\n+    settings.attachments = [];\n+    settings.images = [];\n+    delete settings.description;\n+    delete settings.title;\n+    delete settings.attachments;\n+    delete settings.images;\n+\n+    const settings_string_k = JSON.stringify(settings);\n+\n+    hash = {};\n+    hash[setID] = settings_string_k;\n+\n+    if (self.lastSettingsSave !== settings_string_k) {\n+      try {\n+        chrome.storage.sync.set(hash); // NOTE (Ace, 7-Feb-2017): Might need to store these off the app object\n+        self.lastSettingsSave = settings_string_k;\n+      } catch (error) {\n+        g2t_log(\n+          `saveSettings ERROR: extension context invalidated - failed \"chrome.storage.sync.set\"`\n+        );\n+        self?.popupView?.displayExtensionInvalidReload();\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Encode entities\n+   */\n+  encodeEntities(s) {\n+    let ta = document.createElement('textarea');\n+    ta.value = s;\n+    return ta.innerHTML;\n+    // jQuery way, less safe: return $(\"<textarea />\").text(s).html();\n+  }\n+\n+  /**\n+   * Decode entities\n+   */\n+  decodeEntities(s) {\n+    const self = this;\n+    const dict_k = { '...': '&hellip;', '*': '&bullet;', '-': '&mdash;' };\n+    let re, new_s;\n+    g2t_each(dict_k, function (value, key) {\n+      // value is already available from the callback parameter\n+      re = new RegExp(self.escapeRegExp(key), 'gi');\n+      new_s = s.replace(re, value);\n+      s = new_s;\n+    });\n+    try {\n+      new_s = decodeURIComponent(s);\n+      s = new_s;\n+    } catch (e) {\n+      // Didn't work. Ignore.\n+    }\n+    let ta = document.createElement('textarea');\n+    ta.style.cssText = 'white-space: pre-line;';\n+    ta.innerHTML = s;\n+    return ta.value;\n+    // jQuery way, less safe: return $(\"<textarea />\").html(s).text();\n+  }",
    "path": "chrome_manifest_v3/class_app.js",
    "commit_id": "3bbc7b0b5b5abfda366260c45d6f2cecebf28af3",
    "original_commit_id": "ae0a391b6759338b0ec3c3292da07e458841ab71",
    "user": {
      "login": "acoven",
      "id": 1631902,
      "node_id": "MDQ6VXNlcjE2MzE5MDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1631902?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/acoven",
      "html_url": "https://github.com/acoven",
      "followers_url": "https://api.github.com/users/acoven/followers",
      "following_url": "https://api.github.com/users/acoven/following{/other_user}",
      "gists_url": "https://api.github.com/users/acoven/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/acoven/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/acoven/subscriptions",
      "organizations_url": "https://api.github.com/users/acoven/orgs",
      "repos_url": "https://api.github.com/users/acoven/repos",
      "events_url": "https://api.github.com/users/acoven/events{/privacy}",
      "received_events_url": "https://api.github.com/users/acoven/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "Please create and submit this fix but also rename s to be meaningful line sourceText",
    "created_at": "2025-07-14T04:46:27Z",
    "updated_at": "2025-07-14T04:46:27Z",
    "html_url": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203839325",
    "pull_request_url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203839325"
      },
      "html": {
        "href": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203839325"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203839325/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 1
    },
    "start_line": null,
    "original_start_line": 774,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 795,
    "side": "RIGHT",
    "in_reply_to_id": 2203532568,
    "original_position": 795,
    "position": null,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203839774",
    "pull_request_review_id": 3014760179,
    "id": 2203839774,
    "node_id": "PRRC_kwDOD1hYKM6DW-0e",
    "diff_hunk": "@@ -0,0 +1,848 @@\n+/** Gmail2Trello Application - ES6 Class Version\n+ */\n+\n+var Gmail2Trello = Gmail2Trello || {}; // Namespace initialization - must be var to guarantee correct scope\n+\n+class App {\n+  constructor() {\n+    this.CHROME_SETTINGS_ID = 'g2t_user_settings';\n+    this.UNIQUE_URI_VAR = 'g2t_filename';\n+\n+    this.model = new Gmail2Trello.Model(this);\n+    this.gmailView = new Gmail2Trello.GmailView(this);\n+    this.popupView = new Gmail2Trello.PopupView(this);\n+\n+    this.bindEvents();\n+  }\n+\n+  bindEvents() {\n+    const self = this;\n+\n+    /*** Data's events binding ***/\n+    this.model.event.addListener('onBeforeAuthorize', function () {\n+      self.popupView.bindData(''); // Intentionally blank\n+      self.popupView.showMessage(self, 'Authorizing...');\n+    });\n+\n+    this.model.event.addListener('onAuthorizeFail', function () {\n+      // self.model.isInitialized = false;\n+      self.popupView.showMessage(\n+        self,\n+        'Trello authorization failed <button id=\"showsignout\">Sign out and try again</button>'\n+      );\n+    });\n+\n+    this.model.event.addListener('onAuthorized', function () {\n+      // g2t_log('onAuthorized');\n+      // g2t_log(\"Status: \" + Trello.authorized().toString());\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+    });\n+\n+    this.model.event.addListener('onBeforeLoadTrello', function () {\n+      self.popupView.showMessage(self, 'Loading Trello data...');\n+    });\n+\n+    this.model.event.addListener('onTrelloDataReady', function () {\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+\n+      self.popupView.bindData(self.model);\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloListSuccess', function () {\n+      self.popupView.updateLists();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloCardsSuccess', function () {\n+      self.popupView.updateCards();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloLabelsSuccess', function () {\n+      self.popupView.updateLabels();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloMembersSuccess', function () {\n+      self.popupView.updateMembers();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener(\n+      'onCardSubmitComplete',\n+      function (target, params) {\n+        self.popupView.displaySubmitCompleteForm();\n+        // If card lists or labels have been updated, reload:\n+        const data_k = params?.data || {};\n+        const emailId = data_k?.emailId || 0;\n+        const boardId_k = data_k?.data?.board?.id || 0;\n+        const listId_k = data_k?.data?.list?.id || 0;\n+        const cardId_k = data_k?.data?.card?.id || 0;\n+        const idBoard_k = data_k?.idBoard || 0;\n+        const idList_k = data_k?.idList || 0;\n+        const idCard_k = data_k?.idCard || 0;\n+        const boardId = boardId_k || idBoard_k || 0;\n+        const listId = listId_k || idList_k || 0;\n+        const cardId = cardId_k || idCard_k || 0;\n+        // NOTE (acoven@2020-05-23): Users expect when creating a brand new card,\n+        // we'll remember that new card ID and then keep defaulting to it for\n+        // subsequent updates to that email. That means we'll have to get the return\n+        // value/url from Trello and dissect that, potentially doing this update\n+        // in that routine:\n+        self.model.emailBoardListCardMapUpdate({\n+          emailId,\n+          boardId,\n+          listId,\n+          cardId,\n+        });\n+\n+        if (boardId) {\n+          self.model.loadTrelloLabels(boardId);\n+          self.model.loadTrelloMembers(boardId);\n+        }\n+        if (listId) {\n+          self.model.loadTrelloCards(listId);\n+        }\n+      }\n+    );\n+\n+    this.model.event.addListener('onAPIFailure', function (target, params) {\n+      self.popupView.displayAPIFailedForm(params);\n+    });\n+\n+    /*** PopupView's events binding ***/\n+\n+    this.popupView.event.addListener('onPopupVisible', function () {\n+      if (!self.model.isInitialized) {\n+        self.popupView.showMessage(self, 'Initializing...');\n+        self.popupView.$popupContent.hide();\n+        self.model.init();\n+      } else {\n+        self.popupView.reset();\n+      }\n+\n+      const trelloUser_k = self?.model?.trello?.user || {};\n+      const fullName = trelloUser_k?.fullName || '';\n+\n+      self.gmailView.parsingData = false;\n+      self.model.gmail = self.gmailView.parseData({ fullName });\n+      self.popupView.bindGmailData(self.model.gmail);\n+      self.popupView.event.fire('periodicChecks');\n+    });\n+\n+    this.popupView.event.addListener('periodicChecks', function () {\n+      setTimeout(function () {\n+        self.popupView.periodicChecks();\n+      }, 3000);\n+    });\n+\n+    this.popupView.event.addListener('onBoardChanged', function (target, params) {\n+      let boardId = params.boardId;\n+      if (boardId !== '_' && boardId !== '' && boardId !== null) {\n+        self.model.loadTrelloLists(boardId);\n+        self.model.loadTrelloLabels(boardId);\n+        self.model.loadTrelloMembers(boardId);\n+      }\n+    });\n+\n+    this.popupView.event.addListener('onListChanged', function (target, params) {\n+      let listId = params.listId;\n+      self.model.loadTrelloCards(listId);\n+    });\n+\n+    this.popupView.event.addListener('onSubmit', function () {\n+      self.model.submit();\n+    });\n+\n+    this.popupView.event.addListener('checkTrelloAuthorized', function () {\n+      self.popupView.showMessage(self, 'Authorizing...');\n+      self.model.checkTrelloAuthorized();\n+    });\n+\n+    this.popupView.event.addListener('onRequestDeauthorizeTrello', function () {\n+      g2t_log('onRequestDeauthorizeTrello');\n+      self.model.deauthorizeTrello();\n+      self.popupView.clearBoard();\n+    });\n+\n+    const eventDetectButton = function () {\n+      if (self.gmailView.preDetect()) {\n+        self.popupView.$toolBar = self.gmailView.$toolBar;\n+        self.popupView.confirmPopup();\n+      }\n+    };\n+\n+    this.popupView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    // GMailView's events:\n+\n+    this.gmailView.event.addListener('onDetected', function () {\n+      self.popupView.$toolBar = self.gmailView.$toolBar;\n+      self.popupView.init();\n+    });\n+\n+    this.gmailView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    chrome.runtime.onMessage.addListener(function (\n+      request,\n+      sender,\n+      sendResponse\n+    ) {\n+      if (request?.message === 'g2t_keyboard_shortcut') {\n+        self.popupView.showPopup();\n+      }\n+    });\n+  }\n+\n+  updateData() {\n+    const self = this;\n+\n+    const fullName = self?.model?.trello?.user?.fullName || '';\n+\n+    self.popupView.bindData(self.model);\n+\n+    self.gmailView.parsingData = false;\n+    self.model.gmail = self.gmailView.parseData({ fullName });\n+    self.popupView.bindGmailData(self.model.gmail);\n+  }\n+\n+  initialize() {\n+    const self = this;\n+\n+    this.model.isInitialized = false;\n+\n+    // g2t_log('App:initialize');\n+\n+    this.gmailView.detect();\n+\n+    service = analytics.getService('gmail-2-trello');\n+\n+    // Get a Tracker using your Google Analytics app Tracking ID.\n+    tracker = service.getTracker('G-0QPEDL7YDL'); // Was: UA-8469046-1 -> UA-42442437-4\n+\n+    // Record an \"appView\" each time the user launches your app or goes to a new\n+    // screen within the app.\n+    tracker.sendAppView('PopupView');\n+  }\n+\n+  /**\n+   * Correctly escape RegExp\n+   */\n+  escapeRegExp(str) {\n+    return str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n+  }\n+\n+  /**\n+   * Utility routine to replace variables\n+   */\n+  replacer(text, dict) {\n+    let self = this;\n+\n+    if (!text || text.length < 1) {\n+      // g2t_log('Require text!');\n+      return '';\n+    } else if (!dict || dict.length < 2) {\n+      g2t_log('replacer: Require dictionary!');\n+      return text;\n+    }\n+\n+    let re, new_text;\n+    const replacify = function () {\n+      g2t_each(dict, function (value, key) {\n+        re = new RegExp(`%${self.escapeRegExp(key)}%`, 'gi');\n+        new_text = text.replace(re, value);\n+        text = new_text;\n+      });\n+    };\n+\n+    let runaway_max = 3;\n+    while (text.indexOf('%') !== -1 && runaway_max-- > 0) {\n+      replacify();\n+    }\n+\n+    return text;\n+  }\n+\n+  /**\n+   * Make displayable URI\n+   */\n+  uriForDisplay(uri) {\n+    const uri_display_trigger_length_k = 20;\n+    const uri_length_max_k = 40;\n+    let uri_display = uri || '';\n+    if (uri_display.length > uri_display_trigger_length_k) {\n+      let re = RegExp('^\\\\w+://([\\\\w./_-]+).*?([\\\\w._-]*)$');\n+      let matched = uri_display.match(re);\n+      if (matched && matched.length > 1) {\n+        const filename_k =\n+          matched[2].length < uri_length_max_k\n+            ? matched[2]\n+            : matched[2].slice(-uri_length_max_k);\n+        let prelude = matched[1].substr(0, uri_length_max_k);\n+        if (matched[1].length > uri_length_max_k) {\n+          prelude += '...';\n+        } else if (filename_k.length > 0) {\n+          prelude += ':';\n+        }\n+\n+        uri_display = prelude + filename_k;\n+      }\n+    }\n+    return uri_display;\n+  }\n+\n+  /**\n+   * Make anchored backlink\n+   */\n+  anchorMarkdownify(text, href, comment) {\n+    let text1 = (text || '').trim();\n+    let text1lc = text1.toLowerCase();\n+    let href1 = (href || '').trim();\n+    let href1lc = href1.toLowerCase();\n+    let comment1 = (comment || '').trim();\n+\n+    let retn = '';\n+\n+    if (text1.length < 1 && href1.length < 1) {\n+      // Intetionally blank\n+    } else if (text1lc === href1lc) {\n+      retn = ` <${href1}> `; // This renders correctly in Trello as a sole URL\n+      // NOTE (Ace, 17-Feb-2017): Turns out Trello doesn't support markdown [] only, so we'll construct a nice displayable text vs url:\n+      // text1 = this.uriForDisplay(text1);\n+    } else if (`mailto:${text1lc}` === href1lc) {\n+      retn = ` <${text1}> `; // This renders correctly in Trello as a mailto: url\n+    } else {\n+      const comment1QuotedSpaced = comment1.length > 0 ? ` \"${comment1}\"` : '';\n+      retn = ` [${text1}](<${href1}>${comment1QuotedSpaced}) `;\n+    }\n+\n+    return retn;\n+  }\n+\n+  /**\n+   * Split an email into name and domain\n+   */\n+  splitEmailDomain(email = '') {\n+    const split = email.split('@');\n+    const name = split[0] || '';\n+    const domain = split[1] || '';\n+    return {\n+      name,\n+      domain,\n+    };\n+  }\n+\n+  /**\n+   * Add trailing char if not empty:\n+   */\n+  addChar(front = '', back = '', addChar = ' ') {\n+    if (front.length > 0) {\n+      if (back.length > 0) {\n+        return `${front}${addChar}${back}`;\n+      } else {\n+        return `${front}${addChar}`;\n+      }\n+    } else if (back.length > 0) {\n+      return `${addChar}${back}`;\n+    } else {\n+      return '';\n+    }\n+  }\n+\n+  /**\n+   * Add trailing space if not empty:\n+   */\n+  addSpace(front = '', back = '') {\n+    return this.addChar(front, back, ' ');\n+  }\n+\n+  /**\n+   * Add trailing CRLF if not empty:\n+   */\n+  addCRLF(front = '', back = '') {\n+    return this.addChar(front, back, '\\n');\n+  }\n+\n+  /**\n+   * Markdownify a text block\n+   */\n+  markdownify($emailBody, features, preprocess) {\n+    if (!$emailBody || $emailBody.length < 1) {\n+      g2t_log('markdownify: Require emailBody!');\n+      return;\n+    }\n+    const self = this;\n+\n+    const min_text_length_k = 4;\n+    const max_replace_attempts_k = 10;\n+    const regexp_k = {\n+      begin: '(^|\\\\s+|<|\\\\[|\\\\(|\\\\b|(?=\\\\W+))',\n+      end: '($|\\\\s+|>|\\\\]|\\\\)|\\\\b|(?=\\\\W+))',\n+    };\n+    const unique_placeholder_k = 'g2t_placeholder:'; // Unique placeholder tag\n+\n+    let count = 0;\n+    let replacer_dict = {};\n+\n+    const featureEnabled = (elementTag = '') =>\n+      features === false ? false : features?.[elementTag] !== false;\n+\n+    let $html = $emailBody || ''; // Was: $emailBody.innerHTML || \"\";\n+    // let body = $emailBody.text() || \"\";\n+    let body = $emailBody.html() || '';\n+\n+    // Different encodings handle CRLF differently, so we'll process the main body as html and convert to text:\n+    // Convert paragraph marker to two returns:\n+    let replaced = body.replace(/\\s*[\\n\\r]*<p[^>]*>\\s*[\\n\\r]*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // Convert br marker to one return:\n+    replaced = body.replace(/\\s*[\\n\\r]*<br[^>]*>\\s*[\\n\\r]*/g, '\\n');\n+    body = replaced;\n+\n+    // Remove all other html markers:\n+    replaced = body.replace(/<[^>]*>/g, '');\n+    body = replaced;\n+\n+    // Decode HTML entities:\n+    replaced = self.decodeEntities(body);\n+    body = replaced;\n+\n+    // Replace hr:\n+    replaced = body.replace(/\\s*-{3,}\\s*/g, '---\\n');\n+    body = replaced;\n+\n+    // Convert crlf x 2 (or more) to paragraph markers:\n+    replaced = body.replace(/(\\s*[\\n\\r]\\s*){2,}/g, '<p />\\n');\n+    body = replaced;\n+\n+    let toProcess = {};\n+\n+    /**\n+     * 5 explicit steps in 3 passes:\n+     * (1) Collect tagged items\n+     * (2) Remove duplicates\n+     * (3) Sort force-lowercase by length\n+     * (4) Replace with placeholder\n+     * (5) Replace placeholders with final text\n+     */\n+    const sortAndPlaceholderize = function (tooProcess) {\n+      if (tooProcess) {\n+        g2t_each(\n+          Object.keys(tooProcess).sort(function (a, b) {\n+            // Go by order of largest to smallest\n+            return b.length - a.length;\n+          }),\n+          function (value) {\n+            const replace = tooProcess[value];\n+            const swap = `${unique_placeholder_k}${(count++).toString()}`;\n+            const re = new RegExp(\n+              regexp_k.begin + self.escapeRegExp(value) + regexp_k.end,\n+              'gi'\n+            );\n+            const replaced = body.replace(re, `%${swap}%`); // Replace occurance with placeholder\n+            if (body !== replaced) {\n+              body = replaced;\n+              replacer_dict[swap] = replace;\n+            }\n+          }\n+        );\n+      }\n+    };\n+    const processMarkdown = function (elementTag, replaceText) {\n+      if (elementTag && replaceText && featureEnabled(elementTag)) {\n+        toProcess = preprocess[elementTag] || {};\n+        $(elementTag, $html).each(function (index, value) {\n+          let text = ($(this).text() || '').trim();\n+          if (text && text.length > min_text_length_k) {\n+            let replace = self.replacer(replaceText, { text: text });\n+            toProcess[text.toLowerCase()] = replace; // Intentionally overwrites duplicates\n+          }\n+        });\n+        sortAndPlaceholderize(toProcess);\n+      }\n+    };\n+    /**\n+     * Repeat replace for max attempts or when done, whatever comes first\n+     */\n+    const repeatReplace = function (body, inRegexp, replaceWith) {\n+      let replace1 = '';\n+      for (let iter = max_replace_attempts_k; iter > 0; iter--) {\n+        replace1 = body.replace(inRegexp, replaceWith);\n+        if (body === replace1) {\n+          iter = 0; // All done\n+        } else {\n+          body = replace1;\n+        }\n+      }\n+      return body;\n+    };\n+\n+    // bullet lists:\n+    // ul li -> \" * \"\n+    processMarkdown('ul li', '<p />* %text%<p />');\n+\n+    // numeric lists:\n+    // ol li -> \" 1. \"\n+    processMarkdown('ol li', '<p />1. %text%<p />');\n+\n+    // headers:\n+    // H1 -> #\n+    // H2 -> ##\n+    // H3 -> ###\n+    // H4 -> ####\n+    // H5 -> #####\n+    // H6 -> ######\n+    if (featureEnabled('h')) {\n+      toProcess = preprocess['h'] || {};\n+      $(':header', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let nodeName = $(this).prop('nodeName') || '0';\n+        if (nodeName && text && text.length > min_text_length_k) {\n+          let x = nodeName.substr(-1);\n+          toProcess[text.toLowerCase()] = `\\n${'#'.repeat(x)} ${text}\\n`; // Intentionally overwrites duplicates\n+        }\n+      });\n+      sortAndPlaceholderize(toProcess);\n+    }\n+\n+    replaced = this.replacer(body, replacer_dict); // Replace initial batch of <div> like placeholders\n+    body = replaced;\n+    replacer_dict = {}; // Reset\n+    count = 0; // Reset\n+\n+    // bold: b -> **text**\n+    processMarkdown('b', ' **%text%** ');\n+\n+    // italics: i -> _text_\n+    processMarkdown('i', ' _%text%_ ');\n+\n+    // links:\n+    // a -> [text](html)\n+    if (featureEnabled('a')) {\n+      toProcess = preprocess['a'] || {};\n+      $('a', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let href = ($(this).prop('href') || '').trim(); // Was attr\n+        /*\n+              var uri_display = self.uriForDisplay(href);\n+              var comment = ' \"' + text + ' via ' + uri_display + '\"';\n+              var re = new RegExp(self.escapeRegExp(text), \"i\");\n+              if (uri.match(re)) {\n+                  comment = ' \"Open ' + uri_display + '\"';\n+              }\n+              */\n+        if (href && text && text.length >= min_text_length_k) {\n+          toProcess[text.toLowerCase()] = self.anchorMarkdownify(text, href); // Comment seemed like too much extra text // Intentionally overwrites duplicates\n+        }\n+      });\n+      sortAndPlaceholderize(toProcess);\n+    }\n+\n+    /* DISABLED (Ace, 16-Jan-2017): Images kinda make a mess, until requested lets not markdownify them:\n+      // images:\n+      // img -> ![alt_text](html)\n+      if (featureEnabled('img')) {\n+          $('img', $html).each(function(index, value) {\n+              var text = ($(this).prop(\"alt\") || \"\").trim(); // Was attr\n+              var href = ($(this).prop(\"src\") || \"\").trim(); // Was attr\n+              // var uri_display = self.uriForDisplay(href);\n+              if (href && text && text.length >= min_text_length_k) {\n+                  toProcess[text.toLowerCase()] = self.anchorMarkdownify(text, href); // Comment seemed like too much extra text // Intentionally overwrites duplicates\n+              }\n+          });\n+          sortAndPlaceholderize(toProcess);\n+      }\n+      */\n+\n+    replaced = this.replacer(body, replacer_dict); // Replace second batch of <span> like placeholders\n+    body = replaced;\n+\n+    // Replace bullets following a CRLF:\n+    replaced = body.replace(/\\s*[\\n\\r]+\\s*[·-]+\\s*/g, '<p />* '); // = [\\u00B7\\u2022]\n+    body = replaced;\n+\n+    // Replace remaining bullets with asterisks:\n+    replaced = body.replace(/[·]/g, '*');\n+    body = replaced;\n+\n+    // ORDER MATTERS FOR THIS NEXT SET:\n+    // (1) Replace <space>CRLF<space> with just CR:\n+    replaced = body.replace(/\\s*[\\n\\r]+\\s*/g, '\\n');\n+    body = replaced;\n+\n+    // (2) Replace 2 or more spaces with just one:\n+    replaced = repeatReplace(body, new RegExp('\\\\s{2,}', 'g'), ' ');\n+    body = replaced;\n+\n+    // (3) Replace paragraph markers with CR+CR:\n+    replaced = body.replace(/\\s*<p \\/>\\s*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // (4) Replace 3 or more CRs with just two:\n+    replaced = repeatReplace(body, new RegExp('\\\\n{3,}', 'g'), '\\n\\n');\n+    body = replaced;\n+\n+    // (5) Trim excess at beginning and end:\n+    replaced = body.trim();\n+    body = replaced;\n+\n+    return body;\n+  }\n+\n+  /**\n+   * Determine luminance of a color so we can augment with darker/lighter background\n+   */\n+  luminance(color) {\n+    let bkColorLight = 'lightGray'; // or white\n+    let bkColorDark = 'darkGray'; // 'gray' is even darker\n+    let bkColorReturn = bkColorLight;\n+\n+    let re = new RegExp('rgb\\\\D+(\\\\d+)\\\\D+(\\\\d+)\\\\D+(\\\\d+)');\n+    let matched = color.match(re, 'i');\n+    if (matched && matched.length > 2) {\n+      // 0 is total string:\n+      let r = matched[1];\n+      let g = matched[2];\n+      let b = matched[3];\n+      // var 1 = matched[4]; // if alpha is provided\n+\n+      let luma = 0.2126 * r + 0.7152 * g + 0.0722 * b; // per ITU-R BT.709\n+\n+      if (luma < 40) {\n+        bkColorReturn = bkColorDark;\n+      } else {\n+        bkColorReturn = bkColorLight;\n+      }\n+    } else {\n+      bkColorReturn = bkColorLight; // RegExp failed, assume dark color\n+    }\n+\n+    return 'inherit'; // Use: bkColorReturn if you want to adjust background based on text perceived brightness\n+  }\n+\n+  /**\n+   * HTML bookend a string\n+   */\n+  bookend(bookend, text, style) {\n+    return (\n+      '<' +\n+      bookend +\n+      (style ? ' style=\"' + style + '\"' : '') +\n+      '>' +\n+      (text || '') +\n+      '</' +\n+      bookend +\n+      '>'\n+    );\n+  }\n+\n+  /**\n+   * Get selected text\n+   * http://stackoverflow.com/questions/5379120/get-the-highlighted-selected-text\n+   */\n+  getSelectedText() {\n+    let text = '';\n+    let activeEl = document.activeElement;\n+    let activeElTagName = activeEl ? activeEl.tagName.toLowerCase() : null;\n+    if (\n+      (activeElTagName == 'textarea' || activeElTagName == 'input') &&\n+      /^(?:text|search|password|tel|url)$/i.test(activeEl.type) &&\n+      typeof activeEl.selectionStart == 'number'\n+    ) {\n+      text = activeEl.value\n+        .slice(activeEl.selectionStart, activeEl.selectionEnd)\n+        .trim();\n+    } else if (document.selection) {\n+      text = document.selection.createRange().text.trim();\n+    } else if (document.getSelection) {\n+      text = document.getSelection().toString().trim();\n+    } else if (window.getSelection) {\n+      text = window.getSelection().toString().trim();\n+    }\n+    return text;\n+  }\n+\n+  /**\n+   * Truncate a string\n+   */\n+  truncate(text, max, add) {\n+    let retn = text || '';\n+    const add_k = this.decodeEntities(add || '');\n+    const max_k = max - add_k.length;\n+\n+    if (text && text.length > max_k) {\n+      retn = text.slice(0, max_k) + add_k;\n+    }\n+    return retn;\n+  }\n+\n+  /***\n+   * Middle-truncate a string\n+   */\n+  midTruncate(text, max, add) {\n+    let retn = text || '';\n+    const add_k = this.decodeEntities(add || '');\n+    const max_k = Math.abs((max || 0) - add_k.length);\n+    const mid_k = (max_k + 0.01) / 2;\n+\n+    if (text && text.length > max_k) {\n+      retn = text.slice(0, mid_k + 1) + add_k + text.slice(-mid_k);\n+    }\n+    return retn;\n+  }\n+\n+  /**\n+   * Load settings\n+   */\n+  loadSettings(popup) {\n+    const self = this;\n+    const setID = self.CHROME_SETTINGS_ID;\n+    chrome.storage.sync.get(setID, function (response) {\n+      if (response?.[setID]) {\n+        // NOTE (Ace, 7-Feb-2017): Might need to store these off the app object:\n+        try {\n+          self.popupView.data.settings = JSON.parse(response[setID]);\n+        } catch (err) {\n+          g2t_log(\n+            'loadSettings: JSON parse failed! Error: ' + JSON.stringify(err)\n+          );\n+        }\n+      }\n+      if (popup) {\n+        popup.init_popup();\n+        self.updateData();\n+      }\n+    });\n+  }\n+\n+  /**\n+   * Save settings\n+   */\n+  saveSettings() {\n+    const self = this;\n+    const setID = self.CHROME_SETTINGS_ID;\n+    let settings = Object.assign({}, self.popupView.data.settings);\n+\n+    // Delete large, potentially needing secure, data bits:\n+    settings.description = '';\n+    settings.title = '';\n+    settings.attachments = [];\n+    settings.images = [];\n+    delete settings.description;\n+    delete settings.title;\n+    delete settings.attachments;\n+    delete settings.images;\n+\n+    const settings_string_k = JSON.stringify(settings);\n+\n+    hash = {};\n+    hash[setID] = settings_string_k;\n+\n+    if (self.lastSettingsSave !== settings_string_k) {\n+      try {\n+        chrome.storage.sync.set(hash); // NOTE (Ace, 7-Feb-2017): Might need to store these off the app object\n+        self.lastSettingsSave = settings_string_k;\n+      } catch (error) {\n+        g2t_log(\n+          `saveSettings ERROR: extension context invalidated - failed \"chrome.storage.sync.set\"`\n+        );\n+        self?.popupView?.displayExtensionInvalidReload();\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Encode entities\n+   */\n+  encodeEntities(s) {\n+    let ta = document.createElement('textarea');\n+    ta.value = s;\n+    return ta.innerHTML;\n+    // jQuery way, less safe: return $(\"<textarea />\").text(s).html();\n+  }\n+\n+  /**\n+   * Decode entities\n+   */\n+  decodeEntities(s) {\n+    const self = this;\n+    const dict_k = { '...': '&hellip;', '*': '&bullet;', '-': '&mdash;' };\n+    let re, new_s;\n+    g2t_each(dict_k, function (value, key) {\n+      // value is already available from the callback parameter\n+      re = new RegExp(self.escapeRegExp(key), 'gi');\n+      new_s = s.replace(re, value);\n+      s = new_s;\n+    });\n+    try {\n+      new_s = decodeURIComponent(s);\n+      s = new_s;\n+    } catch (e) {\n+      // Didn't work. Ignore.\n+    }\n+    let ta = document.createElement('textarea');\n+    ta.style.cssText = 'white-space: pre-line;';\n+    ta.innerHTML = s;\n+    return ta.value;\n+    // jQuery way, less safe: return $(\"<textarea />\").html(s).text();\n+  }",
    "path": "chrome_manifest_v3/class_app.js",
    "commit_id": "3bbc7b0b5b5abfda366260c45d6f2cecebf28af3",
    "original_commit_id": "ae0a391b6759338b0ec3c3292da07e458841ab71",
    "user": {
      "login": "coderabbitai[bot]",
      "id": 136622811,
      "node_id": "BOT_kgDOCCSy2w",
      "avatar_url": "https://avatars.githubusercontent.com/in/347564?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/coderabbitai%5Bbot%5D",
      "html_url": "https://github.com/apps/coderabbitai",
      "followers_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "@acoven Now whut? I am the Batman.\n\n\n\n## Task: Fix decodeEntities method issues\n- Rename parameter 's' to 'sourceText' for clarity\n- Avoid parameter reassignment by using result variable\n- Change 'let ta' to 'const ta'\n\n<!-- <requirement>\n[requirement fix_decode_entities_1/1]\nFix the decodeEntities method by renaming the parameter, avoiding parameter reassignment, and using const for ta variable.\n\n[propose_code_change]\n\nFile: `chrome_manifest_v3/class_app.js`\n\n```diff\n-  decodeEntities(s) {\n+  decodeEntities(sourceText) {\n     const self = this;\n     const dict_k = { '...': '&hellip;', '*': '&bullet;', '-': '&mdash;' };\n-    let re, new_s;\n+    let re, new_s, result = sourceText;\n     g2t_each(dict_k, function (value, key) {\n       // value is already available from the callback parameter\n       re = new RegExp(self.escapeRegExp(key), 'gi');\n-      new_s = s.replace(re, value);\n-      s = new_s;\n+      new_s = result.replace(re, value);\n+      result = new_s;\n     });\n     try {\n-      new_s = decodeURIComponent(s);\n-      s = new_s;\n+      new_s = decodeURIComponent(result);\n+      result = new_s;\n     } catch (e) {\n       // Didn't work. Ignore.\n     }\n-    let ta = document.createElement('textarea');\n+    const ta = document.createElement('textarea');\n     ta.style.cssText = 'white-space: pre-line;';\n-    ta.innerHTML = s;\n+    ta.innerHTML = result;\n     return ta.value;\n     // jQuery way, less safe: return $(\"<textarea />\").html(s).text();\n   }\n```\n</requirement> -->\n\nNext?\n\n---\n\n<details>\n<summary>🧠 Learnings used</summary>\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#58\nFile: chrome_manifest_v3/views/popupView.js:1-1\nTimestamp: 2025-07-12T18:10:21.641Z\nLearning: In the gmail-2-trello project, when eliminating `let self = this` or `const self = this` patterns in functions that contain callbacks, the maintainer prefers converting callback functions to arrow functions to preserve `this` context, allowing direct use of `this` throughout the function instead of the `self` alias.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#58\nFile: chrome_manifest_v3/views/popupView.js:384-384\nTimestamp: 2025-07-12T14:58:20.670Z\nLearning: In the gmail-2-trello project, when analyzing `let self = this` patterns, the maintainer prefers to change `let` to `const` when keeping the self alias, and remove the alias entirely where it's not needed for scope preservation in nested callbacks.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#54\nFile: chrome_manifest_v3/service_worker.js:177-179\nTimestamp: 2025-07-10T05:06:47.579Z\nLearning: In the gmail-2-trello project, the maintainer prefers using `let` instead of `const` for object declarations when the object will be mutated (even if the reference doesn't change), for semantic clarity about mutation intent.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#57\nFile: chrome_manifest_v3/model.js:436-445\nTimestamp: 2025-07-11T16:58:40.928Z\nLearning: In the gmail-2-trello project, the maintainer prefers using `let` instead of `const` for array declarations when the array contents will be mutated (even if the reference doesn't change), for semantic clarity about mutation intent.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#57\nFile: docs/CHANGES.md:1-2\nTimestamp: 2025-07-11T16:23:16.422Z\nLearning: In the gmail-2-trello project, the docs/CHANGES.md file is copy-pasted to the Google Chrome extension dashboard, so it uses a custom changelog format with \"=== version@date ===\" entries rather than standard markdown formatting. Do not suggest adding markdown headers or other standard markdown formatting to this file.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#0\nFile: :0-0\nTimestamp: 2025-07-12T20:10:59.237Z\nLearning: In the gmail-2-trello project, when modernizing the `validHash` function replacement, the maintainer clarified that the original function rejected numbers (including 0) because they lack a `.length` property, and asked for options to either maintain this strict behavior or expand acceptance to include numbers.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#61\nFile: chrome_manifest_v3/class_app.js:685-686\nTimestamp: 2025-07-14T04:42:32.307Z\nLearning: In the gmail-2-trello project, when the maintainer asks to \"actually fix it\" after showing code examples, they want the code changes to be implemented using the plan_code_changes tag rather than just displaying the corrected code.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#51\nFile: package.json:3-3\nTimestamp: 2025-07-01T22:23:51.968Z\nLearning: In the gmail-2-trello project, the maintainer uses a custom four-segment versioning scheme (e.g., \"2.9.0.002\") instead of standard SemVer and wants to keep this format unchanged. Do not suggest SemVer compliance for version numbers in this project.\n```\n\n</details>\n\n\n\n---\n\n⏳ Preparing changes...\n\n\n<!-- <agentComponentType>chat-answer</agentComponentType> -->\n\n<!-- <rawResChunk><nextState>plan-edits</nextState></rawResChunk> -->\n\n<!-- <rawResChunk><answer>@acoven Now whut? I am the Batman.\n\n\n\n## Task: Fix decodeEntities method issues\n- Rename parameter 's' to 'sourceText' for clarity\n- Avoid parameter reassignment by using result variable\n- Change 'let ta' to 'const ta'\n\n&lt;!-- <requirement>\n[requirement fix_decode_entities_1/1]\nFix the decodeEntities method by renaming the parameter, avoiding parameter reassignment, and using const for ta variable.\n\n[propose_code_change]\n\nFile: `chrome_manifest_v3/class_app.js`\n\n```diff\n-  decodeEntities(s) {\n+  decodeEntities(sourceText) {\n     const self = this;\n     const dict_k = { '...': '&hellip;', '*': '&bullet;', '-': '&mdash;' };\n-    let re, new_s;\n+    let re, new_s, result = sourceText;\n     g2t_each(dict_k, function (value, key) {\n       // value is already available from the callback parameter\n       re = new RegExp(self.escapeRegExp(key), 'gi');\n-      new_s = s.replace(re, value);\n-      s = new_s;\n+      new_s = result.replace(re, value);\n+      result = new_s;\n     });\n     try {\n-      new_s = decodeURIComponent(s);\n-      s = new_s;\n+      new_s = decodeURIComponent(result);\n+      result = new_s;\n     } catch (e) {\n       // Didn't work. Ignore.\n     }\n-    let ta = document.createElement('textarea');\n+    const ta = document.createElement('textarea');\n     ta.style.cssText = 'white-space: pre-line;';\n-    ta.innerHTML = s;\n+    ta.innerHTML = result;\n     return ta.value;\n     // jQuery way, less safe: return $(\"<textarea />\").html(s).text();\n   }\n```\n</requirement> --&gt;\n\nNext?\n\n---\n\n<details>\n<summary>🧠 Learnings used</summary>\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#58\nFile: chrome_manifest_v3/views/popupView.js:1-1\nTimestamp: 2025-07-12T18:10:21.641Z\nLearning: In the gmail-2-trello project, when eliminating `let self = this` or `const self = this` patterns in functions that contain callbacks, the maintainer prefers converting callback functions to arrow functions to preserve `this` context, allowing direct use of `this` throughout the function instead of the `self` alias.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#58\nFile: chrome_manifest_v3/views/popupView.js:384-384\nTimestamp: 2025-07-12T14:58:20.670Z\nLearning: In the gmail-2-trello project, when analyzing `let self = this` patterns, the maintainer prefers to change `let` to `const` when keeping the self alias, and remove the alias entirely where it's not needed for scope preservation in nested callbacks.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#54\nFile: chrome_manifest_v3/service_worker.js:177-179\nTimestamp: 2025-07-10T05:06:47.579Z\nLearning: In the gmail-2-trello project, the maintainer prefers using `let` instead of `const` for object declarations when the object will be mutated (even if the reference doesn't change), for semantic clarity about mutation intent.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#57\nFile: chrome_manifest_v3/model.js:436-445\nTimestamp: 2025-07-11T16:58:40.928Z\nLearning: In the gmail-2-trello project, the maintainer prefers using `let` instead of `const` for array declarations when the array contents will be mutated (even if the reference doesn't change), for semantic clarity about mutation intent.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#57\nFile: docs/CHANGES.md:1-2\nTimestamp: 2025-07-11T16:23:16.422Z\nLearning: In the gmail-2-trello project, the docs/CHANGES.md file is copy-pasted to the Google Chrome extension dashboard, so it uses a custom changelog format with \"=== version@date ===\" entries rather than standard markdown formatting. Do not suggest adding markdown headers or other standard markdown formatting to this file.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#0\nFile: :0-0\nTimestamp: 2025-07-12T20:10:59.237Z\nLearning: In the gmail-2-trello project, when modernizing the `validHash` function replacement, the maintainer clarified that the original function rejected numbers (including 0) because they lack a `.length` property, and asked for options to either maintain this strict behavior or expand acceptance to include numbers.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#61\nFile: chrome_manifest_v3/class_app.js:685-686\nTimestamp: 2025-07-14T04:42:32.307Z\nLearning: In the gmail-2-trello project, when the maintainer asks to \"actually fix it\" after showing code examples, they want the code changes to be implemented using the plan_code_changes tag rather than just displaying the corrected code.\n```\n\n---\n\n```\nLearnt from: acoven\nPR: appliedmedia/gmail-2-trello#51\nFile: package.json:3-3\nTimestamp: 2025-07-01T22:23:51.968Z\nLearning: In the gmail-2-trello project, the maintainer uses a custom four-segment versioning scheme (e.g., \"2.9.0.002\") instead of standard SemVer and wants to keep this format unchanged. Do not suggest SemVer compliance for version numbers in this project.\n```\n\n</details>\n\n\n\n---\n\n⏳ Preparing changes...\n\n</answer></rawResChunk> -->\n\n<!-- This is an auto-generated reply by CodeRabbit -->",
    "created_at": "2025-07-14T04:47:01Z",
    "updated_at": "2025-07-14T04:47:02Z",
    "html_url": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203839774",
    "pull_request_url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203839774"
      },
      "html": {
        "href": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203839774"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203839774/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 774,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 795,
    "side": "RIGHT",
    "in_reply_to_id": 2203532568,
    "original_position": 795,
    "position": null,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203840764",
    "pull_request_review_id": 3014761616,
    "id": 2203840764,
    "node_id": "PRRC_kwDOD1hYKM6DW_D8",
    "diff_hunk": "@@ -0,0 +1,848 @@\n+/** Gmail2Trello Application - ES6 Class Version\n+ */\n+\n+var Gmail2Trello = Gmail2Trello || {}; // Namespace initialization - must be var to guarantee correct scope\n+\n+class App {\n+  constructor() {\n+    this.CHROME_SETTINGS_ID = 'g2t_user_settings';\n+    this.UNIQUE_URI_VAR = 'g2t_filename';\n+\n+    this.model = new Gmail2Trello.Model(this);\n+    this.gmailView = new Gmail2Trello.GmailView(this);\n+    this.popupView = new Gmail2Trello.PopupView(this);\n+\n+    this.bindEvents();\n+  }\n+\n+  bindEvents() {\n+    const self = this;\n+\n+    /*** Data's events binding ***/\n+    this.model.event.addListener('onBeforeAuthorize', function () {\n+      self.popupView.bindData(''); // Intentionally blank\n+      self.popupView.showMessage(self, 'Authorizing...');\n+    });\n+\n+    this.model.event.addListener('onAuthorizeFail', function () {\n+      // self.model.isInitialized = false;\n+      self.popupView.showMessage(\n+        self,\n+        'Trello authorization failed <button id=\"showsignout\">Sign out and try again</button>'\n+      );\n+    });\n+\n+    this.model.event.addListener('onAuthorized', function () {\n+      // g2t_log('onAuthorized');\n+      // g2t_log(\"Status: \" + Trello.authorized().toString());\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+    });\n+\n+    this.model.event.addListener('onBeforeLoadTrello', function () {\n+      self.popupView.showMessage(self, 'Loading Trello data...');\n+    });\n+\n+    this.model.event.addListener('onTrelloDataReady', function () {\n+      self.popupView.$popupContent.show();\n+      self.popupView.hideMessage();\n+\n+      self.popupView.bindData(self.model);\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloListSuccess', function () {\n+      self.popupView.updateLists();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloCardsSuccess', function () {\n+      self.popupView.updateCards();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloLabelsSuccess', function () {\n+      self.popupView.updateLabels();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener('onLoadTrelloMembersSuccess', function () {\n+      self.popupView.updateMembers();\n+      self.popupView.validateData();\n+    });\n+\n+    this.model.event.addListener(\n+      'onCardSubmitComplete',\n+      function (target, params) {\n+        self.popupView.displaySubmitCompleteForm();\n+        // If card lists or labels have been updated, reload:\n+        const data_k = params?.data || {};\n+        const emailId = data_k?.emailId || 0;\n+        const boardId_k = data_k?.data?.board?.id || 0;\n+        const listId_k = data_k?.data?.list?.id || 0;\n+        const cardId_k = data_k?.data?.card?.id || 0;\n+        const idBoard_k = data_k?.idBoard || 0;\n+        const idList_k = data_k?.idList || 0;\n+        const idCard_k = data_k?.idCard || 0;\n+        const boardId = boardId_k || idBoard_k || 0;\n+        const listId = listId_k || idList_k || 0;\n+        const cardId = cardId_k || idCard_k || 0;\n+        // NOTE (acoven@2020-05-23): Users expect when creating a brand new card,\n+        // we'll remember that new card ID and then keep defaulting to it for\n+        // subsequent updates to that email. That means we'll have to get the return\n+        // value/url from Trello and dissect that, potentially doing this update\n+        // in that routine:\n+        self.model.emailBoardListCardMapUpdate({\n+          emailId,\n+          boardId,\n+          listId,\n+          cardId,\n+        });\n+\n+        if (boardId) {\n+          self.model.loadTrelloLabels(boardId);\n+          self.model.loadTrelloMembers(boardId);\n+        }\n+        if (listId) {\n+          self.model.loadTrelloCards(listId);\n+        }\n+      }\n+    );\n+\n+    this.model.event.addListener('onAPIFailure', function (target, params) {\n+      self.popupView.displayAPIFailedForm(params);\n+    });\n+\n+    /*** PopupView's events binding ***/\n+\n+    this.popupView.event.addListener('onPopupVisible', function () {\n+      if (!self.model.isInitialized) {\n+        self.popupView.showMessage(self, 'Initializing...');\n+        self.popupView.$popupContent.hide();\n+        self.model.init();\n+      } else {\n+        self.popupView.reset();\n+      }\n+\n+      const trelloUser_k = self?.model?.trello?.user || {};\n+      const fullName = trelloUser_k?.fullName || '';\n+\n+      self.gmailView.parsingData = false;\n+      self.model.gmail = self.gmailView.parseData({ fullName });\n+      self.popupView.bindGmailData(self.model.gmail);\n+      self.popupView.event.fire('periodicChecks');\n+    });\n+\n+    this.popupView.event.addListener('periodicChecks', function () {\n+      setTimeout(function () {\n+        self.popupView.periodicChecks();\n+      }, 3000);\n+    });\n+\n+    this.popupView.event.addListener('onBoardChanged', function (target, params) {\n+      let boardId = params.boardId;\n+      if (boardId !== '_' && boardId !== '' && boardId !== null) {\n+        self.model.loadTrelloLists(boardId);\n+        self.model.loadTrelloLabels(boardId);\n+        self.model.loadTrelloMembers(boardId);\n+      }\n+    });\n+\n+    this.popupView.event.addListener('onListChanged', function (target, params) {\n+      let listId = params.listId;\n+      self.model.loadTrelloCards(listId);\n+    });\n+\n+    this.popupView.event.addListener('onSubmit', function () {\n+      self.model.submit();\n+    });\n+\n+    this.popupView.event.addListener('checkTrelloAuthorized', function () {\n+      self.popupView.showMessage(self, 'Authorizing...');\n+      self.model.checkTrelloAuthorized();\n+    });\n+\n+    this.popupView.event.addListener('onRequestDeauthorizeTrello', function () {\n+      g2t_log('onRequestDeauthorizeTrello');\n+      self.model.deauthorizeTrello();\n+      self.popupView.clearBoard();\n+    });\n+\n+    const eventDetectButton = function () {\n+      if (self.gmailView.preDetect()) {\n+        self.popupView.$toolBar = self.gmailView.$toolBar;\n+        self.popupView.confirmPopup();\n+      }\n+    };\n+\n+    this.popupView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    // GMailView's events:\n+\n+    this.gmailView.event.addListener('onDetected', function () {\n+      self.popupView.$toolBar = self.gmailView.$toolBar;\n+      self.popupView.init();\n+    });\n+\n+    this.gmailView.event.addListener('detectButton', function () {\n+      eventDetectButton();\n+    });\n+\n+    chrome.runtime.onMessage.addListener(function (\n+      request,\n+      sender,\n+      sendResponse\n+    ) {\n+      if (request?.message === 'g2t_keyboard_shortcut') {\n+        self.popupView.showPopup();\n+      }\n+    });\n+  }\n+\n+  updateData() {\n+    const self = this;\n+\n+    const fullName = self?.model?.trello?.user?.fullName || '';\n+\n+    self.popupView.bindData(self.model);\n+\n+    self.gmailView.parsingData = false;\n+    self.model.gmail = self.gmailView.parseData({ fullName });\n+    self.popupView.bindGmailData(self.model.gmail);\n+  }\n+\n+  initialize() {\n+    const self = this;\n+\n+    this.model.isInitialized = false;\n+\n+    // g2t_log('App:initialize');\n+\n+    this.gmailView.detect();\n+\n+    service = analytics.getService('gmail-2-trello');\n+\n+    // Get a Tracker using your Google Analytics app Tracking ID.\n+    tracker = service.getTracker('G-0QPEDL7YDL'); // Was: UA-8469046-1 -> UA-42442437-4\n+\n+    // Record an \"appView\" each time the user launches your app or goes to a new\n+    // screen within the app.\n+    tracker.sendAppView('PopupView');\n+  }\n+\n+  /**\n+   * Correctly escape RegExp\n+   */\n+  escapeRegExp(str) {\n+    return str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n+  }\n+\n+  /**\n+   * Utility routine to replace variables\n+   */\n+  replacer(text, dict) {\n+    let self = this;\n+\n+    if (!text || text.length < 1) {\n+      // g2t_log('Require text!');\n+      return '';\n+    } else if (!dict || dict.length < 2) {\n+      g2t_log('replacer: Require dictionary!');\n+      return text;\n+    }\n+\n+    let re, new_text;\n+    const replacify = function () {\n+      g2t_each(dict, function (value, key) {\n+        re = new RegExp(`%${self.escapeRegExp(key)}%`, 'gi');\n+        new_text = text.replace(re, value);\n+        text = new_text;\n+      });\n+    };\n+\n+    let runaway_max = 3;\n+    while (text.indexOf('%') !== -1 && runaway_max-- > 0) {\n+      replacify();\n+    }\n+\n+    return text;\n+  }\n+\n+  /**\n+   * Make displayable URI\n+   */\n+  uriForDisplay(uri) {\n+    const uri_display_trigger_length_k = 20;\n+    const uri_length_max_k = 40;\n+    let uri_display = uri || '';\n+    if (uri_display.length > uri_display_trigger_length_k) {\n+      let re = RegExp('^\\\\w+://([\\\\w./_-]+).*?([\\\\w._-]*)$');\n+      let matched = uri_display.match(re);\n+      if (matched && matched.length > 1) {\n+        const filename_k =\n+          matched[2].length < uri_length_max_k\n+            ? matched[2]\n+            : matched[2].slice(-uri_length_max_k);\n+        let prelude = matched[1].substr(0, uri_length_max_k);\n+        if (matched[1].length > uri_length_max_k) {\n+          prelude += '...';\n+        } else if (filename_k.length > 0) {\n+          prelude += ':';\n+        }\n+\n+        uri_display = prelude + filename_k;\n+      }\n+    }\n+    return uri_display;\n+  }\n+\n+  /**\n+   * Make anchored backlink\n+   */\n+  anchorMarkdownify(text, href, comment) {\n+    let text1 = (text || '').trim();\n+    let text1lc = text1.toLowerCase();\n+    let href1 = (href || '').trim();\n+    let href1lc = href1.toLowerCase();\n+    let comment1 = (comment || '').trim();\n+\n+    let retn = '';\n+\n+    if (text1.length < 1 && href1.length < 1) {\n+      // Intetionally blank\n+    } else if (text1lc === href1lc) {\n+      retn = ` <${href1}> `; // This renders correctly in Trello as a sole URL\n+      // NOTE (Ace, 17-Feb-2017): Turns out Trello doesn't support markdown [] only, so we'll construct a nice displayable text vs url:\n+      // text1 = this.uriForDisplay(text1);\n+    } else if (`mailto:${text1lc}` === href1lc) {\n+      retn = ` <${text1}> `; // This renders correctly in Trello as a mailto: url\n+    } else {\n+      const comment1QuotedSpaced = comment1.length > 0 ? ` \"${comment1}\"` : '';\n+      retn = ` [${text1}](<${href1}>${comment1QuotedSpaced}) `;\n+    }\n+\n+    return retn;\n+  }\n+\n+  /**\n+   * Split an email into name and domain\n+   */\n+  splitEmailDomain(email = '') {\n+    const split = email.split('@');\n+    const name = split[0] || '';\n+    const domain = split[1] || '';\n+    return {\n+      name,\n+      domain,\n+    };\n+  }\n+\n+  /**\n+   * Add trailing char if not empty:\n+   */\n+  addChar(front = '', back = '', addChar = ' ') {\n+    if (front.length > 0) {\n+      if (back.length > 0) {\n+        return `${front}${addChar}${back}`;\n+      } else {\n+        return `${front}${addChar}`;\n+      }\n+    } else if (back.length > 0) {\n+      return `${addChar}${back}`;\n+    } else {\n+      return '';\n+    }\n+  }\n+\n+  /**\n+   * Add trailing space if not empty:\n+   */\n+  addSpace(front = '', back = '') {\n+    return this.addChar(front, back, ' ');\n+  }\n+\n+  /**\n+   * Add trailing CRLF if not empty:\n+   */\n+  addCRLF(front = '', back = '') {\n+    return this.addChar(front, back, '\\n');\n+  }\n+\n+  /**\n+   * Markdownify a text block\n+   */\n+  markdownify($emailBody, features, preprocess) {\n+    if (!$emailBody || $emailBody.length < 1) {\n+      g2t_log('markdownify: Require emailBody!');\n+      return;\n+    }\n+    const self = this;\n+\n+    const min_text_length_k = 4;\n+    const max_replace_attempts_k = 10;\n+    const regexp_k = {\n+      begin: '(^|\\\\s+|<|\\\\[|\\\\(|\\\\b|(?=\\\\W+))',\n+      end: '($|\\\\s+|>|\\\\]|\\\\)|\\\\b|(?=\\\\W+))',\n+    };\n+    const unique_placeholder_k = 'g2t_placeholder:'; // Unique placeholder tag\n+\n+    let count = 0;\n+    let replacer_dict = {};\n+\n+    const featureEnabled = (elementTag = '') =>\n+      features === false ? false : features?.[elementTag] !== false;\n+\n+    let $html = $emailBody || ''; // Was: $emailBody.innerHTML || \"\";\n+    // let body = $emailBody.text() || \"\";\n+    let body = $emailBody.html() || '';\n+\n+    // Different encodings handle CRLF differently, so we'll process the main body as html and convert to text:\n+    // Convert paragraph marker to two returns:\n+    let replaced = body.replace(/\\s*[\\n\\r]*<p[^>]*>\\s*[\\n\\r]*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // Convert br marker to one return:\n+    replaced = body.replace(/\\s*[\\n\\r]*<br[^>]*>\\s*[\\n\\r]*/g, '\\n');\n+    body = replaced;\n+\n+    // Remove all other html markers:\n+    replaced = body.replace(/<[^>]*>/g, '');\n+    body = replaced;\n+\n+    // Decode HTML entities:\n+    replaced = self.decodeEntities(body);\n+    body = replaced;\n+\n+    // Replace hr:\n+    replaced = body.replace(/\\s*-{3,}\\s*/g, '---\\n');\n+    body = replaced;\n+\n+    // Convert crlf x 2 (or more) to paragraph markers:\n+    replaced = body.replace(/(\\s*[\\n\\r]\\s*){2,}/g, '<p />\\n');\n+    body = replaced;\n+\n+    let toProcess = {};\n+\n+    /**\n+     * 5 explicit steps in 3 passes:\n+     * (1) Collect tagged items\n+     * (2) Remove duplicates\n+     * (3) Sort force-lowercase by length\n+     * (4) Replace with placeholder\n+     * (5) Replace placeholders with final text\n+     */\n+    const sortAndPlaceholderize = function (tooProcess) {\n+      if (tooProcess) {\n+        g2t_each(\n+          Object.keys(tooProcess).sort(function (a, b) {\n+            // Go by order of largest to smallest\n+            return b.length - a.length;\n+          }),\n+          function (value) {\n+            const replace = tooProcess[value];\n+            const swap = `${unique_placeholder_k}${(count++).toString()}`;\n+            const re = new RegExp(\n+              regexp_k.begin + self.escapeRegExp(value) + regexp_k.end,\n+              'gi'\n+            );\n+            const replaced = body.replace(re, `%${swap}%`); // Replace occurance with placeholder\n+            if (body !== replaced) {\n+              body = replaced;\n+              replacer_dict[swap] = replace;\n+            }\n+          }\n+        );\n+      }\n+    };\n+    const processMarkdown = function (elementTag, replaceText) {\n+      if (elementTag && replaceText && featureEnabled(elementTag)) {\n+        toProcess = preprocess[elementTag] || {};\n+        $(elementTag, $html).each(function (index, value) {\n+          let text = ($(this).text() || '').trim();\n+          if (text && text.length > min_text_length_k) {\n+            let replace = self.replacer(replaceText, { text: text });\n+            toProcess[text.toLowerCase()] = replace; // Intentionally overwrites duplicates\n+          }\n+        });\n+        sortAndPlaceholderize(toProcess);\n+      }\n+    };\n+    /**\n+     * Repeat replace for max attempts or when done, whatever comes first\n+     */\n+    const repeatReplace = function (body, inRegexp, replaceWith) {\n+      let replace1 = '';\n+      for (let iter = max_replace_attempts_k; iter > 0; iter--) {\n+        replace1 = body.replace(inRegexp, replaceWith);\n+        if (body === replace1) {\n+          iter = 0; // All done\n+        } else {\n+          body = replace1;\n+        }\n+      }\n+      return body;\n+    };\n+\n+    // bullet lists:\n+    // ul li -> \" * \"\n+    processMarkdown('ul li', '<p />* %text%<p />');\n+\n+    // numeric lists:\n+    // ol li -> \" 1. \"\n+    processMarkdown('ol li', '<p />1. %text%<p />');\n+\n+    // headers:\n+    // H1 -> #\n+    // H2 -> ##\n+    // H3 -> ###\n+    // H4 -> ####\n+    // H5 -> #####\n+    // H6 -> ######\n+    if (featureEnabled('h')) {\n+      toProcess = preprocess['h'] || {};\n+      $(':header', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let nodeName = $(this).prop('nodeName') || '0';\n+        if (nodeName && text && text.length > min_text_length_k) {\n+          let x = nodeName.substr(-1);\n+          toProcess[text.toLowerCase()] = `\\n${'#'.repeat(x)} ${text}\\n`; // Intentionally overwrites duplicates\n+        }\n+      });\n+      sortAndPlaceholderize(toProcess);\n+    }\n+\n+    replaced = this.replacer(body, replacer_dict); // Replace initial batch of <div> like placeholders\n+    body = replaced;\n+    replacer_dict = {}; // Reset\n+    count = 0; // Reset\n+\n+    // bold: b -> **text**\n+    processMarkdown('b', ' **%text%** ');\n+\n+    // italics: i -> _text_\n+    processMarkdown('i', ' _%text%_ ');\n+\n+    // links:\n+    // a -> [text](html)\n+    if (featureEnabled('a')) {\n+      toProcess = preprocess['a'] || {};\n+      $('a', $html).each(function (index, value) {\n+        let text = ($(this).text() || '').trim();\n+        let href = ($(this).prop('href') || '').trim(); // Was attr\n+        /*\n+              var uri_display = self.uriForDisplay(href);\n+              var comment = ' \"' + text + ' via ' + uri_display + '\"';\n+              var re = new RegExp(self.escapeRegExp(text), \"i\");\n+              if (uri.match(re)) {\n+                  comment = ' \"Open ' + uri_display + '\"';\n+              }\n+              */\n+        if (href && text && text.length >= min_text_length_k) {\n+          toProcess[text.toLowerCase()] = self.anchorMarkdownify(text, href); // Comment seemed like too much extra text // Intentionally overwrites duplicates\n+        }\n+      });\n+      sortAndPlaceholderize(toProcess);\n+    }\n+\n+    /* DISABLED (Ace, 16-Jan-2017): Images kinda make a mess, until requested lets not markdownify them:\n+      // images:\n+      // img -> ![alt_text](html)\n+      if (featureEnabled('img')) {\n+          $('img', $html).each(function(index, value) {\n+              var text = ($(this).prop(\"alt\") || \"\").trim(); // Was attr\n+              var href = ($(this).prop(\"src\") || \"\").trim(); // Was attr\n+              // var uri_display = self.uriForDisplay(href);\n+              if (href && text && text.length >= min_text_length_k) {\n+                  toProcess[text.toLowerCase()] = self.anchorMarkdownify(text, href); // Comment seemed like too much extra text // Intentionally overwrites duplicates\n+              }\n+          });\n+          sortAndPlaceholderize(toProcess);\n+      }\n+      */\n+\n+    replaced = this.replacer(body, replacer_dict); // Replace second batch of <span> like placeholders\n+    body = replaced;\n+\n+    // Replace bullets following a CRLF:\n+    replaced = body.replace(/\\s*[\\n\\r]+\\s*[·-]+\\s*/g, '<p />* '); // = [\\u00B7\\u2022]\n+    body = replaced;\n+\n+    // Replace remaining bullets with asterisks:\n+    replaced = body.replace(/[·]/g, '*');\n+    body = replaced;\n+\n+    // ORDER MATTERS FOR THIS NEXT SET:\n+    // (1) Replace <space>CRLF<space> with just CR:\n+    replaced = body.replace(/\\s*[\\n\\r]+\\s*/g, '\\n');\n+    body = replaced;\n+\n+    // (2) Replace 2 or more spaces with just one:\n+    replaced = repeatReplace(body, new RegExp('\\\\s{2,}', 'g'), ' ');\n+    body = replaced;\n+\n+    // (3) Replace paragraph markers with CR+CR:\n+    replaced = body.replace(/\\s*<p \\/>\\s*/g, '\\n\\n');\n+    body = replaced;\n+\n+    // (4) Replace 3 or more CRs with just two:\n+    replaced = repeatReplace(body, new RegExp('\\\\n{3,}', 'g'), '\\n\\n');\n+    body = replaced;\n+\n+    // (5) Trim excess at beginning and end:\n+    replaced = body.trim();\n+    body = replaced;\n+\n+    return body;\n+  }\n+\n+  /**\n+   * Determine luminance of a color so we can augment with darker/lighter background\n+   */\n+  luminance(color) {\n+    let bkColorLight = 'lightGray'; // or white\n+    let bkColorDark = 'darkGray'; // 'gray' is even darker\n+    let bkColorReturn = bkColorLight;\n+\n+    let re = new RegExp('rgb\\\\D+(\\\\d+)\\\\D+(\\\\d+)\\\\D+(\\\\d+)');\n+    let matched = color.match(re, 'i');\n+    if (matched && matched.length > 2) {\n+      // 0 is total string:\n+      let r = matched[1];\n+      let g = matched[2];\n+      let b = matched[3];\n+      // var 1 = matched[4]; // if alpha is provided\n+\n+      let luma = 0.2126 * r + 0.7152 * g + 0.0722 * b; // per ITU-R BT.709\n+\n+      if (luma < 40) {\n+        bkColorReturn = bkColorDark;\n+      } else {\n+        bkColorReturn = bkColorLight;\n+      }\n+    } else {\n+      bkColorReturn = bkColorLight; // RegExp failed, assume dark color\n+    }\n+\n+    return 'inherit'; // Use: bkColorReturn if you want to adjust background based on text perceived brightness\n+  }\n+\n+  /**\n+   * HTML bookend a string\n+   */\n+  bookend(bookend, text, style) {\n+    return (\n+      '<' +\n+      bookend +\n+      (style ? ' style=\"' + style + '\"' : '') +\n+      '>' +\n+      (text || '') +\n+      '</' +\n+      bookend +\n+      '>'\n+    );\n+  }\n+\n+  /**\n+   * Get selected text\n+   * http://stackoverflow.com/questions/5379120/get-the-highlighted-selected-text\n+   */\n+  getSelectedText() {\n+    let text = '';\n+    let activeEl = document.activeElement;\n+    let activeElTagName = activeEl ? activeEl.tagName.toLowerCase() : null;\n+    if (\n+      (activeElTagName == 'textarea' || activeElTagName == 'input') &&\n+      /^(?:text|search|password|tel|url)$/i.test(activeEl.type) &&\n+      typeof activeEl.selectionStart == 'number'\n+    ) {\n+      text = activeEl.value\n+        .slice(activeEl.selectionStart, activeEl.selectionEnd)\n+        .trim();\n+    } else if (document.selection) {\n+      text = document.selection.createRange().text.trim();\n+    } else if (document.getSelection) {\n+      text = document.getSelection().toString().trim();\n+    } else if (window.getSelection) {\n+      text = window.getSelection().toString().trim();\n+    }\n+    return text;\n+  }\n+\n+  /**\n+   * Truncate a string\n+   */\n+  truncate(text, max, add) {\n+    let retn = text || '';\n+    const add_k = this.decodeEntities(add || '');\n+    const max_k = max - add_k.length;\n+\n+    if (text && text.length > max_k) {\n+      retn = text.slice(0, max_k) + add_k;\n+    }\n+    return retn;\n+  }\n+\n+  /***\n+   * Middle-truncate a string\n+   */\n+  midTruncate(text, max, add) {\n+    let retn = text || '';\n+    const add_k = this.decodeEntities(add || '');\n+    const max_k = Math.abs((max || 0) - add_k.length);\n+    const mid_k = (max_k + 0.01) / 2;\n+\n+    if (text && text.length > max_k) {\n+      retn = text.slice(0, mid_k + 1) + add_k + text.slice(-mid_k);\n+    }\n+    return retn;\n+  }\n+\n+  /**\n+   * Load settings\n+   */\n+  loadSettings(popup) {\n+    const self = this;\n+    const setID = self.CHROME_SETTINGS_ID;\n+    chrome.storage.sync.get(setID, function (response) {\n+      if (response?.[setID]) {\n+        // NOTE (Ace, 7-Feb-2017): Might need to store these off the app object:\n+        try {\n+          self.popupView.data.settings = JSON.parse(response[setID]);\n+        } catch (err) {\n+          g2t_log(\n+            'loadSettings: JSON parse failed! Error: ' + JSON.stringify(err)\n+          );\n+        }\n+      }\n+      if (popup) {\n+        popup.init_popup();\n+        self.updateData();\n+      }\n+    });\n+  }\n+\n+  /**\n+   * Save settings\n+   */\n+  saveSettings() {\n+    const self = this;\n+    const setID = self.CHROME_SETTINGS_ID;\n+    let settings = Object.assign({}, self.popupView.data.settings);\n+\n+    // Delete large, potentially needing secure, data bits:\n+    settings.description = '';\n+    settings.title = '';\n+    settings.attachments = [];\n+    settings.images = [];\n+    delete settings.description;\n+    delete settings.title;\n+    delete settings.attachments;\n+    delete settings.images;\n+\n+    const settings_string_k = JSON.stringify(settings);\n+\n+    hash = {};\n+    hash[setID] = settings_string_k;\n+\n+    if (self.lastSettingsSave !== settings_string_k) {\n+      try {\n+        chrome.storage.sync.set(hash); // NOTE (Ace, 7-Feb-2017): Might need to store these off the app object\n+        self.lastSettingsSave = settings_string_k;\n+      } catch (error) {\n+        g2t_log(\n+          `saveSettings ERROR: extension context invalidated - failed \"chrome.storage.sync.set\"`\n+        );\n+        self?.popupView?.displayExtensionInvalidReload();\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Encode entities\n+   */\n+  encodeEntities(s) {\n+    let ta = document.createElement('textarea');\n+    ta.value = s;\n+    return ta.innerHTML;\n+    // jQuery way, less safe: return $(\"<textarea />\").text(s).html();\n+  }\n+\n+  /**\n+   * Decode entities\n+   */\n+  decodeEntities(s) {\n+    const self = this;\n+    const dict_k = { '...': '&hellip;', '*': '&bullet;', '-': '&mdash;' };\n+    let re, new_s;\n+    g2t_each(dict_k, function (value, key) {\n+      // value is already available from the callback parameter\n+      re = new RegExp(self.escapeRegExp(key), 'gi');\n+      new_s = s.replace(re, value);\n+      s = new_s;\n+    });\n+    try {\n+      new_s = decodeURIComponent(s);\n+      s = new_s;\n+    } catch (e) {\n+      // Didn't work. Ignore.\n+    }\n+    let ta = document.createElement('textarea');\n+    ta.style.cssText = 'white-space: pre-line;';\n+    ta.innerHTML = s;\n+    return ta.value;\n+    // jQuery way, less safe: return $(\"<textarea />\").html(s).text();\n+  }",
    "path": "chrome_manifest_v3/class_app.js",
    "commit_id": "3bbc7b0b5b5abfda366260c45d6f2cecebf28af3",
    "original_commit_id": "ae0a391b6759338b0ec3c3292da07e458841ab71",
    "user": {
      "login": "coderabbitai[bot]",
      "id": 136622811,
      "node_id": "BOT_kgDOCCSy2w",
      "avatar_url": "https://avatars.githubusercontent.com/in/347564?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/coderabbitai%5Bbot%5D",
      "html_url": "https://github.com/apps/coderabbitai",
      "followers_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/coderabbitai%5Bbot%5D/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "A summary of the changes CodeRabbit can apply:\n\n> - Update the `decodeEntities` method by renaming its parameter for clarity, eliminating parameter reassignment issues, replacing the external callback with an inline function, and remove the obsolete `decodeEntities_onEach` method to streamline entity decoding logic.\n\n- [ ] <!-- {\"checkboxId\": \"85e7c9f1-3a23-4b8e-9f25-d7a5b234a8c1\", \"radioGroupId\": \"edit-actions-group-2203840764\"} --> Created local commit - (🔄 Check again to try again)\n\n<!-- <agentComponentType>plan-edits</agentComponentType> -->\n\n<!-- <rawResChunk>Looking at the `decodeEntities` method, I need to fix the parameter reassignment issues and rename the parameter to be more meaningful. I can see the current implementation has problematic parameter passing with the callback that won't work correctly.\n\n<changeScript>\n```shell\n# Fix the decodeEntities method to avoid parameter reassignment and use meaningful names\nsed -i '/decodeEntities(s) {/,/}/c\\\n  decodeEntities(sourceText) {\\\n    const self = this;\\\n    const dict_k = { \"...\": \"&hellip;\", \"*\": \"&bullet;\", \"-\": \"&mdash;\" };\\\n    let re, new_s, result = sourceText;\\\n    g2t_each(dict_k, function (value, key) {\\\n      // value is already available from the callback parameter\\\n      re = new RegExp(self.escapeRegExp(key), \"gi\");\\\n      new_s = result.replace(re, value);\\\n      result = new_s;\\\n    });\\\n    try {\\\n      new_s = decodeURIComponent(result);\\\n      result = new_s;\\\n    } catch (e) {\\\n      // Didn'\\''t work. Ignore.\\\n    }\\\n    const ta = document.createElement(\"textarea\");\\\n    ta.style.cssText = \"white-space: pre-line;\";\\\n    ta.innerHTML = result;\\\n    return ta.value;\\\n    // jQuery way, less safe: return $(\"<textarea />\").html(s).text();\\\n  }' chrome_manifest_v3/class_app.js\n\n# Remove the now-unused decodeEntities_onEach callback method since we're using inline callback\nsed -i '/decodeEntities_onEach(s, re, new_s, value, key) {/,/}/d' chrome_manifest_v3/class_app.js\n```\n</changeScript></rawResChunk> -->\n\n<!-- <rawResChunk><planSummary>- Update the `decodeEntities` method by renaming its parameter for clarity, eliminating parameter reassignment issues, replacing the external callback with an inline function, and remove the obsolete `decodeEntities_onEach` method to streamline entity decoding logic.</planSummary></rawResChunk> -->\n\n<!-- This is an auto-generated reply by CodeRabbit -->",
    "created_at": "2025-07-14T04:48:20Z",
    "updated_at": "2025-07-14T05:03:02Z",
    "html_url": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203840764",
    "pull_request_url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203840764"
      },
      "html": {
        "href": "https://github.com/appliedmedia/gmail-2-trello/pull/61#discussion_r2203840764"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/61"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/appliedmedia/gmail-2-trello/pulls/comments/2203840764/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 774,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 795,
    "side": "RIGHT",
    "in_reply_to_id": 2203532568,
    "original_position": 795,
    "position": null,
    "subject_type": "line"
  }
]
